{"version":3,"file":"app.24d1030b88ca3cc3cc5f.js","mappings":"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","sources":["webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/Util.js","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/Types.js","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/Date.js","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/Numeric.js","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/RegExp.js","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/String.js","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/Option.js","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/Array.js","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/List.js","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/Global.js","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/AsyncBuilder.js","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/Choice.js","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/Async.js","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/Event.js","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/Observable.js","webpack:///./src/Client/output/fable_modules/Fable.Elmish.3.1.0/prelude.fs","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/Timer.js","webpack:///./src/Client/output/fable_modules/Fable.Elmish.3.1.0/cmd.fs","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/Seq.js","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/FSharp.Core.js","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/Range.js","webpack:///./src/Client/output/fable_modules/Fable.Elmish.3.1.0/ring.fs","webpack:///./src/Client/output/fable_modules/Fable.Elmish.React.3.0.1/common.fs","webpack:///../src/CineMol/CineMol.Types.fs","webpack:///../src/CineMol/CineMol.Helpers.fs","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/Reflection.js","webpack:///./src/Client/output/fable_modules/Fulma.2.16.0/Common.fs","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/MapUtil.js","webpack:///./src/Client/output/fable_modules/Fulma.2.16.0/Elements/Form/File.fs","webpack:///../src/CineMol/CineMol.Drawing.fs","webpack:///../src/CineMol/CineMol.Encoding.fs","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/Double.js","webpack:///./src/Client/output/fable_modules/fable-library.3.7.5/Int32.js","webpack:///../src/CineMol/CineMol.Parsing.fs","webpack:///../src/CineMol/CineMol.Style.fs","webpack:///./src/Client/output/fable_modules/Fable.FontAwesome.2.0.0/FontAwesome.fs","webpack:///./src/Client/output/fable_modules/Feliz.Bulma.2.18.0/ElementBuilders.fs","webpack:///./src/Client/Index.fs","webpack:///./src/Client/output/fable_modules/Fable.Elmish.React.3.0.1/react.fs","webpack:///./src/Client/output/fable_modules/Fable.Elmish.3.1.0/program.fs","webpack:///./src/Client/App.fs"],"sourcesContent":["// tslint:disable:ban-types\nexport function isIterable(x) {\n    return x != null && typeof x === \"object\" && Symbol.iterator in x;\n}\nexport function isArrayLike(x) {\n    return Array.isArray(x) || ArrayBuffer.isView(x);\n}\nfunction isComparer(x) {\n    return typeof x.Compare === \"function\";\n}\nfunction isComparable(x) {\n    return typeof x.CompareTo === \"function\";\n}\nfunction isEquatable(x) {\n    return typeof x.Equals === \"function\";\n}\nfunction isHashable(x) {\n    return typeof x.GetHashCode === \"function\";\n}\nexport function isDisposable(x) {\n    return x != null && typeof x.Dispose === \"function\";\n}\nexport function disposeSafe(x) {\n    if (isDisposable(x)) {\n        x.Dispose();\n    }\n}\nexport function sameConstructor(x, y) {\n    return Object.getPrototypeOf(x).constructor === Object.getPrototypeOf(y).constructor;\n}\nexport class Enumerator {\n    constructor(iter) {\n        this.iter = iter;\n    }\n    [\"System.Collections.Generic.IEnumerator`1.get_Current\"]() {\n        return this.current;\n    }\n    [\"System.Collections.IEnumerator.get_Current\"]() {\n        return this.current;\n    }\n    [\"System.Collections.IEnumerator.MoveNext\"]() {\n        const cur = this.iter.next();\n        this.current = cur.value;\n        return !cur.done;\n    }\n    [\"System.Collections.IEnumerator.Reset\"]() {\n        throw new Error(\"JS iterators cannot be reset\");\n    }\n    Dispose() {\n        return;\n    }\n}\nexport function getEnumerator(o) {\n    return typeof o.GetEnumerator === \"function\"\n        ? o.GetEnumerator()\n        : new Enumerator(o[Symbol.iterator]());\n}\nexport function toIterator(en) {\n    return {\n        [Symbol.iterator]() { return this; },\n        next() {\n            const hasNext = en[\"System.Collections.IEnumerator.MoveNext\"]();\n            const current = hasNext ? en[\"System.Collections.IEnumerator.get_Current\"]() : undefined;\n            return { done: !hasNext, value: current };\n        },\n    };\n}\nexport class Comparer {\n    constructor(f) {\n        this.Compare = f || compare;\n    }\n}\nexport function comparerFromEqualityComparer(comparer) {\n    // Sometimes IEqualityComparer also implements IComparer\n    if (isComparer(comparer)) {\n        return new Comparer(comparer.Compare);\n    }\n    else {\n        return new Comparer((x, y) => {\n            const xhash = comparer.GetHashCode(x);\n            const yhash = comparer.GetHashCode(y);\n            if (xhash === yhash) {\n                return comparer.Equals(x, y) ? 0 : -1;\n            }\n            else {\n                return xhash < yhash ? -1 : 1;\n            }\n        });\n    }\n}\nexport function assertEqual(actual, expected, msg) {\n    if (!equals(actual, expected)) {\n        throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n            actual,\n            expected,\n        });\n    }\n}\nexport function assertNotEqual(actual, expected, msg) {\n    if (equals(actual, expected)) {\n        throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n            actual,\n            expected,\n        });\n    }\n}\nexport class Lazy {\n    constructor(factory) {\n        this.factory = factory;\n        this.isValueCreated = false;\n    }\n    get Value() {\n        if (!this.isValueCreated) {\n            this.createdValue = this.factory();\n            this.isValueCreated = true;\n        }\n        return this.createdValue;\n    }\n    get IsValueCreated() {\n        return this.isValueCreated;\n    }\n}\nexport function lazyFromValue(v) {\n    return new Lazy(() => v);\n}\nexport function padWithZeros(i, length) {\n    let str = i.toString(10);\n    while (str.length < length) {\n        str = \"0\" + str;\n    }\n    return str;\n}\nexport function padLeftAndRightWithZeros(i, lengthLeft, lengthRight) {\n    let str = i.toString(10);\n    while (str.length < lengthLeft) {\n        str = \"0\" + str;\n    }\n    while (str.length < lengthRight) {\n        str = str + \"0\";\n    }\n    return str;\n}\nexport function dateOffset(date) {\n    const date1 = date;\n    return typeof date1.offset === \"number\"\n        ? date1.offset\n        : (date.kind === 1 /* UTC */\n            ? 0 : date.getTimezoneOffset() * -60000);\n}\nexport function int16ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nexport function int32ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFFFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nexport class ObjectRef {\n    static id(o) {\n        if (!ObjectRef.idMap.has(o)) {\n            ObjectRef.idMap.set(o, ++ObjectRef.count);\n        }\n        return ObjectRef.idMap.get(o);\n    }\n}\nObjectRef.idMap = new WeakMap();\nObjectRef.count = 0;\nexport function stringHash(s) {\n    let i = 0;\n    let h = 5381;\n    const len = s.length;\n    while (i < len) {\n        h = (h * 33) ^ s.charCodeAt(i++);\n    }\n    return h;\n}\nexport function numberHash(x) {\n    return x * 2654435761 | 0;\n}\n// From https://stackoverflow.com/a/37449594\nexport function combineHashCodes(hashes) {\n    if (hashes.length === 0) {\n        return 0;\n    }\n    return hashes.reduce((h1, h2) => {\n        return ((h1 << 5) + h1) ^ h2;\n    });\n}\nexport function physicalHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    switch (typeof x) {\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return numberHash(x);\n        case \"string\":\n            return stringHash(x);\n        default:\n            return numberHash(ObjectRef.id(x));\n    }\n}\nexport function identityHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    else if (isHashable(x)) {\n        return x.GetHashCode();\n    }\n    else {\n        return physicalHash(x);\n    }\n}\nexport function dateHash(x) {\n    return x.getTime();\n}\nexport function arrayHash(x) {\n    const len = x.length;\n    const hashes = new Array(len);\n    for (let i = 0; i < len; i++) {\n        hashes[i] = structuralHash(x[i]);\n    }\n    return combineHashCodes(hashes);\n}\nexport function structuralHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    switch (typeof x) {\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return numberHash(x);\n        case \"string\":\n            return stringHash(x);\n        default: {\n            if (isHashable(x)) {\n                return x.GetHashCode();\n            }\n            else if (isArrayLike(x)) {\n                return arrayHash(x);\n            }\n            else if (x instanceof Date) {\n                return dateHash(x);\n            }\n            else if (Object.getPrototypeOf(x).constructor === Object) {\n                // TODO: check call-stack to prevent cyclic objects?\n                const hashes = Object.values(x).map((v) => structuralHash(v));\n                return combineHashCodes(hashes);\n            }\n            else {\n                // Classes don't implement GetHashCode by default, but must use identity hashing\n                return numberHash(ObjectRef.id(x));\n                // return stringHash(String(x));\n            }\n        }\n    }\n}\n// Intended for custom numeric types, like long or decimal\nexport function fastStructuralHash(x) {\n    return stringHash(String(x));\n}\n// Intended for declared types that may or may not implement GetHashCode\nexport function safeHash(x) {\n    return x == null ? 0 : isHashable(x) ? x.GetHashCode() : numberHash(ObjectRef.id(x));\n}\nexport function equalArraysWith(x, y, eq) {\n    if (x == null) {\n        return y == null;\n    }\n    if (y == null) {\n        return false;\n    }\n    if (x.length !== y.length) {\n        return false;\n    }\n    for (let i = 0; i < x.length; i++) {\n        if (!eq(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function equalArrays(x, y) {\n    return equalArraysWith(x, y, equals);\n}\nfunction equalObjects(x, y) {\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) {\n        return false;\n    }\n    xKeys.sort();\n    yKeys.sort();\n    for (let i = 0; i < xKeys.length; i++) {\n        if (xKeys[i] !== yKeys[i] || !equals(x[xKeys[i]], y[yKeys[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function equals(x, y) {\n    if (x === y) {\n        return true;\n    }\n    else if (x == null) {\n        return y == null;\n    }\n    else if (y == null) {\n        return false;\n    }\n    else if (typeof x !== \"object\") {\n        return false;\n    }\n    else if (isEquatable(x)) {\n        return x.Equals(y);\n    }\n    else if (isArrayLike(x)) {\n        return isArrayLike(y) && equalArrays(x, y);\n    }\n    else if (x instanceof Date) {\n        return (y instanceof Date) && compareDates(x, y) === 0;\n    }\n    else {\n        return Object.getPrototypeOf(x).constructor === Object && equalObjects(x, y);\n    }\n}\nexport function compareDates(x, y) {\n    let xtime;\n    let ytime;\n    // DateTimeOffset and DateTime deals with equality differently.\n    if (\"offset\" in x && \"offset\" in y) {\n        xtime = x.getTime();\n        ytime = y.getTime();\n    }\n    else {\n        xtime = x.getTime() + dateOffset(x);\n        ytime = y.getTime() + dateOffset(y);\n    }\n    return xtime === ytime ? 0 : (xtime < ytime ? -1 : 1);\n}\nexport function comparePrimitives(x, y) {\n    return x === y ? 0 : (x < y ? -1 : 1);\n}\nexport function compareArraysWith(x, y, comp) {\n    if (x == null) {\n        return y == null ? 0 : 1;\n    }\n    if (y == null) {\n        return -1;\n    }\n    if (x.length !== y.length) {\n        return x.length < y.length ? -1 : 1;\n    }\n    for (let i = 0, j = 0; i < x.length; i++) {\n        j = comp(x[i], y[i]);\n        if (j !== 0) {\n            return j;\n        }\n    }\n    return 0;\n}\nexport function compareArrays(x, y) {\n    return compareArraysWith(x, y, compare);\n}\nfunction compareObjects(x, y) {\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) {\n        return xKeys.length < yKeys.length ? -1 : 1;\n    }\n    xKeys.sort();\n    yKeys.sort();\n    for (let i = 0, j = 0; i < xKeys.length; i++) {\n        const key = xKeys[i];\n        if (key !== yKeys[i]) {\n            return key < yKeys[i] ? -1 : 1;\n        }\n        else {\n            j = compare(x[key], y[key]);\n            if (j !== 0) {\n                return j;\n            }\n        }\n    }\n    return 0;\n}\nexport function compare(x, y) {\n    if (x === y) {\n        return 0;\n    }\n    else if (x == null) {\n        return y == null ? 0 : -1;\n    }\n    else if (y == null) {\n        return 1;\n    }\n    else if (typeof x !== \"object\") {\n        return x < y ? -1 : 1;\n    }\n    else if (isComparable(x)) {\n        return x.CompareTo(y);\n    }\n    else if (isArrayLike(x)) {\n        return isArrayLike(y) ? compareArrays(x, y) : -1;\n    }\n    else if (x instanceof Date) {\n        return y instanceof Date ? compareDates(x, y) : -1;\n    }\n    else {\n        return Object.getPrototypeOf(x).constructor === Object ? compareObjects(x, y) : -1;\n    }\n}\nexport function min(comparer, x, y) {\n    return comparer(x, y) < 0 ? x : y;\n}\nexport function max(comparer, x, y) {\n    return comparer(x, y) > 0 ? x : y;\n}\nexport function clamp(comparer, value, min, max) {\n    return (comparer(value, min) < 0) ? min : (comparer(value, max) > 0) ? max : value;\n}\nexport function createAtom(value) {\n    let atom = value;\n    return (value, isSetter) => {\n        if (!isSetter) {\n            return atom;\n        }\n        else {\n            atom = value;\n            return void 0;\n        }\n    };\n}\nexport function createObj(fields) {\n    const obj = {};\n    for (const kv of fields) {\n        obj[kv[0]] = kv[1];\n    }\n    return obj;\n}\nexport function jsOptions(mutator) {\n    const opts = {};\n    mutator(opts);\n    return opts;\n}\nexport function round(value, digits = 0) {\n    const m = Math.pow(10, digits);\n    const n = +(digits ? value * m : value).toFixed(8);\n    const i = Math.floor(n);\n    const f = n - i;\n    const e = 1e-8;\n    const r = (f > 0.5 - e && f < 0.5 + e) ? ((i % 2 === 0) ? i : i + 1) : Math.round(n);\n    return digits ? r / m : r;\n}\nexport function sign(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n}\nexport function unescapeDataString(s) {\n    // https://stackoverflow.com/a/4458580/524236\n    return decodeURIComponent((s).replace(/\\+/g, \"%20\"));\n}\nexport function escapeDataString(s) {\n    return encodeURIComponent(s).replace(/!/g, \"%21\")\n        .replace(/'/g, \"%27\")\n        .replace(/\\(/g, \"%28\")\n        .replace(/\\)/g, \"%29\")\n        .replace(/\\*/g, \"%2A\");\n}\nexport function escapeUriString(s) {\n    return encodeURI(s);\n}\n// ICollection.Clear and Count members can be called on Arrays\n// or Dictionaries so we need a runtime check (see #1120)\nexport function count(col) {\n    if (isArrayLike(col)) {\n        return col.length;\n    }\n    else {\n        let count = 0;\n        for (const _ of col) {\n            count++;\n        }\n        return count;\n    }\n}\nexport function clear(col) {\n    if (isArrayLike(col)) {\n        col.splice(0);\n    }\n    else {\n        col.clear();\n    }\n}\nconst CURRIED = Symbol(\"curried\");\nexport function uncurry(arity, f) {\n    // f may be a function option with None value\n    if (f == null || f.length > 1) {\n        return f;\n    }\n    const uncurried = (...args) => {\n        let res = f;\n        for (let i = 0; i < arity; i++) {\n            res = res(args[i]);\n        }\n        return res;\n    };\n    uncurried[CURRIED] = f;\n    return uncurried;\n}\nfunction _curry(args, arity, f) {\n    return (arg) => arity === 1\n        ? f(...args.concat([arg]))\n        // Note it's important to generate a new args array every time\n        // because a partially applied function can be run multiple times\n        : _curry(args.concat([arg]), arity - 1, f);\n}\nexport function curry(arity, f) {\n    if (f == null || f.length === 1) {\n        return f;\n    }\n    else if (CURRIED in f) {\n        return f[CURRIED];\n    }\n    else {\n        return _curry([], arity, f);\n    }\n}\nexport function checkArity(arity, f) {\n    return f.length > arity\n        ? (...args1) => (...args2) => f.apply(undefined, args1.concat(args2))\n        : f;\n}\nexport function partialApply(arity, f, args) {\n    if (f == null) {\n        return undefined;\n    }\n    else if (CURRIED in f) {\n        f = f[CURRIED];\n        for (let i = 0; i < args.length; i++) {\n            f = f(args[i]);\n        }\n        return f;\n    }\n    else {\n        return _curry(args, arity, f);\n    }\n}\nexport function mapCurriedArgs(fn, mappings) {\n    function mapArg(fn, arg, mappings, idx) {\n        const mapping = mappings[idx];\n        if (mapping !== 0) {\n            const expectedArity = mapping[0];\n            const actualArity = mapping[1];\n            if (expectedArity > 1) {\n                arg = curry(expectedArity, arg);\n            }\n            if (actualArity > 1) {\n                arg = uncurry(actualArity, arg);\n            }\n        }\n        const res = fn(arg);\n        if (idx + 1 === mappings.length) {\n            return res;\n        }\n        else {\n            return (arg) => mapArg(res, arg, mappings, idx + 1);\n        }\n    }\n    return (arg) => mapArg(fn, arg, mappings, 0);\n}\n","import { combineHashCodes, compare, compareArrays, equalArrays, equals, sameConstructor, numberHash, structuralHash } from \"./Util.js\";\nexport function seqToString(self) {\n    let count = 0;\n    let str = \"[\";\n    for (const x of self) {\n        if (count === 0) {\n            str += toString(x);\n        }\n        else if (count === 100) {\n            str += \"; ...\";\n            break;\n        }\n        else {\n            str += \"; \" + toString(x);\n        }\n        count++;\n    }\n    return str + \"]\";\n}\nexport function toString(x, callStack = 0) {\n    if (x != null && typeof x === \"object\") {\n        if (typeof x.toString === \"function\") {\n            return x.toString();\n        }\n        else if (Symbol.iterator in x) {\n            return seqToString(x);\n        }\n        else { // TODO: Date?\n            const cons = Object.getPrototypeOf(x).constructor;\n            return cons === Object && callStack < 10\n                // Same format as recordToString\n                ? \"{ \" + Object.entries(x).map(([k, v]) => k + \" = \" + toString(v, callStack + 1)).join(\"\\n  \") + \" }\"\n                : cons.name;\n        }\n    }\n    return String(x);\n}\nexport function unionToString(name, fields) {\n    if (fields.length === 0) {\n        return name;\n    }\n    else {\n        let fieldStr = \"\";\n        let withParens = true;\n        if (fields.length === 1) {\n            fieldStr = toString(fields[0]);\n            withParens = fieldStr.indexOf(\" \") >= 0;\n        }\n        else {\n            fieldStr = fields.map((x) => toString(x)).join(\", \");\n        }\n        return name + (withParens ? \" (\" : \" \") + fieldStr + (withParens ? \")\" : \"\");\n    }\n}\nexport class Union {\n    get name() {\n        return this.cases()[this.tag];\n    }\n    toJSON() {\n        return this.fields.length === 0 ? this.name : [this.name].concat(this.fields);\n    }\n    toString() {\n        return unionToString(this.name, this.fields);\n    }\n    GetHashCode() {\n        const hashes = this.fields.map((x) => structuralHash(x));\n        hashes.splice(0, 0, numberHash(this.tag));\n        return combineHashCodes(hashes);\n    }\n    Equals(other) {\n        if (this === other) {\n            return true;\n        }\n        else if (!sameConstructor(this, other)) {\n            return false;\n        }\n        else if (this.tag === other.tag) {\n            return equalArrays(this.fields, other.fields);\n        }\n        else {\n            return false;\n        }\n    }\n    CompareTo(other) {\n        if (this === other) {\n            return 0;\n        }\n        else if (!sameConstructor(this, other)) {\n            return -1;\n        }\n        else if (this.tag === other.tag) {\n            return compareArrays(this.fields, other.fields);\n        }\n        else {\n            return this.tag < other.tag ? -1 : 1;\n        }\n    }\n}\nfunction recordToJSON(self) {\n    const o = {};\n    const keys = Object.keys(self);\n    for (let i = 0; i < keys.length; i++) {\n        o[keys[i]] = self[keys[i]];\n    }\n    return o;\n}\nfunction recordToString(self) {\n    return \"{ \" + Object.entries(self).map(([k, v]) => k + \" = \" + toString(v)).join(\"\\n  \") + \" }\";\n}\nfunction recordGetHashCode(self) {\n    const hashes = Object.values(self).map((v) => structuralHash(v));\n    return combineHashCodes(hashes);\n}\nfunction recordEquals(self, other) {\n    if (self === other) {\n        return true;\n    }\n    else if (!sameConstructor(self, other)) {\n        return false;\n    }\n    else {\n        const thisNames = Object.keys(self);\n        for (let i = 0; i < thisNames.length; i++) {\n            if (!equals(self[thisNames[i]], other[thisNames[i]])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nfunction recordCompareTo(self, other) {\n    if (self === other) {\n        return 0;\n    }\n    else if (!sameConstructor(self, other)) {\n        return -1;\n    }\n    else {\n        const thisNames = Object.keys(self);\n        for (let i = 0; i < thisNames.length; i++) {\n            const result = compare(self[thisNames[i]], other[thisNames[i]]);\n            if (result !== 0) {\n                return result;\n            }\n        }\n        return 0;\n    }\n}\nexport class Record {\n    toJSON() { return recordToJSON(this); }\n    toString() { return recordToString(this); }\n    GetHashCode() { return recordGetHashCode(this); }\n    Equals(other) { return recordEquals(this, other); }\n    CompareTo(other) { return recordCompareTo(this, other); }\n}\nexport class FSharpRef {\n    constructor(contentsOrGetter, setter) {\n        if (typeof setter === \"function\") {\n            this.getter = contentsOrGetter;\n            this.setter = setter;\n        }\n        else {\n            this.getter = () => contentsOrGetter;\n            this.setter = (v) => { contentsOrGetter = v; };\n        }\n    }\n    get contents() {\n        return this.getter();\n    }\n    set contents(v) {\n        this.setter(v);\n    }\n}\n// EXCEPTIONS\n// Exception is intentionally not derived from Error, for performance reasons (see #2160)\nexport class Exception {\n    constructor(message) {\n        this.message = message;\n    }\n}\nexport function isException(x) {\n    return x instanceof Exception || x instanceof Error;\n}\nexport class FSharpException extends Exception {\n    toJSON() { return recordToJSON(this); }\n    toString() { return recordToString(this); }\n    GetHashCode() { return recordGetHashCode(this); }\n    Equals(other) { return recordEquals(this, other); }\n    CompareTo(other) { return recordCompareTo(this, other); }\n}\nexport class MatchFailureException extends FSharpException {\n    constructor(arg1, arg2, arg3) {\n        super();\n        this.arg1 = arg1;\n        this.arg2 = arg2 | 0;\n        this.arg3 = arg3 | 0;\n        this.message = \"The match cases were incomplete\";\n    }\n}\nexport class Attribute {\n}\n","/**\n * DateTimeOffset functions.\n *\n * Note: Date instances are always DateObjects in local\n * timezone (because JS dates are all kinds of messed up).\n * A local date returns UTC epoc when `.getTime()` is called.\n *\n * Basically; invariant: date.getTime() always return UTC time.\n */\nimport { fromValue, ticksToUnixEpochMilliseconds, unixEpochMillisecondsToTicks } from \"./Long.js\";\nimport { compareDates, dateOffset, padWithZeros } from \"./Util.js\";\nexport function dateOffsetToString(offset) {\n    const isMinus = offset < 0;\n    offset = Math.abs(offset);\n    const hours = ~~(offset / 3600000);\n    const minutes = (offset % 3600000) / 60000;\n    return (isMinus ? \"-\" : \"+\") +\n        padWithZeros(hours, 2) + \":\" +\n        padWithZeros(minutes, 2);\n}\nexport function dateToHalfUTCString(date, half) {\n    const str = date.toISOString();\n    return half === \"first\"\n        ? str.substring(0, str.indexOf(\"T\"))\n        : str.substring(str.indexOf(\"T\") + 1, str.length - 1);\n}\nfunction dateToISOString(d, utc) {\n    if (utc) {\n        return d.toISOString();\n    }\n    else {\n        // JS Date is always local\n        const printOffset = d.kind == null ? true : d.kind === 2 /* Local */;\n        return padWithZeros(d.getFullYear(), 4) + \"-\" +\n            padWithZeros(d.getMonth() + 1, 2) + \"-\" +\n            padWithZeros(d.getDate(), 2) + \"T\" +\n            padWithZeros(d.getHours(), 2) + \":\" +\n            padWithZeros(d.getMinutes(), 2) + \":\" +\n            padWithZeros(d.getSeconds(), 2) + \".\" +\n            padWithZeros(d.getMilliseconds(), 3) +\n            (printOffset ? dateOffsetToString(d.getTimezoneOffset() * -60000) : \"\");\n    }\n}\nfunction dateToISOStringWithOffset(dateWithOffset, offset) {\n    const str = dateWithOffset.toISOString();\n    return str.substring(0, str.length - 1) + dateOffsetToString(offset);\n}\nfunction dateToStringWithCustomFormat(date, format, utc) {\n    return format.replace(/(\\w)\\1*/g, (match) => {\n        let rep = Number.NaN;\n        switch (match.substring(0, 1)) {\n            case \"y\":\n                const y = utc ? date.getUTCFullYear() : date.getFullYear();\n                rep = match.length < 4 ? y % 100 : y;\n                break;\n            case \"M\":\n                rep = (utc ? date.getUTCMonth() : date.getMonth()) + 1;\n                break;\n            case \"d\":\n                rep = utc ? date.getUTCDate() : date.getDate();\n                break;\n            case \"H\":\n                rep = utc ? date.getUTCHours() : date.getHours();\n                break;\n            case \"h\":\n                const h = utc ? date.getUTCHours() : date.getHours();\n                rep = h > 12 ? h % 12 : h;\n                break;\n            case \"m\":\n                rep = utc ? date.getUTCMinutes() : date.getMinutes();\n                break;\n            case \"s\":\n                rep = utc ? date.getUTCSeconds() : date.getSeconds();\n                break;\n            case \"f\":\n                rep = utc ? date.getUTCMilliseconds() : date.getMilliseconds();\n                break;\n        }\n        if (Number.isNaN(rep)) {\n            return match;\n        }\n        else {\n            return (rep < 10 && match.length > 1) ? \"0\" + rep : \"\" + rep;\n        }\n    });\n}\nfunction dateToStringWithOffset(date, format) {\n    var _a, _b, _c;\n    const d = new Date(date.getTime() + ((_a = date.offset) !== null && _a !== void 0 ? _a : 0));\n    if (typeof format !== \"string\") {\n        return d.toISOString().replace(/\\.\\d+/, \"\").replace(/[A-Z]|\\.\\d+/g, \" \") + dateOffsetToString(((_b = date.offset) !== null && _b !== void 0 ? _b : 0));\n    }\n    else if (format.length === 1) {\n        switch (format) {\n            case \"D\":\n            case \"d\": return dateToHalfUTCString(d, \"first\");\n            case \"T\":\n            case \"t\": return dateToHalfUTCString(d, \"second\");\n            case \"O\":\n            case \"o\": return dateToISOStringWithOffset(d, ((_c = date.offset) !== null && _c !== void 0 ? _c : 0));\n            default: throw new Error(\"Unrecognized Date print format\");\n        }\n    }\n    else {\n        return dateToStringWithCustomFormat(d, format, true);\n    }\n}\nfunction dateToStringWithKind(date, format) {\n    const utc = date.kind === 1 /* UTC */;\n    if (typeof format !== \"string\") {\n        return utc ? date.toUTCString() : date.toLocaleString();\n    }\n    else if (format.length === 1) {\n        switch (format) {\n            case \"D\":\n            case \"d\":\n                return utc ? dateToHalfUTCString(date, \"first\") : date.toLocaleDateString();\n            case \"T\":\n            case \"t\":\n                return utc ? dateToHalfUTCString(date, \"second\") : date.toLocaleTimeString();\n            case \"O\":\n            case \"o\":\n                return dateToISOString(date, utc);\n            default:\n                throw new Error(\"Unrecognized Date print format\");\n        }\n    }\n    else {\n        return dateToStringWithCustomFormat(date, format, utc);\n    }\n}\nexport function toString(date, format, _provider) {\n    return date.offset != null\n        ? dateToStringWithOffset(date, format)\n        : dateToStringWithKind(date, format);\n}\nexport function DateTime(value, kind) {\n    const d = new Date(value);\n    d.kind = (kind == null ? 0 /* Unspecified */ : kind) | 0;\n    return d;\n}\nexport function fromTicks(ticks, kind) {\n    ticks = fromValue(ticks);\n    kind = kind != null ? kind : 2 /* Local */; // better default than Unspecified\n    let date = DateTime(ticksToUnixEpochMilliseconds(ticks), kind);\n    // Ticks are local to offset (in this case, either UTC or Local/Unknown).\n    // If kind is anything but UTC, that means that the tick number was not\n    // in utc, thus getTime() cannot return UTC, and needs to be shifted.\n    if (kind !== 1 /* UTC */) {\n        date = DateTime(date.getTime() - dateOffset(date), kind);\n    }\n    return date;\n}\nexport function fromDateTimeOffset(date, kind) {\n    var _a;\n    switch (kind) {\n        case 1 /* UTC */: return DateTime(date.getTime(), 1 /* UTC */);\n        case 2 /* Local */: return DateTime(date.getTime(), 2 /* Local */);\n        default:\n            const d = DateTime(date.getTime() + ((_a = date.offset) !== null && _a !== void 0 ? _a : 0), kind);\n            return DateTime(d.getTime() - dateOffset(d), kind);\n    }\n}\nexport function getTicks(date) {\n    return unixEpochMillisecondsToTicks(date.getTime(), dateOffset(date));\n}\nexport function minValue() {\n    // This is \"0001-01-01T00:00:00.000Z\", actual JS min value is -8640000000000000\n    return DateTime(-62135596800000, 0 /* Unspecified */);\n}\nexport function maxValue() {\n    // This is \"9999-12-31T23:59:59.999Z\", actual JS max value is 8640000000000000\n    return DateTime(253402300799999, 0 /* Unspecified */);\n}\nexport function parseRaw(input) {\n    function fail() {\n        throw new Error(`The string is not a valid Date: ${input}`);\n    }\n    if (input == null || input.trim() === \"\") {\n        fail();\n    }\n    // ISO dates without TZ are parsed as UTC. Adding time without TZ keeps them local.\n    if (input.length === 10 && input[4] === \"-\" && input[7] === \"-\") {\n        input += \"T00:00:00\";\n    }\n    let date = new Date(input);\n    let offset = null;\n    if (isNaN(date.getTime())) {\n        // Try to check strings JS Date cannot parse (see #1045, #1422)\n        // tslint:disable-next-line:max-line-length\n        const m = /^\\s*(\\d+[^\\w\\s:]\\d+[^\\w\\s:]\\d+)?\\s*(\\d+:\\d+(?::\\d+(?:\\.\\d+)?)?)?\\s*([AaPp][Mm])?\\s*(Z|[+-]([01]?\\d):?([0-5]?\\d)?)?\\s*$/.exec(input);\n        if (m != null) {\n            let baseDate;\n            let timeInSeconds = 0;\n            if (m[2] != null) {\n                const timeParts = m[2].split(\":\");\n                timeInSeconds =\n                    parseInt(timeParts[0], 10) * 3600 +\n                        parseInt(timeParts[1] || \"0\", 10) * 60 +\n                        parseFloat(timeParts[2] || \"0\");\n                if (m[3] != null && m[3].toUpperCase() === \"PM\") {\n                    timeInSeconds += 720;\n                }\n            }\n            if (m[4] != null) { // There's an offset, parse as UTC\n                if (m[1] != null) {\n                    baseDate = new Date(m[1] + \" UTC\");\n                }\n                else {\n                    const d = new Date();\n                    baseDate = new Date(d.getUTCFullYear() + \"/\" + (d.getUTCMonth() + 1) + \"/\" + d.getUTCDate());\n                }\n                if (m[4] === \"Z\") {\n                    offset = \"Z\";\n                }\n                else {\n                    let offsetInMinutes = parseInt(m[5], 10) * 60 + parseInt(m[6] || \"0\", 10);\n                    if (m[4][0] === \"-\") {\n                        offsetInMinutes *= -1;\n                    }\n                    offset = offsetInMinutes;\n                    timeInSeconds -= offsetInMinutes * 60;\n                }\n            }\n            else {\n                if (m[1] != null) {\n                    baseDate = new Date(m[1]);\n                }\n                else {\n                    const d = new Date();\n                    baseDate = new Date(d.getFullYear() + \"/\" + (d.getMonth() + 1) + \"/\" + d.getDate());\n                }\n            }\n            date = new Date(baseDate.getTime() + timeInSeconds * 1000);\n            // correct for daylight savings time\n            date = new Date(date.getTime() + (date.getTimezoneOffset() - baseDate.getTimezoneOffset()) * 60000);\n        }\n        else {\n            fail();\n        }\n        // Check again the date is valid after transformations, see #2229\n        if (isNaN(date.getTime())) {\n            fail();\n        }\n    }\n    return [date, offset];\n}\nexport function parse(str, detectUTC = false) {\n    const [date, offset] = parseRaw(str);\n    // .NET always parses DateTime as Local if there's offset info (even \"Z\")\n    // Newtonsoft.Json uses UTC if the offset is \"Z\"\n    const kind = offset != null\n        ? (detectUTC && offset === \"Z\" ? 1 /* UTC */ : 2 /* Local */)\n        : 0 /* Unspecified */;\n    return DateTime(date.getTime(), kind);\n}\nexport function tryParse(v, defValue) {\n    try {\n        defValue.contents = parse(v);\n        return true;\n    }\n    catch (_err) {\n        return false;\n    }\n}\nexport function create(year, month, day, h = 0, m = 0, s = 0, ms = 0, kind) {\n    const dateValue = kind === 1 /* UTC */\n        ? Date.UTC(year, month - 1, day, h, m, s, ms)\n        : new Date(year, month - 1, day, h, m, s, ms).getTime();\n    if (isNaN(dateValue)) {\n        throw new Error(\"The parameters describe an unrepresentable Date.\");\n    }\n    const date = DateTime(dateValue, kind);\n    if (year <= 99) {\n        date.setFullYear(year, month - 1, day);\n    }\n    return date;\n}\nexport function now() {\n    return DateTime(Date.now(), 2 /* Local */);\n}\nexport function utcNow() {\n    return DateTime(Date.now(), 1 /* UTC */);\n}\nexport function today() {\n    return date(now());\n}\nexport function isLeapYear(year) {\n    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n}\nexport function daysInMonth(year, month) {\n    return month === 2\n        ? (isLeapYear(year) ? 29 : 28)\n        : (month >= 8 ? (month % 2 === 0 ? 31 : 30) : (month % 2 === 0 ? 30 : 31));\n}\nexport function toUniversalTime(date) {\n    return date.kind === 1 /* UTC */ ? date : DateTime(date.getTime(), 1 /* UTC */);\n}\nexport function toLocalTime(date) {\n    return date.kind === 2 /* Local */ ? date : DateTime(date.getTime(), 2 /* Local */);\n}\nexport function specifyKind(d, kind) {\n    return create(year(d), month(d), day(d), hour(d), minute(d), second(d), millisecond(d), kind);\n}\nexport function timeOfDay(d) {\n    return hour(d) * 3600000\n        + minute(d) * 60000\n        + second(d) * 1000\n        + millisecond(d);\n}\nexport function date(d) {\n    return create(year(d), month(d), day(d), 0, 0, 0, 0, d.kind);\n}\nexport function day(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCDate() : d.getDate();\n}\nexport function hour(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCHours() : d.getHours();\n}\nexport function millisecond(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCMilliseconds() : d.getMilliseconds();\n}\nexport function minute(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCMinutes() : d.getMinutes();\n}\nexport function month(d) {\n    return (d.kind === 1 /* UTC */ ? d.getUTCMonth() : d.getMonth()) + 1;\n}\nexport function second(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCSeconds() : d.getSeconds();\n}\nexport function year(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCFullYear() : d.getFullYear();\n}\nexport function dayOfWeek(d) {\n    return d.kind === 1 /* UTC */ ? d.getUTCDay() : d.getDay();\n}\nexport function dayOfYear(d) {\n    const _year = year(d);\n    const _month = month(d);\n    let _day = day(d);\n    for (let i = 1; i < _month; i++) {\n        _day += daysInMonth(_year, i);\n    }\n    return _day;\n}\nexport function add(d, ts) {\n    const newDate = DateTime(d.getTime() + ts, d.kind);\n    if (d.kind === 2 /* Local */) {\n        const oldTzOffset = d.getTimezoneOffset();\n        const newTzOffset = newDate.getTimezoneOffset();\n        return oldTzOffset !== newTzOffset\n            ? DateTime(newDate.getTime() + (newTzOffset - oldTzOffset) * 60000, d.kind)\n            : newDate;\n    }\n    else {\n        return newDate;\n    }\n}\nexport function addDays(d, v) {\n    return add(d, v * 86400000);\n}\nexport function addHours(d, v) {\n    return add(d, v * 3600000);\n}\nexport function addMinutes(d, v) {\n    return add(d, v * 60000);\n}\nexport function addSeconds(d, v) {\n    return add(d, v * 1000);\n}\nexport function addMilliseconds(d, v) {\n    return add(d, v);\n}\nexport function addYears(d, v) {\n    const newMonth = month(d);\n    const newYear = year(d) + v;\n    const _daysInMonth = daysInMonth(newYear, newMonth);\n    const newDay = Math.min(_daysInMonth, day(d));\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind);\n}\nexport function addMonths(d, v) {\n    let newMonth = month(d) + v;\n    let newMonth_ = 0;\n    let yearOffset = 0;\n    if (newMonth > 12) {\n        newMonth_ = newMonth % 12;\n        yearOffset = Math.floor(newMonth / 12);\n        newMonth = newMonth_;\n    }\n    else if (newMonth < 1) {\n        newMonth_ = 12 + newMonth % 12;\n        yearOffset = Math.floor(newMonth / 12) + (newMonth_ === 12 ? -1 : 0);\n        newMonth = newMonth_;\n    }\n    const newYear = year(d) + yearOffset;\n    const _daysInMonth = daysInMonth(newYear, newMonth);\n    const newDay = Math.min(_daysInMonth, day(d));\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind);\n}\nexport function subtract(d, that) {\n    return typeof that === \"number\"\n        ? add(d, -that)\n        : d.getTime() - that.getTime();\n}\nexport function toLongDateString(d) {\n    return d.toDateString();\n}\nexport function toShortDateString(d) {\n    return d.toLocaleDateString();\n}\nexport function toLongTimeString(d) {\n    return d.toLocaleTimeString();\n}\nexport function toShortTimeString(d) {\n    return d.toLocaleTimeString().replace(/:\\d\\d(?!:)/, \"\");\n}\nexport function equals(d1, d2) {\n    return d1.getTime() === d2.getTime();\n}\nexport const compare = compareDates;\nexport const compareTo = compareDates;\nexport function op_Addition(x, y) {\n    return add(x, y);\n}\nexport function op_Subtraction(x, y) {\n    return subtract(x, y);\n}\nexport function isDaylightSavingTime(x) {\n    const jan = new Date(x.getFullYear(), 0, 1);\n    const jul = new Date(x.getFullYear(), 6, 1);\n    return isDST(jan.getTimezoneOffset(), jul.getTimezoneOffset(), x.getTimezoneOffset());\n}\nfunction isDST(janOffset, julOffset, tOffset) {\n    return Math.min(janOffset, julOffset) === tOffset;\n}\nexport default DateTime;\n","export const symbol = Symbol(\"numeric\");\nexport function isNumeric(x) {\n    return typeof x === \"number\" || (x === null || x === void 0 ? void 0 : x[symbol]);\n}\nexport function compare(x, y) {\n    if (typeof x === \"number\") {\n        return x < y ? -1 : (x > y ? 1 : 0);\n    }\n    else {\n        return x.CompareTo(y);\n    }\n}\nexport function multiply(x, y) {\n    if (typeof x === \"number\") {\n        return x * y;\n    }\n    else {\n        return x[symbol]().multiply(y);\n    }\n}\nexport function toFixed(x, dp) {\n    if (typeof x === \"number\") {\n        return x.toFixed(dp);\n    }\n    else {\n        return x[symbol]().toFixed(dp);\n    }\n}\nexport function toPrecision(x, sd) {\n    if (typeof x === \"number\") {\n        return x.toPrecision(sd);\n    }\n    else {\n        return x[symbol]().toPrecision(sd);\n    }\n}\nexport function toExponential(x, dp) {\n    if (typeof x === \"number\") {\n        return x.toExponential(dp);\n    }\n    else {\n        return x[symbol]().toExponential(dp);\n    }\n}\nexport function toHex(x) {\n    if (typeof x === \"number\") {\n        return (Number(x) >>> 0).toString(16);\n    }\n    else {\n        return x[symbol]().toHex();\n    }\n}\n","export function create(pattern, options = 0) {\n    // Supported RegexOptions\n    // * IgnoreCase:  0x0001\n    // * Multiline:   0x0002\n    // * Singleline:  0x0010\n    // * ECMAScript:  0x0100 (ignored)\n    if ((options & ~(1 ^ 2 ^ 16 ^ 256)) !== 0) {\n        throw new Error(\"RegexOptions only supports: IgnoreCase, Multiline, Singleline and ECMAScript\");\n    }\n    let flags = \"g\";\n    flags += options & 1 ? \"i\" : \"\"; // 0x0001 RegexOptions.IgnoreCase\n    flags += options & 2 ? \"m\" : \"\";\n    flags += options & 16 ? \"s\" : \"\";\n    return new RegExp(pattern, flags);\n}\n// From http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex\nexport function escape(str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n}\nexport function unescape(str) {\n    return str.replace(/\\\\([\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|])/g, \"$1\");\n}\nexport function isMatch(reg, input, startAt = 0) {\n    reg.lastIndex = startAt;\n    return reg.test(input);\n}\nexport function match(reg, input, startAt = 0) {\n    reg.lastIndex = startAt;\n    return reg.exec(input);\n}\nexport function matches(reg, input, startAt = 0) {\n    reg.lastIndex = startAt;\n    if (!reg.global) {\n        throw new Error(\"Non-global RegExp\"); // Prevent infinite loop\n    }\n    let m = reg.exec(input);\n    const matches = [];\n    while (m !== null) {\n        matches.push(m);\n        m = reg.exec(input);\n    }\n    return matches;\n}\nexport function options(reg) {\n    let options = 256; // ECMAScript\n    options |= reg.ignoreCase ? 1 : 0;\n    options |= reg.multiline ? 2 : 0;\n    return options;\n}\nexport function replace(reg, input, replacement, limit, offset = 0) {\n    function replacer() {\n        let res = arguments[0];\n        if (limit) {\n            limit--;\n            const match = [];\n            const len = arguments.length;\n            // arguments: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_function_as_a_parameter\n            // * match: matched substring\n            // * p1, p2, ...: nth capture group string\n            // * offset: offset of matched substring\n            // * string: whole string examined\n            // * groups: named capturing groups\n            //           ONLY if regex contains a named capture group AND browser supports named groups\n            // -> last element can be groups OR input string\n            // -> check if last element is string\n            const withGroups = typeof arguments[len - 1] !== \"string\";\n            let pLast = withGroups ? len - 3 : len - 2;\n            for (let i = 0; i < pLast; i++) {\n                match.push(arguments[i]);\n            }\n            match.index = arguments[pLast++];\n            match.input = arguments[pLast++];\n            if (withGroups) {\n                match.groups = arguments[pLast];\n            }\n            res = replacement(match);\n        }\n        return res;\n    }\n    if (typeof reg === \"string\") {\n        const tmp = reg;\n        reg = create(input, limit !== null && limit !== void 0 ? limit : 0);\n        input = tmp;\n        limit = undefined;\n    }\n    if (typeof replacement === \"function\") {\n        limit = limit == null ? -1 : limit;\n        return input.substring(0, offset) + input.substring(offset).replace(reg, replacer);\n    }\n    else {\n        replacement =\n            replacement\n                // $0 doesn't work with JS regex, see #1155\n                .replace(/\\$0/g, (_s) => \"$&\")\n                // named groups in replacement are `${name}` in .Net, but `$<name>` in JS (in regex: groups are `(?<name>...)` in both)\n                .replace(/\\${([^}]+)}/g, \"\\$<$1>\");\n        if (limit != null) {\n            let m;\n            const sub1 = input.substring(offset);\n            const _matches = matches(reg, sub1);\n            const sub2 = matches.length > limit ? (m = _matches[limit - 1], sub1.substring(0, m.index + m[0].length)) : sub1;\n            return input.substring(0, offset) + sub2.replace(reg, replacement)\n                + input.substring(offset + sub2.length);\n        }\n        else {\n            return input.replace(reg, replacement);\n        }\n    }\n}\nexport function split(reg, input, limit, offset = 0) {\n    if (typeof reg === \"string\") {\n        const tmp = reg;\n        reg = create(input, limit !== null && limit !== void 0 ? limit : 0);\n        input = tmp;\n        limit = undefined;\n    }\n    input = input.substring(offset);\n    return input.split(reg, limit);\n}\n","import { toString as dateToString } from \"./Date.js\";\nimport { compare as numericCompare, isNumeric, multiply, toExponential, toFixed, toHex, toPrecision } from \"./Numeric.js\";\nimport { escape } from \"./RegExp.js\";\nimport { toString } from \"./Types.js\";\nconst fsFormatRegExp = /(^|[^%])%([0+\\- ]*)(\\*|\\d+)?(?:\\.(\\d+))?(\\w)/g;\nconst interpolateRegExp = /(?:(^|[^%])%([0+\\- ]*)(\\d+)?(?:\\.(\\d+))?(\\w))?%P\\(\\)/g;\nconst formatRegExp = /\\{(\\d+)(,-?\\d+)?(?:\\:([a-zA-Z])(\\d{0,2})|\\:(.+?))?\\}/g;\nfunction isLessThan(x, y) {\n    return numericCompare(x, y) < 0;\n}\nfunction cmp(x, y, ic) {\n    function isIgnoreCase(i) {\n        return i === true ||\n            i === 1 /* CurrentCultureIgnoreCase */ ||\n            i === 3 /* InvariantCultureIgnoreCase */ ||\n            i === 5 /* OrdinalIgnoreCase */;\n    }\n    function isOrdinal(i) {\n        return i === 4 /* Ordinal */ ||\n            i === 5 /* OrdinalIgnoreCase */;\n    }\n    if (x == null) {\n        return y == null ? 0 : -1;\n    }\n    if (y == null) {\n        return 1;\n    } // everything is bigger than null\n    if (isOrdinal(ic)) {\n        if (isIgnoreCase(ic)) {\n            x = x.toLowerCase();\n            y = y.toLowerCase();\n        }\n        return (x === y) ? 0 : (x < y ? -1 : 1);\n    }\n    else {\n        if (isIgnoreCase(ic)) {\n            x = x.toLocaleLowerCase();\n            y = y.toLocaleLowerCase();\n        }\n        return x.localeCompare(y);\n    }\n}\nexport function compare(...args) {\n    switch (args.length) {\n        case 2: return cmp(args[0], args[1], false);\n        case 3: return cmp(args[0], args[1], args[2]);\n        case 4: return cmp(args[0], args[1], args[2] === true);\n        case 5: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), false);\n        case 6: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5]);\n        case 7: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5] === true);\n        default: throw new Error(\"String.compare: Unsupported number of parameters\");\n    }\n}\nexport function compareOrdinal(x, y) {\n    return cmp(x, y, 4 /* Ordinal */);\n}\nexport function compareTo(x, y) {\n    return cmp(x, y, 0 /* CurrentCulture */);\n}\nexport function startsWith(str, pattern, ic) {\n    if (str.length >= pattern.length) {\n        return cmp(str.substr(0, pattern.length), pattern, ic) === 0;\n    }\n    return false;\n}\nexport function indexOfAny(str, anyOf, ...args) {\n    if (str == null || str === \"\") {\n        return -1;\n    }\n    const startIndex = (args.length > 0) ? args[0] : 0;\n    if (startIndex < 0) {\n        throw new Error(\"Start index cannot be negative\");\n    }\n    const length = (args.length > 1) ? args[1] : str.length - startIndex;\n    if (length < 0) {\n        throw new Error(\"Length cannot be negative\");\n    }\n    if (length > str.length - startIndex) {\n        throw new Error(\"Invalid startIndex and length\");\n    }\n    str = str.substr(startIndex, length);\n    for (const c of anyOf) {\n        const index = str.indexOf(c);\n        if (index > -1) {\n            return index + startIndex;\n        }\n    }\n    return -1;\n}\nexport function printf(input) {\n    return {\n        input,\n        cont: fsFormat(input),\n    };\n}\nexport function interpolate(str, values) {\n    let valIdx = 0;\n    let strIdx = 0;\n    let result = \"\";\n    interpolateRegExp.lastIndex = 0;\n    let match = interpolateRegExp.exec(str);\n    while (match) {\n        // The first group corresponds to the no-escape char (^|[^%]), the actual pattern starts in the next char\n        // Note: we don't use negative lookbehind because some browsers don't support it yet\n        const matchIndex = match.index + (match[1] || \"\").length;\n        result += str.substring(strIdx, matchIndex).replace(/%%/g, \"%\");\n        const [, , flags, padLength, precision, format] = match;\n        result += formatReplacement(values[valIdx++], flags, padLength, precision, format);\n        strIdx = interpolateRegExp.lastIndex;\n        // Likewise we need to move interpolateRegExp.lastIndex one char behind to make sure we match the no-escape char next time\n        interpolateRegExp.lastIndex -= 1;\n        match = interpolateRegExp.exec(str);\n    }\n    result += str.substring(strIdx).replace(/%%/g, \"%\");\n    return result;\n}\nfunction continuePrint(cont, arg) {\n    return typeof arg === \"string\" ? cont(arg) : arg.cont(cont);\n}\nexport function toConsole(arg) {\n    // Don't remove the lambda here, see #1357\n    return continuePrint((x) => console.log(x), arg);\n}\nexport function toConsoleError(arg) {\n    return continuePrint((x) => console.error(x), arg);\n}\nexport function toText(arg) {\n    return continuePrint((x) => x, arg);\n}\nexport function toFail(arg) {\n    return continuePrint((x) => {\n        throw new Error(x);\n    }, arg);\n}\nfunction formatReplacement(rep, flags, padLength, precision, format) {\n    let sign = \"\";\n    flags = flags || \"\";\n    format = format || \"\";\n    if (isNumeric(rep)) {\n        if (format.toLowerCase() !== \"x\") {\n            if (isLessThan(rep, 0)) {\n                rep = multiply(rep, -1);\n                sign = \"-\";\n            }\n            else {\n                if (flags.indexOf(\" \") >= 0) {\n                    sign = \" \";\n                }\n                else if (flags.indexOf(\"+\") >= 0) {\n                    sign = \"+\";\n                }\n            }\n        }\n        precision = precision == null ? null : parseInt(precision, 10);\n        switch (format) {\n            case \"f\":\n            case \"F\":\n                precision = precision != null ? precision : 6;\n                rep = toFixed(rep, precision);\n                break;\n            case \"g\":\n            case \"G\":\n                rep = precision != null ? toPrecision(rep, precision) : toPrecision(rep);\n                break;\n            case \"e\":\n            case \"E\":\n                rep = precision != null ? toExponential(rep, precision) : toExponential(rep);\n                break;\n            case \"x\":\n                rep = toHex(rep);\n                break;\n            case \"X\":\n                rep = toHex(rep).toUpperCase();\n                break;\n            default: // AOid\n                rep = String(rep);\n                break;\n        }\n    }\n    else if (rep instanceof Date) {\n        rep = dateToString(rep);\n    }\n    else {\n        rep = toString(rep);\n    }\n    padLength = typeof padLength === \"number\" ? padLength : parseInt(padLength, 10);\n    if (!isNaN(padLength)) {\n        const zeroFlag = flags.indexOf(\"0\") >= 0; // Use '0' for left padding\n        const minusFlag = flags.indexOf(\"-\") >= 0; // Right padding\n        const ch = minusFlag || !zeroFlag ? \" \" : \"0\";\n        if (ch === \"0\") {\n            rep = padLeft(rep, padLength - sign.length, ch, minusFlag);\n            rep = sign + rep;\n        }\n        else {\n            rep = padLeft(sign + rep, padLength, ch, minusFlag);\n        }\n    }\n    else {\n        rep = sign + rep;\n    }\n    return rep;\n}\nfunction createPrinter(cont, _strParts, _matches, _result = \"\", padArg = -1) {\n    return (...args) => {\n        // Make copies of the values passed by reference because the function can be used multiple times\n        let result = _result;\n        const strParts = _strParts.slice();\n        const matches = _matches.slice();\n        for (const arg of args) {\n            const [, , flags, _padLength, precision, format] = matches[0];\n            let padLength = _padLength;\n            if (padArg >= 0) {\n                padLength = padArg;\n                padArg = -1;\n            }\n            else if (padLength === \"*\") {\n                if (arg < 0) {\n                    throw new Error(\"Non-negative number required\");\n                }\n                padArg = arg;\n                continue;\n            }\n            result += strParts[0];\n            result += formatReplacement(arg, flags, padLength, precision, format);\n            strParts.splice(0, 1);\n            matches.splice(0, 1);\n        }\n        if (matches.length === 0) {\n            result += strParts[0];\n            return cont(result);\n        }\n        else {\n            return createPrinter(cont, strParts, matches, result, padArg);\n        }\n    };\n}\nexport function fsFormat(str) {\n    return (cont) => {\n        fsFormatRegExp.lastIndex = 0;\n        const strParts = [];\n        const matches = [];\n        let strIdx = 0;\n        let match = fsFormatRegExp.exec(str);\n        while (match) {\n            // The first group corresponds to the no-escape char (^|[^%]), the actual pattern starts in the next char\n            // Note: we don't use negative lookbehind because some browsers don't support it yet\n            const matchIndex = match.index + (match[1] || \"\").length;\n            strParts.push(str.substring(strIdx, matchIndex).replace(/%%/g, \"%\"));\n            matches.push(match);\n            strIdx = fsFormatRegExp.lastIndex;\n            // Likewise we need to move fsFormatRegExp.lastIndex one char behind to make sure we match the no-escape char next time\n            fsFormatRegExp.lastIndex -= 1;\n            match = fsFormatRegExp.exec(str);\n        }\n        if (strParts.length === 0) {\n            return cont(str.replace(/%%/g, \"%\"));\n        }\n        else {\n            strParts.push(str.substring(strIdx).replace(/%%/g, \"%\"));\n            return createPrinter(cont, strParts, matches);\n        }\n    };\n}\nexport function format(str, ...args) {\n    if (typeof str === \"object\" && args.length > 0) {\n        // Called with culture info\n        str = args[0];\n        args.shift();\n    }\n    return str.replace(formatRegExp, (_, idx, padLength, format, precision, pattern) => {\n        if (idx < 0 || idx >= args.length) {\n            throw new Error(\"Index must be greater or equal to zero and less than the arguments' length.\");\n        }\n        let rep = args[idx];\n        if (isNumeric(rep)) {\n            precision = precision == null ? null : parseInt(precision, 10);\n            switch (format) {\n                case \"f\":\n                case \"F\":\n                    precision = precision != null ? precision : 2;\n                    rep = toFixed(rep, precision);\n                    break;\n                case \"g\":\n                case \"G\":\n                    rep = precision != null ? toPrecision(rep, precision) : toPrecision(rep);\n                    break;\n                case \"e\":\n                case \"E\":\n                    rep = precision != null ? toExponential(rep, precision) : toExponential(rep);\n                    break;\n                case \"p\":\n                case \"P\":\n                    precision = precision != null ? precision : 2;\n                    rep = toFixed(multiply(rep, 100), precision) + \" %\";\n                    break;\n                case \"d\":\n                case \"D\":\n                    rep = precision != null ? padLeft(String(rep), precision, \"0\") : String(rep);\n                    break;\n                case \"x\":\n                case \"X\":\n                    rep = precision != null ? padLeft(toHex(rep), precision, \"0\") : toHex(rep);\n                    if (format === \"X\") {\n                        rep = rep.toUpperCase();\n                    }\n                    break;\n                default:\n                    if (pattern) {\n                        let sign = \"\";\n                        rep = pattern.replace(/([0#,]+)(\\.[0#]+)?/, (_, intPart, decimalPart) => {\n                            if (isLessThan(rep, 0)) {\n                                rep = multiply(rep, -1);\n                                sign = \"-\";\n                            }\n                            const decimalPartLength = decimalPart != null ? decimalPart.length : 0;\n                            rep = toFixed(rep, Math.max(decimalPartLength - 1, 0));\n                            // Thousands separator\n                            if (intPart.indexOf(\",\") > 0) {\n                                const [intPart, decimalPart] = rep.split(\".\");\n                                const i = intPart.length % 3;\n                                const thousandGroups = Math.floor(intPart.length / 3);\n                                let thousands = i > 0 ? intPart.substr(0, i) + (thousandGroups > 0 ? \",\" : \"\") : \"\";\n                                for (let j = 0; j < thousandGroups; j++) {\n                                    thousands += intPart.substr(i + j * 3, 3) + (j < thousandGroups - 1 ? \",\" : \"\");\n                                }\n                                rep = decimalPart ? thousands + \".\" + decimalPart : thousands;\n                            }\n                            // In .NET you can mix 0/# placeholders but for simplicity we only check the left most character\n                            intPart = intPart.replace(/,/g, \"\");\n                            const intPartLength = intPart.length > 0 && intPart[0] === \"0\" ? intPart.length : 0;\n                            return padLeft(rep, intPartLength - sign.length + decimalPartLength, \"0\");\n                        });\n                        rep = sign + rep;\n                    }\n            }\n        }\n        else if (rep instanceof Date) {\n            rep = dateToString(rep, pattern || format);\n        }\n        else {\n            rep = toString(rep);\n        }\n        padLength = parseInt((padLength || \" \").substring(1), 10);\n        if (!isNaN(padLength)) {\n            rep = padLeft(String(rep), Math.abs(padLength), \" \", padLength < 0);\n        }\n        return rep;\n    });\n}\nexport function endsWith(str, search) {\n    const idx = str.lastIndexOf(search);\n    return idx >= 0 && idx === str.length - search.length;\n}\nexport function initialize(n, f) {\n    if (n < 0) {\n        throw new Error(\"String length must be non-negative\");\n    }\n    const xs = new Array(n);\n    for (let i = 0; i < n; i++) {\n        xs[i] = f(i);\n    }\n    return xs.join(\"\");\n}\nexport function insert(str, startIndex, value) {\n    if (startIndex < 0 || startIndex > str.length) {\n        throw new Error(\"startIndex is negative or greater than the length of this instance.\");\n    }\n    return str.substring(0, startIndex) + value + str.substring(startIndex);\n}\nexport function isNullOrEmpty(str) {\n    return typeof str !== \"string\" || str.length === 0;\n}\nexport function isNullOrWhiteSpace(str) {\n    return typeof str !== \"string\" || /^\\s*$/.test(str);\n}\nexport function concat(...xs) {\n    return xs.map((x) => String(x)).join(\"\");\n}\nexport function join(delimiter, xs) {\n    if (Array.isArray(xs)) {\n        return xs.join(delimiter);\n    }\n    else {\n        return Array.from(xs).join(delimiter);\n    }\n}\nexport function joinWithIndices(delimiter, xs, startIndex, count) {\n    const endIndexPlusOne = startIndex + count;\n    if (endIndexPlusOne > xs.length) {\n        throw new Error(\"Index and count must refer to a location within the buffer.\");\n    }\n    return xs.slice(startIndex, endIndexPlusOne).join(delimiter);\n}\nfunction notSupported(name) {\n    throw new Error(\"The environment doesn't support '\" + name + \"', please use a polyfill.\");\n}\nexport function toBase64String(inArray) {\n    let str = \"\";\n    for (let i = 0; i < inArray.length; i++) {\n        str += String.fromCharCode(inArray[i]);\n    }\n    return typeof btoa === \"function\" ? btoa(str) : notSupported(\"btoa\");\n}\nexport function fromBase64String(b64Encoded) {\n    const binary = typeof atob === \"function\" ? atob(b64Encoded) : notSupported(\"atob\");\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n}\nexport function padLeft(str, len, ch, isRight) {\n    ch = ch || \" \";\n    len = len - str.length;\n    for (let i = 0; i < len; i++) {\n        str = isRight ? str + ch : ch + str;\n    }\n    return str;\n}\nexport function padRight(str, len, ch) {\n    return padLeft(str, len, ch, true);\n}\nexport function remove(str, startIndex, count) {\n    if (startIndex >= str.length) {\n        throw new Error(\"startIndex must be less than length of string\");\n    }\n    if (typeof count === \"number\" && (startIndex + count) > str.length) {\n        throw new Error(\"Index and count must refer to a location within the string.\");\n    }\n    return str.slice(0, startIndex) + (typeof count === \"number\" ? str.substr(startIndex + count) : \"\");\n}\nexport function replace(str, search, replace) {\n    return str.replace(new RegExp(escape(search), \"g\"), replace);\n}\nexport function replicate(n, x) {\n    return initialize(n, () => x);\n}\nexport function getCharAtIndex(input, index) {\n    if (index < 0 || index >= input.length) {\n        throw new Error(\"Index was outside the bounds of the array.\");\n    }\n    return input[index];\n}\nexport function split(str, splitters, count, options) {\n    count = typeof count === \"number\" ? count : undefined;\n    options = typeof options === \"number\" ? options : 0;\n    if (count && count < 0) {\n        throw new Error(\"Count cannot be less than zero\");\n    }\n    if (count === 0) {\n        return [];\n    }\n    const removeEmpty = (options & 1) === 1;\n    const trim = (options & 2) === 2;\n    splitters = splitters || [];\n    splitters = splitters.filter(x => x).map(escape);\n    splitters = splitters.length > 0 ? splitters : [\"\\\\s\"];\n    const splits = [];\n    const reg = new RegExp(splitters.join(\"|\"), \"g\");\n    let findSplits = true;\n    let i = 0;\n    do {\n        const match = reg.exec(str);\n        if (match === null) {\n            const candidate = trim ? str.substring(i).trim() : str.substring(i);\n            if (!removeEmpty || candidate.length > 0) {\n                splits.push(candidate);\n            }\n            findSplits = false;\n        }\n        else {\n            const candidate = trim ? str.substring(i, match.index).trim() : str.substring(i, match.index);\n            if (!removeEmpty || candidate.length > 0) {\n                if (count != null && splits.length + 1 === count) {\n                    splits.push(trim ? str.substring(i).trim() : str.substring(i));\n                    findSplits = false;\n                }\n                else {\n                    splits.push(candidate);\n                }\n            }\n            i = reg.lastIndex;\n        }\n    } while (findSplits);\n    return splits;\n}\nexport function trim(str, ...chars) {\n    if (chars.length === 0) {\n        return str.trim();\n    }\n    const pattern = \"[\" + escape(chars.join(\"\")) + \"]+\";\n    return str.replace(new RegExp(\"^\" + pattern), \"\").replace(new RegExp(pattern + \"$\"), \"\");\n}\nexport function trimStart(str, ...chars) {\n    return chars.length === 0\n        ? str.trimStart()\n        : str.replace(new RegExp(\"^[\" + escape(chars.join(\"\")) + \"]+\"), \"\");\n}\nexport function trimEnd(str, ...chars) {\n    return chars.length === 0\n        ? str.trimEnd()\n        : str.replace(new RegExp(\"[\" + escape(chars.join(\"\")) + \"]+$\"), \"\");\n}\nexport function filter(pred, x) {\n    return x.split(\"\").filter((c) => pred(c)).join(\"\");\n}\nexport function substring(str, startIndex, length) {\n    if ((startIndex + (length || 0) > str.length)) {\n        throw new Error(\"Invalid startIndex and/or length\");\n    }\n    return length != null ? str.substr(startIndex, length) : str.substr(startIndex);\n}\nexport function fmt(strs, ...args) {\n    return ({ strs, args });\n}\nexport function fmtWith(fmts) {\n    return (strs, ...args) => ({ strs, args, fmts });\n}\nexport function getFormat(s) {\n    return s.fmts\n        ? s.strs.reduce((acc, newPart, index) => acc + `{${String(index - 1) + s.fmts[index - 1]}}` + newPart)\n        : s.strs.reduce((acc, newPart, index) => acc + `{${index - 1}}` + newPart);\n}\n","import { compare, equals, structuralHash } from \"./Util.js\";\n// Using a class here for better compatibility with TS files importing Some\nexport class Some {\n    constructor(value) {\n        this.value = value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    // Don't add \"Some\" for consistency with erased options\n    toString() {\n        return String(this.value);\n    }\n    GetHashCode() {\n        return structuralHash(this.value);\n    }\n    Equals(other) {\n        if (other == null) {\n            return false;\n        }\n        else {\n            return equals(this.value, other instanceof Some ? other.value : other);\n        }\n    }\n    CompareTo(other) {\n        if (other == null) {\n            return 1;\n        }\n        else {\n            return compare(this.value, other instanceof Some ? other.value : other);\n        }\n    }\n}\nexport function some(x) {\n    return x == null || x instanceof Some ? new Some(x) : x;\n}\nexport function value(x) {\n    if (x == null) {\n        throw new Error(\"Option has no value\");\n    }\n    else {\n        return x instanceof Some ? x.value : x;\n    }\n}\nexport function ofNullable(x) {\n    // This will fail with unit probably, an alternative would be:\n    // return x === null ? undefined : (x === undefined ? new Some(x) : x);\n    return x == null ? undefined : x;\n}\nexport function toNullable(x) {\n    return x == null ? null : value(x);\n}\nexport function flatten(x) {\n    return x == null ? undefined : value(x);\n}\nexport function toArray(opt) {\n    return (opt == null) ? [] : [value(opt)];\n}\nexport function defaultArg(opt, defaultValue) {\n    return (opt != null) ? value(opt) : defaultValue;\n}\nexport function defaultArgWith(opt, defThunk) {\n    return (opt != null) ? value(opt) : defThunk();\n}\nexport function filter(predicate, opt) {\n    return (opt != null) ? (predicate(value(opt)) ? opt : undefined) : opt;\n}\nexport function map(mapping, opt) {\n    return (opt != null) ? some(mapping(value(opt))) : undefined;\n}\nexport function map2(mapping, opt1, opt2) {\n    return (opt1 != null && opt2 != null) ? mapping(value(opt1), value(opt2)) : undefined;\n}\nexport function map3(mapping, opt1, opt2, opt3) {\n    return (opt1 != null && opt2 != null && opt3 != null) ? mapping(value(opt1), value(opt2), value(opt3)) : undefined;\n}\nexport function bind(binder, opt) {\n    return opt != null ? binder(value(opt)) : undefined;\n}\nexport function tryOp(op, arg) {\n    try {\n        return some(op(arg));\n    }\n    catch (_a) {\n        return undefined;\n    }\n}\n","import { value as value_2, defaultArg, some } from \"./Option.js\";\r\nimport { min as min_1, disposeSafe, getEnumerator, comparePrimitives, max as max_1 } from \"./Util.js\";\r\nimport { SR_indexOutOfBounds } from \"./Global.js\";\r\n\r\nexport function Helpers_allocateArrayFromCons(cons, len) {\r\n    if ((typeof cons) === \"function\") {\r\n        return new cons(len);\r\n    }\r\n    else {\r\n        return new Array(len);\r\n    }\r\n}\r\n\r\nfunction indexNotFound() {\r\n    throw (new Error(\"An index satisfying the predicate was not found in the collection.\"));\r\n}\r\n\r\nfunction differentLengths() {\r\n    throw (new Error(\"Arrays had different lengths\"));\r\n}\r\n\r\nexport function append(array1, array2, cons) {\r\n    const len1 = array1.length | 0;\r\n    const len2 = array2.length | 0;\r\n    const newArray = Helpers_allocateArrayFromCons(cons, len1 + len2);\r\n    for (let i = 0; i <= (len1 - 1); i++) {\r\n        newArray[i] = array1[i];\r\n    }\r\n    for (let i_1 = 0; i_1 <= (len2 - 1); i_1++) {\r\n        newArray[i_1 + len1] = array2[i_1];\r\n    }\r\n    return newArray;\r\n}\r\n\r\nexport function filter(predicate, array) {\r\n    return array.filter(predicate);\r\n}\r\n\r\nexport function fill(target, targetIndex, count, value) {\r\n    const start = targetIndex | 0;\r\n    return target.fill(value, start, (start + count));\r\n}\r\n\r\nexport function getSubArray(array, start, count) {\r\n    const start_1 = start | 0;\r\n    return array.slice(start_1, (start_1 + count));\r\n}\r\n\r\nexport function last(array) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"The input array was empty\\\\nParameter name: array\"));\r\n    }\r\n    return array[array.length - 1];\r\n}\r\n\r\nexport function tryLast(array) {\r\n    if (array.length === 0) {\r\n        return void 0;\r\n    }\r\n    else {\r\n        return some(array[array.length - 1]);\r\n    }\r\n}\r\n\r\nexport function mapIndexed(f, source, cons) {\r\n    const len = source.length | 0;\r\n    const target = Helpers_allocateArrayFromCons(cons, len);\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        target[i] = f(i, source[i]);\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function map(f, source, cons) {\r\n    const len = source.length | 0;\r\n    const target = Helpers_allocateArrayFromCons(cons, len);\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        target[i] = f(source[i]);\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function mapIndexed2(f, source1, source2, cons) {\r\n    if (source1.length !== source2.length) {\r\n        throw (new Error(\"Arrays had different lengths\"));\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\r\n    for (let i = 0; i <= (source1.length - 1); i++) {\r\n        result[i] = f(i, source1[i], source2[i]);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function map2(f, source1, source2, cons) {\r\n    if (source1.length !== source2.length) {\r\n        throw (new Error(\"Arrays had different lengths\"));\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\r\n    for (let i = 0; i <= (source1.length - 1); i++) {\r\n        result[i] = f(source1[i], source2[i]);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function mapIndexed3(f, source1, source2, source3, cons) {\r\n    if ((source1.length !== source2.length) ? true : (source2.length !== source3.length)) {\r\n        throw (new Error(\"Arrays had different lengths\"));\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\r\n    for (let i = 0; i <= (source1.length - 1); i++) {\r\n        result[i] = f(i, source1[i], source2[i], source3[i]);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function map3(f, source1, source2, source3, cons) {\r\n    if ((source1.length !== source2.length) ? true : (source2.length !== source3.length)) {\r\n        throw (new Error(\"Arrays had different lengths\"));\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\r\n    for (let i = 0; i <= (source1.length - 1); i++) {\r\n        result[i] = f(source1[i], source2[i], source3[i]);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function mapFold(mapping, state, array, cons) {\r\n    const matchValue = array.length | 0;\r\n    if (matchValue === 0) {\r\n        return [[], state];\r\n    }\r\n    else {\r\n        let acc = state;\r\n        const res = Helpers_allocateArrayFromCons(cons, matchValue);\r\n        for (let i = 0; i <= (array.length - 1); i++) {\r\n            const patternInput = mapping(acc, array[i]);\r\n            res[i] = patternInput[0];\r\n            acc = patternInput[1];\r\n        }\r\n        return [res, acc];\r\n    }\r\n}\r\n\r\nexport function mapFoldBack(mapping, array, state, cons) {\r\n    const matchValue = array.length | 0;\r\n    if (matchValue === 0) {\r\n        return [[], state];\r\n    }\r\n    else {\r\n        let acc = state;\r\n        const res = Helpers_allocateArrayFromCons(cons, matchValue);\r\n        for (let i = array.length - 1; i >= 0; i--) {\r\n            const patternInput = mapping(array[i], acc);\r\n            res[i] = patternInput[0];\r\n            acc = patternInput[1];\r\n        }\r\n        return [res, acc];\r\n    }\r\n}\r\n\r\nexport function indexed(source) {\r\n    const len = source.length | 0;\r\n    const target = new Array(len);\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        target[i] = [i, source[i]];\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function truncate(count, array) {\r\n    const count_1 = max_1(comparePrimitives, 0, count) | 0;\r\n    const start = 0;\r\n    return array.slice(start, (start + count_1));\r\n}\r\n\r\nexport function concat(arrays, cons) {\r\n    const arrays_1 = Array.isArray(arrays) ? arrays : (Array.from(arrays));\r\n    const matchValue = arrays_1.length | 0;\r\n    switch (matchValue) {\r\n        case 0: {\r\n            return Helpers_allocateArrayFromCons(cons, 0);\r\n        }\r\n        case 1: {\r\n            return arrays_1[0];\r\n        }\r\n        default: {\r\n            let totalIdx = 0;\r\n            let totalLength = 0;\r\n            for (let idx = 0; idx <= (arrays_1.length - 1); idx++) {\r\n                const arr_1 = arrays_1[idx];\r\n                totalLength = ((totalLength + arr_1.length) | 0);\r\n            }\r\n            const result = Helpers_allocateArrayFromCons(cons, totalLength);\r\n            for (let idx_1 = 0; idx_1 <= (arrays_1.length - 1); idx_1++) {\r\n                const arr_2 = arrays_1[idx_1];\r\n                for (let j = 0; j <= (arr_2.length - 1); j++) {\r\n                    result[totalIdx] = arr_2[j];\r\n                    totalIdx = ((totalIdx + 1) | 0);\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\nexport function collect(mapping, array, cons) {\r\n    return concat(map(mapping, array, null), cons);\r\n}\r\n\r\nexport function where(predicate, array) {\r\n    return array.filter(predicate);\r\n}\r\n\r\nexport function contains(value, array, eq) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i >= array.length) {\r\n                return false;\r\n            }\r\n            else if (eq.Equals(value, array[i])) {\r\n                return true;\r\n            }\r\n            else {\r\n                i_mut = (i + 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0);\r\n}\r\n\r\nexport function empty(cons) {\r\n    return Helpers_allocateArrayFromCons(cons, 0);\r\n}\r\n\r\nexport function singleton(value, cons) {\r\n    const ar = Helpers_allocateArrayFromCons(cons, 1);\r\n    ar[0] = value;\r\n    return ar;\r\n}\r\n\r\nexport function initialize(count, initializer, cons) {\r\n    if (count < 0) {\r\n        throw (new Error(\"The input must be non-negative\\\\nParameter name: count\"));\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, count);\r\n    for (let i = 0; i <= (count - 1); i++) {\r\n        result[i] = initializer(i);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function pairwise(array) {\r\n    if (array.length < 2) {\r\n        return [];\r\n    }\r\n    else {\r\n        const count = (array.length - 1) | 0;\r\n        const result = new Array(count);\r\n        for (let i = 0; i <= (count - 1); i++) {\r\n            result[i] = [array[i], array[i + 1]];\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport function replicate(count, initial, cons) {\r\n    if (count < 0) {\r\n        throw (new Error(\"The input must be non-negative\\\\nParameter name: count\"));\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, count);\r\n    for (let i = 0; i <= (result.length - 1); i++) {\r\n        result[i] = initial;\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function copy(array) {\r\n    return array.slice();\r\n}\r\n\r\nexport function reverse(array) {\r\n    const array_2 = array.slice();\r\n    return array_2.reverse();\r\n}\r\n\r\nexport function scan(folder, state, array, cons) {\r\n    const res = Helpers_allocateArrayFromCons(cons, array.length + 1);\r\n    res[0] = state;\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        res[i + 1] = folder(res[i], array[i]);\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function scanBack(folder, array, state, cons) {\r\n    const res = Helpers_allocateArrayFromCons(cons, array.length + 1);\r\n    res[array.length] = state;\r\n    for (let i = array.length - 1; i >= 0; i--) {\r\n        res[i] = folder(array[i], res[i + 1]);\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function skip(count, array, cons) {\r\n    if (count > array.length) {\r\n        throw (new Error(\"count is greater than array length\\\\nParameter name: count\"));\r\n    }\r\n    if (count === array.length) {\r\n        return Helpers_allocateArrayFromCons(cons, 0);\r\n    }\r\n    else {\r\n        const count_1 = ((count < 0) ? 0 : count) | 0;\r\n        return array.slice(count_1);\r\n    }\r\n}\r\n\r\nexport function skipWhile(predicate, array, cons) {\r\n    let count = 0;\r\n    while ((count < array.length) && predicate(array[count])) {\r\n        count = ((count + 1) | 0);\r\n    }\r\n    if (count === array.length) {\r\n        return Helpers_allocateArrayFromCons(cons, 0);\r\n    }\r\n    else {\r\n        const count_1 = count | 0;\r\n        return array.slice(count_1);\r\n    }\r\n}\r\n\r\nexport function take(count, array, cons) {\r\n    if (count < 0) {\r\n        throw (new Error(\"The input must be non-negative\\\\nParameter name: count\"));\r\n    }\r\n    if (count > array.length) {\r\n        throw (new Error(\"count is greater than array length\\\\nParameter name: count\"));\r\n    }\r\n    if (count === 0) {\r\n        return Helpers_allocateArrayFromCons(cons, 0);\r\n    }\r\n    else {\r\n        const start = 0;\r\n        return array.slice(start, (start + count));\r\n    }\r\n}\r\n\r\nexport function takeWhile(predicate, array, cons) {\r\n    let count = 0;\r\n    while ((count < array.length) && predicate(array[count])) {\r\n        count = ((count + 1) | 0);\r\n    }\r\n    if (count === 0) {\r\n        return Helpers_allocateArrayFromCons(cons, 0);\r\n    }\r\n    else {\r\n        const start = 0;\r\n        const count_1 = count | 0;\r\n        return array.slice(start, (start + count_1));\r\n    }\r\n}\r\n\r\nexport function addInPlace(x, array) {\r\n    array.push(x);\r\n}\r\n\r\nexport function addRangeInPlace(range, array) {\r\n    const enumerator = getEnumerator(range);\r\n    try {\r\n        while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            addInPlace(enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), array);\r\n        }\r\n    }\r\n    finally {\r\n        disposeSafe(enumerator);\r\n    }\r\n}\r\n\r\nexport function insertRangeInPlace(index, range, array) {\r\n    let index_1;\r\n    let i = index;\r\n    const enumerator = getEnumerator(range);\r\n    try {\r\n        while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            const x = enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n            (index_1 = (i | 0), array.splice(index_1, 0, x));\r\n            i = ((i + 1) | 0);\r\n        }\r\n    }\r\n    finally {\r\n        disposeSafe(enumerator);\r\n    }\r\n}\r\n\r\nexport function removeInPlace(item_1, array) {\r\n    const i = (array.indexOf(item_1, 0)) | 0;\r\n    if (i > -1) {\r\n        array.splice(i, 1);\r\n        return true;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function removeAllInPlace(predicate, array) {\r\n    const countRemoveAll = (count) => {\r\n        const i = (array.findIndex(predicate)) | 0;\r\n        if (i > -1) {\r\n            array.splice(i, 1);\r\n            return (countRemoveAll(count) + 1) | 0;\r\n        }\r\n        else {\r\n            return count | 0;\r\n        }\r\n    };\r\n    return countRemoveAll(0) | 0;\r\n}\r\n\r\nexport function copyTo(source, sourceIndex, target, targetIndex, count) {\r\n    const diff = (targetIndex - sourceIndex) | 0;\r\n    for (let i = sourceIndex; i <= ((sourceIndex + count) - 1); i++) {\r\n        target[i + diff] = source[i];\r\n    }\r\n}\r\n\r\nexport function copyToTypedArray(source, sourceIndex, target, targetIndex, count) {\r\n    try {\r\n        target.set(source.subarray(sourceIndex, sourceIndex + count), targetIndex);\r\n    }\r\n    catch (matchValue) {\r\n        copyTo(source, sourceIndex, target, targetIndex, count);\r\n    }\r\n}\r\n\r\nexport function indexOf(array, item_1, start, count) {\r\n    const start_1 = defaultArg(start, 0) | 0;\r\n    const i = (array.indexOf(item_1, start_1)) | 0;\r\n    if ((count != null) && (i >= (start_1 + value_2(count)))) {\r\n        return -1;\r\n    }\r\n    else {\r\n        return i | 0;\r\n    }\r\n}\r\n\r\nexport function partition(f, source, cons) {\r\n    const len = source.length | 0;\r\n    const res1 = Helpers_allocateArrayFromCons(cons, len);\r\n    const res2 = Helpers_allocateArrayFromCons(cons, len);\r\n    let iTrue = 0;\r\n    let iFalse = 0;\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        if (f(source[i])) {\r\n            res1[iTrue] = source[i];\r\n            iTrue = ((iTrue + 1) | 0);\r\n        }\r\n        else {\r\n            res2[iFalse] = source[i];\r\n            iFalse = ((iFalse + 1) | 0);\r\n        }\r\n    }\r\n    return [truncate(iTrue, res1), truncate(iFalse, res2)];\r\n}\r\n\r\nexport function find(predicate, array) {\r\n    const matchValue = array.find(predicate);\r\n    if (matchValue == null) {\r\n        return indexNotFound();\r\n    }\r\n    else {\r\n        return value_2(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFind(predicate, array) {\r\n    return array.find(predicate);\r\n}\r\n\r\nexport function findIndex(predicate, array) {\r\n    const matchValue = (array.findIndex(predicate)) | 0;\r\n    if (matchValue > -1) {\r\n        return matchValue | 0;\r\n    }\r\n    else {\r\n        return indexNotFound() | 0;\r\n    }\r\n}\r\n\r\nexport function tryFindIndex(predicate, array) {\r\n    const matchValue = (array.findIndex(predicate)) | 0;\r\n    if (matchValue > -1) {\r\n        return matchValue;\r\n    }\r\n    else {\r\n        return void 0;\r\n    }\r\n}\r\n\r\nexport function pick(chooser, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i >= array.length) {\r\n                return indexNotFound();\r\n            }\r\n            else {\r\n                const matchValue = chooser(array[i]);\r\n                if (matchValue != null) {\r\n                    return value_2(matchValue);\r\n                }\r\n                else {\r\n                    i_mut = (i + 1);\r\n                    continue loop;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0);\r\n}\r\n\r\nexport function tryPick(chooser, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i >= array.length) {\r\n                return void 0;\r\n            }\r\n            else {\r\n                const matchValue = chooser(array[i]);\r\n                if (matchValue == null) {\r\n                    i_mut = (i + 1);\r\n                    continue loop;\r\n                }\r\n                else {\r\n                    return matchValue;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0);\r\n}\r\n\r\nexport function findBack(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return indexNotFound();\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return array[i];\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1);\r\n}\r\n\r\nexport function tryFindBack(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return void 0;\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return some(array[i]);\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1);\r\n}\r\n\r\nexport function findLastIndex(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return -1;\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return i | 0;\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1) | 0;\r\n}\r\n\r\nexport function findIndexBack(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return indexNotFound() | 0;\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return i | 0;\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1) | 0;\r\n}\r\n\r\nexport function tryFindIndexBack(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return void 0;\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return i;\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1);\r\n}\r\n\r\nexport function choose(chooser, array, cons) {\r\n    const res = [];\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        const matchValue = chooser(array[i]);\r\n        if (matchValue != null) {\r\n            const y = value_2(matchValue);\r\n            res.push(y);\r\n        }\r\n    }\r\n    if ((typeof cons) === \"function\") {\r\n        return map((x) => x, res, cons);\r\n    }\r\n    else {\r\n        return res;\r\n    }\r\n}\r\n\r\nexport function foldIndexed(folder, state, array) {\r\n    return array.reduce(((delegateArg0, delegateArg1, delegateArg2) => folder(delegateArg2, delegateArg0, delegateArg1)), state);\r\n}\r\n\r\nexport function fold(folder, state, array) {\r\n    return array.reduce((folder), state);\r\n}\r\n\r\nexport function iterate(action, array) {\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        action(array[i]);\r\n    }\r\n}\r\n\r\nexport function iterateIndexed(action, array) {\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        action(i, array[i]);\r\n    }\r\n}\r\n\r\nexport function iterate2(action, array1, array2) {\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        action(array1[i], array2[i]);\r\n    }\r\n}\r\n\r\nexport function iterateIndexed2(action, array1, array2) {\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        action(i, array1[i], array2[i]);\r\n    }\r\n}\r\n\r\nexport function isEmpty(array) {\r\n    return array.length === 0;\r\n}\r\n\r\nexport function forAll(predicate, array) {\r\n    return array.every(predicate);\r\n}\r\n\r\nexport function permute(f, array) {\r\n    const size = array.length | 0;\r\n    const res = array.slice();\r\n    const checkFlags = new Array(size);\r\n    iterateIndexed((i, x) => {\r\n        const j = f(i) | 0;\r\n        if ((j < 0) ? true : (j >= size)) {\r\n            throw (new Error(\"Not a valid permutation\"));\r\n        }\r\n        res[j] = x;\r\n        checkFlags[j] = 1;\r\n    }, array);\r\n    if (!(checkFlags.every((y) => (1 === y)))) {\r\n        throw (new Error(\"Not a valid permutation\"));\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function setSlice(target, lower, upper, source) {\r\n    const lower_1 = defaultArg(lower, 0) | 0;\r\n    const upper_1 = defaultArg(upper, 0) | 0;\r\n    const length = (((upper_1 > 0) ? upper_1 : (target.length - 1)) - lower_1) | 0;\r\n    for (let i = 0; i <= length; i++) {\r\n        target[i + lower_1] = source[i];\r\n    }\r\n}\r\n\r\nexport function sortInPlaceBy(projection, xs, comparer) {\r\n    xs.sort((x, y) => comparer.Compare(projection(x), projection(y)));\r\n}\r\n\r\nexport function sortInPlace(xs, comparer) {\r\n    xs.sort((x, y) => comparer.Compare(x, y));\r\n}\r\n\r\nexport function sort(xs, comparer) {\r\n    const xs_1 = xs.slice();\r\n    xs_1.sort((x, y) => comparer.Compare(x, y));\r\n    return xs_1;\r\n}\r\n\r\nexport function sortBy(projection, xs, comparer) {\r\n    const xs_1 = xs.slice();\r\n    return (xs_1.sort((x, y) => comparer.Compare(projection(x), projection(y))), xs_1);\r\n}\r\n\r\nexport function sortDescending(xs, comparer) {\r\n    const xs_1 = xs.slice();\r\n    xs_1.sort((x, y) => (comparer.Compare(x, y) * -1));\r\n    return xs_1;\r\n}\r\n\r\nexport function sortByDescending(projection, xs, comparer) {\r\n    const xs_1 = xs.slice();\r\n    return (xs_1.sort((x, y) => (comparer.Compare(projection(x), projection(y)) * -1)), xs_1);\r\n}\r\n\r\nexport function sortWith(comparer, xs) {\r\n    const comparer_1 = comparer;\r\n    const xs_1 = xs.slice();\r\n    xs_1.sort(comparer_1);\r\n    return xs_1;\r\n}\r\n\r\nexport function allPairs(xs, ys) {\r\n    const len1 = xs.length | 0;\r\n    const len2 = ys.length | 0;\r\n    const res = new Array(len1 * len2);\r\n    for (let i = 0; i <= (xs.length - 1); i++) {\r\n        for (let j = 0; j <= (ys.length - 1); j++) {\r\n            res[(i * len2) + j] = [xs[i], ys[j]];\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function unfold(generator, state) {\r\n    const res = [];\r\n    const loop = (state_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const state_1 = state_1_mut;\r\n            const matchValue = generator(state_1);\r\n            if (matchValue != null) {\r\n                const x = matchValue[0];\r\n                const s = matchValue[1];\r\n                res.push(x);\r\n                state_1_mut = s;\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    loop(state);\r\n    return res;\r\n}\r\n\r\nexport function unzip(array) {\r\n    const len = array.length | 0;\r\n    const res1 = new Array(len);\r\n    const res2 = new Array(len);\r\n    iterateIndexed((i, tupledArg) => {\r\n        res1[i] = tupledArg[0];\r\n        res2[i] = tupledArg[1];\r\n    }, array);\r\n    return [res1, res2];\r\n}\r\n\r\nexport function unzip3(array) {\r\n    const len = array.length | 0;\r\n    const res1 = new Array(len);\r\n    const res2 = new Array(len);\r\n    const res3 = new Array(len);\r\n    iterateIndexed((i, tupledArg) => {\r\n        res1[i] = tupledArg[0];\r\n        res2[i] = tupledArg[1];\r\n        res3[i] = tupledArg[2];\r\n    }, array);\r\n    return [res1, res2, res3];\r\n}\r\n\r\nexport function zip(array1, array2) {\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    const result = new Array(array1.length);\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        result[i] = [array1[i], array2[i]];\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function zip3(array1, array2, array3) {\r\n    if ((array1.length !== array2.length) ? true : (array2.length !== array3.length)) {\r\n        differentLengths();\r\n    }\r\n    const result = new Array(array1.length);\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        result[i] = [array1[i], array2[i], array3[i]];\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function chunkBySize(chunkSize, array) {\r\n    if (chunkSize < 1) {\r\n        throw (new Error(\"The input must be positive.\\\\nParameter name: size\"));\r\n    }\r\n    if (array.length === 0) {\r\n        return [[]];\r\n    }\r\n    else {\r\n        const result = [];\r\n        for (let x = 0; x <= ((~(~Math.ceil(array.length / chunkSize))) - 1); x++) {\r\n            let slice;\r\n            const start_1 = (x * chunkSize) | 0;\r\n            slice = (array.slice(start_1, (start_1 + chunkSize)));\r\n            result.push(slice);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport function splitAt(index, array) {\r\n    let start;\r\n    if ((index < 0) ? true : (index > array.length)) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    return [(start = 0, array.slice(start, (start + index))), array.slice(index)];\r\n}\r\n\r\nexport function compareWith(comparer, array1, array2) {\r\n    if (array1 == null) {\r\n        if (array2 == null) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    }\r\n    else if (array2 == null) {\r\n        return 1;\r\n    }\r\n    else {\r\n        let i = 0;\r\n        let result = 0;\r\n        const length1 = array1.length | 0;\r\n        const length2 = array2.length | 0;\r\n        if (length1 > length2) {\r\n            return 1;\r\n        }\r\n        else if (length1 < length2) {\r\n            return -1;\r\n        }\r\n        else {\r\n            while ((i < length1) && (result === 0)) {\r\n                result = (comparer(array1[i], array2[i]) | 0);\r\n                i = ((i + 1) | 0);\r\n            }\r\n            return result | 0;\r\n        }\r\n    }\r\n}\r\n\r\nexport function equalsWith(equals, array1, array2) {\r\n    if (array1 == null) {\r\n        if (array2 == null) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    else if (array2 == null) {\r\n        return false;\r\n    }\r\n    else {\r\n        let i = 0;\r\n        let result = true;\r\n        const length1 = array1.length | 0;\r\n        const length2 = array2.length | 0;\r\n        if (length1 > length2) {\r\n            return false;\r\n        }\r\n        else if (length1 < length2) {\r\n            return false;\r\n        }\r\n        else {\r\n            while ((i < length1) && result) {\r\n                result = equals(array1[i], array2[i]);\r\n                i = ((i + 1) | 0);\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\nexport function exactlyOne(array) {\r\n    if (array.length === 1) {\r\n        return array[0];\r\n    }\r\n    else if (array.length === 0) {\r\n        throw (new Error(\"The input sequence was empty\\\\nParameter name: array\"));\r\n    }\r\n    else {\r\n        throw (new Error(\"Input array too long\\\\nParameter name: array\"));\r\n    }\r\n}\r\n\r\nexport function tryExactlyOne(array) {\r\n    if (array.length === 1) {\r\n        return some(array[0]);\r\n    }\r\n    else {\r\n        return void 0;\r\n    }\r\n}\r\n\r\nexport function head(array) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"The input array was empty\\\\nParameter name: array\"));\r\n    }\r\n    else {\r\n        return array[0];\r\n    }\r\n}\r\n\r\nexport function tryHead(array) {\r\n    if (array.length === 0) {\r\n        return void 0;\r\n    }\r\n    else {\r\n        return some(array[0]);\r\n    }\r\n}\r\n\r\nexport function tail(array) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"Not enough elements\\\\nParameter name: array\"));\r\n    }\r\n    return array.slice(1);\r\n}\r\n\r\nexport function item(index, array) {\r\n    return array[index];\r\n}\r\n\r\nexport function tryItem(index, array) {\r\n    if ((index < 0) ? true : (index >= array.length)) {\r\n        return void 0;\r\n    }\r\n    else {\r\n        return some(array[index]);\r\n    }\r\n}\r\n\r\nexport function foldBackIndexed(folder, array, state) {\r\n    return array.reduceRight(((delegateArg0, delegateArg1, delegateArg2) => folder(delegateArg2, delegateArg1, delegateArg0)), state);\r\n}\r\n\r\nexport function foldBack(folder, array, state) {\r\n    return array.reduceRight(((delegateArg0, delegateArg1) => folder(delegateArg1, delegateArg0)), state);\r\n}\r\n\r\nexport function foldIndexed2(folder, state, array1, array2) {\r\n    let acc = state;\r\n    if (array1.length !== array2.length) {\r\n        throw (new Error(\"Arrays have different lengths\"));\r\n    }\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        acc = folder(i, acc, array1[i], array2[i]);\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function fold2(folder, state, array1, array2) {\r\n    return foldIndexed2((_arg1, acc, x, y) => folder(acc, x, y), state, array1, array2);\r\n}\r\n\r\nexport function foldBackIndexed2(folder, array1, array2, state) {\r\n    let acc = state;\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    const size = array1.length | 0;\r\n    for (let i = 1; i <= size; i++) {\r\n        acc = folder(i - 1, array1[size - i], array2[size - i], acc);\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function foldBack2(f, array1, array2, state) {\r\n    return foldBackIndexed2((_arg1, x, y, acc) => f(x, y, acc), array1, array2, state);\r\n}\r\n\r\nexport function reduce(reduction, array) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"The input array was empty\"));\r\n    }\r\n    const reduction_1 = reduction;\r\n    return array.reduce(reduction_1);\r\n}\r\n\r\nexport function reduceBack(reduction, array) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"The input array was empty\"));\r\n    }\r\n    const reduction_1 = reduction;\r\n    return array.reduceRight(reduction_1);\r\n}\r\n\r\nexport function forAll2(predicate, array1, array2) {\r\n    return fold2((acc, x, y) => (acc && predicate(x, y)), true, array1, array2);\r\n}\r\n\r\nexport function existsOffset(predicate_mut, array_mut, index_mut) {\r\n    existsOffset:\r\n    while (true) {\r\n        const predicate = predicate_mut, array = array_mut, index = index_mut;\r\n        if (index === array.length) {\r\n            return false;\r\n        }\r\n        else if (predicate(array[index])) {\r\n            return true;\r\n        }\r\n        else {\r\n            predicate_mut = predicate;\r\n            array_mut = array;\r\n            index_mut = (index + 1);\r\n            continue existsOffset;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function exists(predicate, array) {\r\n    return existsOffset(predicate, array, 0);\r\n}\r\n\r\nexport function existsOffset2(predicate_mut, array1_mut, array2_mut, index_mut) {\r\n    existsOffset2:\r\n    while (true) {\r\n        const predicate = predicate_mut, array1 = array1_mut, array2 = array2_mut, index = index_mut;\r\n        if (index === array1.length) {\r\n            return false;\r\n        }\r\n        else if (predicate(array1[index], array2[index])) {\r\n            return true;\r\n        }\r\n        else {\r\n            predicate_mut = predicate;\r\n            array1_mut = array1;\r\n            array2_mut = array2;\r\n            index_mut = (index + 1);\r\n            continue existsOffset2;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function exists2(predicate, array1, array2) {\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    return existsOffset2(predicate, array1, array2, 0);\r\n}\r\n\r\nexport function sum(array, adder) {\r\n    let acc = adder.GetZero();\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        acc = adder.Add(acc, array[i]);\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function sumBy(projection, array, adder) {\r\n    let acc = adder.GetZero();\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        acc = adder.Add(acc, projection(array[i]));\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function maxBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function max(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function minBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function min(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function average(array, averager) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"The input array was empty\\\\nParameter name: array\"));\r\n    }\r\n    let total = averager.GetZero();\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        total = averager.Add(total, array[i]);\r\n    }\r\n    return averager.DivideByInt(total, array.length);\r\n}\r\n\r\nexport function averageBy(projection, array, averager) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"The input array was empty\\\\nParameter name: array\"));\r\n    }\r\n    let total = averager.GetZero();\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        total = averager.Add(total, projection(array[i]));\r\n    }\r\n    return averager.DivideByInt(total, array.length);\r\n}\r\n\r\nexport function windowed(windowSize, source) {\r\n    if (windowSize <= 0) {\r\n        throw (new Error(\"windowSize must be positive\"));\r\n    }\r\n    let res;\r\n    const len = max_1(comparePrimitives, 0, (source.length - windowSize) + 1) | 0;\r\n    res = (new Array(len));\r\n    for (let i = windowSize; i <= source.length; i++) {\r\n        res[i - windowSize] = source.slice(i - windowSize, (i - 1) + 1);\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function splitInto(chunks, array) {\r\n    if (chunks < 1) {\r\n        throw (new Error(\"The input must be positive.\\\\nParameter name: chunks\"));\r\n    }\r\n    if (array.length === 0) {\r\n        return [[]];\r\n    }\r\n    else {\r\n        const result = [];\r\n        const chunks_1 = min_1(comparePrimitives, chunks, array.length) | 0;\r\n        const minChunkSize = (~(~(array.length / chunks_1))) | 0;\r\n        const chunksWithExtraItem = (array.length % chunks_1) | 0;\r\n        for (let i = 0; i <= (chunks_1 - 1); i++) {\r\n            const chunkSize = ((i < chunksWithExtraItem) ? (minChunkSize + 1) : minChunkSize) | 0;\r\n            let slice;\r\n            const start_1 = ((i * minChunkSize) + min_1(comparePrimitives, chunksWithExtraItem, i)) | 0;\r\n            slice = (array.slice(start_1, (start_1 + chunkSize)));\r\n            result.push(slice);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport function transpose(arrays, cons) {\r\n    const arrays_1 = Array.isArray(arrays) ? arrays : (Array.from(arrays));\r\n    const len = arrays_1.length | 0;\r\n    if (len === 0) {\r\n        return new Array(0);\r\n    }\r\n    else {\r\n        const firstArray = arrays_1[0];\r\n        const lenInner = firstArray.length | 0;\r\n        if (!forAll((a) => (a.length === lenInner), arrays_1)) {\r\n            differentLengths();\r\n        }\r\n        const result = new Array(lenInner);\r\n        for (let i = 0; i <= (lenInner - 1); i++) {\r\n            result[i] = Helpers_allocateArrayFromCons(cons, len);\r\n            for (let j = 0; j <= (len - 1); j++) {\r\n                result[i][j] = arrays_1[j][i];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport function insertAt(index, y, xs) {\r\n    const len = xs.length | 0;\r\n    if ((index < 0) ? true : (index > len)) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    const target = new xs.constructor(len + 1);\r\n    for (let i = 0; i <= (index - 1); i++) {\r\n        target[i] = xs[i];\r\n    }\r\n    target[index] = y;\r\n    for (let i_1 = index; i_1 <= (len - 1); i_1++) {\r\n        target[i_1 + 1] = xs[i_1];\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function insertManyAt(index, ys, xs) {\r\n    const len = xs.length | 0;\r\n    if ((index < 0) ? true : (index > len)) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    const ys_1 = Array.from(ys);\r\n    const len2 = ys_1.length | 0;\r\n    const target = new xs.constructor(len + len2);\r\n    for (let i = 0; i <= (index - 1); i++) {\r\n        target[i] = xs[i];\r\n    }\r\n    for (let i_1 = 0; i_1 <= (len2 - 1); i_1++) {\r\n        target[index + i_1] = ys_1[i_1];\r\n    }\r\n    for (let i_2 = index; i_2 <= (len - 1); i_2++) {\r\n        target[i_2 + len2] = xs[i_2];\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function removeAt(index, xs) {\r\n    if ((index < 0) ? true : (index >= xs.length)) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    let i = -1;\r\n    return filter((_arg1) => {\r\n        i = ((i + 1) | 0);\r\n        return i !== index;\r\n    }, xs);\r\n}\r\n\r\nexport function removeManyAt(index, count, xs) {\r\n    let i = -1;\r\n    let status = -1;\r\n    const ys = filter((_arg1) => {\r\n        i = ((i + 1) | 0);\r\n        if (i === index) {\r\n            status = 0;\r\n            return false;\r\n        }\r\n        else if (i > index) {\r\n            if (i < (index + count)) {\r\n                return false;\r\n            }\r\n            else {\r\n                status = 1;\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }, xs);\r\n    const status_1 = (((status === 0) && ((i + 1) === (index + count))) ? 1 : status) | 0;\r\n    if (status_1 < 1) {\r\n        const arg = (status_1 < 0) ? \"index\" : \"count\";\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + arg));\r\n    }\r\n    return ys;\r\n}\r\n\r\nexport function updateAt(index, y, xs) {\r\n    const len = xs.length | 0;\r\n    if ((index < 0) ? true : (index >= len)) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    const target = new xs.constructor(len);\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        target[i] = ((i === index) ? y : xs[i]);\r\n    }\r\n    return target;\r\n}\r\n\r\n","import { join } from \"./String.js\";\r\nimport { uncurry, disposeSafe, isArrayLike, getEnumerator, toIterator, compare, structuralHash, equals } from \"./Util.js\";\r\nimport { Record } from \"./Types.js\";\r\nimport { class_type, record_type, option_type } from \"./Reflection.js\";\r\nimport { SR_inputSequenceTooLong, SR_inputSequenceEmpty, SR_inputMustBeNonNegative, SR_notEnoughElements, SR_differentLengths, SR_keyNotFoundAlt, SR_indexOutOfBounds, SR_inputWasEmpty } from \"./Global.js\";\r\nimport { defaultArg, value as value_1, some } from \"./Option.js\";\r\nimport { transpose as transpose_1, splitInto as splitInto_1, windowed as windowed_1, pairwise as pairwise_1, chunkBySize as chunkBySize_1, map as map_1, permute as permute_1, tryFindIndexBack as tryFindIndexBack_1, tryFindBack as tryFindBack_1, scanBack as scanBack_1, foldBack2 as foldBack2_1, foldBack as foldBack_1, fill } from \"./Array.js\";\r\n\r\nexport class FSharpList extends Record {\r\n    constructor(head, tail) {\r\n        super();\r\n        this.head = head;\r\n        this.tail = tail;\r\n    }\r\n    toString() {\r\n        const xs = this;\r\n        return (\"[\" + join(\"; \", xs)) + \"]\";\r\n    }\r\n    Equals(other) {\r\n        const xs = this;\r\n        if (xs === other) {\r\n            return true;\r\n        }\r\n        else {\r\n            const loop = (xs_1_mut, ys_1_mut) => {\r\n                loop:\r\n                while (true) {\r\n                    const xs_1 = xs_1_mut, ys_1 = ys_1_mut;\r\n                    const matchValue = [xs_1.tail, ys_1.tail];\r\n                    if (matchValue[0] != null) {\r\n                        if (matchValue[1] != null) {\r\n                            const xt = matchValue[0];\r\n                            const yt = matchValue[1];\r\n                            if (equals(xs_1.head, ys_1.head)) {\r\n                                xs_1_mut = xt;\r\n                                ys_1_mut = yt;\r\n                                continue loop;\r\n                            }\r\n                            else {\r\n                                return false;\r\n                            }\r\n                        }\r\n                        else {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    else if (matchValue[1] != null) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        return true;\r\n                    }\r\n                    break;\r\n                }\r\n            };\r\n            return loop(xs, other);\r\n        }\r\n    }\r\n    GetHashCode() {\r\n        const xs = this;\r\n        const loop = (i_mut, h_mut, xs_1_mut) => {\r\n            loop:\r\n            while (true) {\r\n                const i = i_mut, h = h_mut, xs_1 = xs_1_mut;\r\n                const matchValue = xs_1.tail;\r\n                if (matchValue != null) {\r\n                    const t = matchValue;\r\n                    if (i > 18) {\r\n                        return h | 0;\r\n                    }\r\n                    else {\r\n                        i_mut = (i + 1);\r\n                        h_mut = (((h << 1) + structuralHash(xs_1.head)) + (631 * i));\r\n                        xs_1_mut = t;\r\n                        continue loop;\r\n                    }\r\n                }\r\n                else {\r\n                    return h | 0;\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        return loop(0, 0, xs) | 0;\r\n    }\r\n    toJSON(_key) {\r\n        const this$ = this;\r\n        return Array.from(this$);\r\n    }\r\n    CompareTo(other) {\r\n        const xs = this;\r\n        const loop = (xs_1_mut, ys_1_mut) => {\r\n            loop:\r\n            while (true) {\r\n                const xs_1 = xs_1_mut, ys_1 = ys_1_mut;\r\n                const matchValue = [xs_1.tail, ys_1.tail];\r\n                if (matchValue[0] != null) {\r\n                    if (matchValue[1] != null) {\r\n                        const xt = matchValue[0];\r\n                        const yt = matchValue[1];\r\n                        const c = compare(xs_1.head, ys_1.head) | 0;\r\n                        if (c === 0) {\r\n                            xs_1_mut = xt;\r\n                            ys_1_mut = yt;\r\n                            continue loop;\r\n                        }\r\n                        else {\r\n                            return c | 0;\r\n                        }\r\n                    }\r\n                    else {\r\n                        return 1;\r\n                    }\r\n                }\r\n                else if (matchValue[1] != null) {\r\n                    return -1;\r\n                }\r\n                else {\r\n                    return 0;\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        return loop(xs, other) | 0;\r\n    }\r\n    GetEnumerator() {\r\n        const xs = this;\r\n        return ListEnumerator$1_$ctor_3002E699(xs);\r\n    }\r\n    [Symbol.iterator]() {\r\n        return toIterator(this.GetEnumerator());\r\n    }\r\n    [\"System.Collections.IEnumerable.GetEnumerator\"]() {\r\n        const xs = this;\r\n        return getEnumerator(xs);\r\n    }\r\n}\r\n\r\nexport function FSharpList$reflection(gen0) {\r\n    return record_type(\"ListModule.FSharpList\", [gen0], FSharpList, () => [[\"head\", gen0], [\"tail\", option_type(FSharpList$reflection(gen0))]]);\r\n}\r\n\r\nexport class ListEnumerator$1 {\r\n    constructor(xs) {\r\n        this.xs = xs;\r\n        this.it = this.xs;\r\n        this.current = null;\r\n    }\r\n    [\"System.Collections.Generic.IEnumerator`1.get_Current\"]() {\r\n        const __ = this;\r\n        return __.current;\r\n    }\r\n    [\"System.Collections.IEnumerator.get_Current\"]() {\r\n        const __ = this;\r\n        return __.current;\r\n    }\r\n    [\"System.Collections.IEnumerator.MoveNext\"]() {\r\n        const __ = this;\r\n        const matchValue = __.it.tail;\r\n        if (matchValue != null) {\r\n            const t = matchValue;\r\n            __.current = __.it.head;\r\n            __.it = t;\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    [\"System.Collections.IEnumerator.Reset\"]() {\r\n        const __ = this;\r\n        __.it = __.xs;\r\n        __.current = null;\r\n    }\r\n    Dispose() {\r\n    }\r\n}\r\n\r\nexport function ListEnumerator$1$reflection(gen0) {\r\n    return class_type(\"ListModule.ListEnumerator`1\", [gen0], ListEnumerator$1);\r\n}\r\n\r\nexport function ListEnumerator$1_$ctor_3002E699(xs) {\r\n    return new ListEnumerator$1(xs);\r\n}\r\n\r\nexport function FSharpList_get_Empty() {\r\n    return new FSharpList(null, void 0);\r\n}\r\n\r\nexport function FSharpList_Cons_305B8EAC(x, xs) {\r\n    return new FSharpList(x, xs);\r\n}\r\n\r\nexport function FSharpList__get_IsEmpty(xs) {\r\n    return xs.tail == null;\r\n}\r\n\r\nexport function FSharpList__get_Length(xs) {\r\n    const loop = (i_mut, xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, xs_1 = xs_1_mut;\r\n            const matchValue = xs_1.tail;\r\n            if (matchValue != null) {\r\n                i_mut = (i + 1);\r\n                xs_1_mut = matchValue;\r\n                continue loop;\r\n            }\r\n            else {\r\n                return i | 0;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0, xs) | 0;\r\n}\r\n\r\nexport function FSharpList__get_Head(xs) {\r\n    const matchValue = xs.tail;\r\n    if (matchValue != null) {\r\n        return xs.head;\r\n    }\r\n    else {\r\n        throw (new Error((SR_inputWasEmpty + \"\\\\nParameter name: \") + \"list\"));\r\n    }\r\n}\r\n\r\nexport function FSharpList__get_Tail(xs) {\r\n    const matchValue = xs.tail;\r\n    if (matchValue != null) {\r\n        return matchValue;\r\n    }\r\n    else {\r\n        throw (new Error((SR_inputWasEmpty + \"\\\\nParameter name: \") + \"list\"));\r\n    }\r\n}\r\n\r\nexport function FSharpList__get_Item_Z524259A4(xs, index) {\r\n    const loop = (i_mut, xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, xs_1 = xs_1_mut;\r\n            const matchValue = xs_1.tail;\r\n            if (matchValue != null) {\r\n                if (i === index) {\r\n                    return xs_1.head;\r\n                }\r\n                else {\r\n                    i_mut = (i + 1);\r\n                    xs_1_mut = matchValue;\r\n                    continue loop;\r\n                }\r\n            }\r\n            else {\r\n                throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0, xs);\r\n}\r\n\r\nexport function empty() {\r\n    return FSharpList_get_Empty();\r\n}\r\n\r\nexport function cons(x, xs) {\r\n    return FSharpList_Cons_305B8EAC(x, xs);\r\n}\r\n\r\nexport function singleton(x) {\r\n    return FSharpList_Cons_305B8EAC(x, FSharpList_get_Empty());\r\n}\r\n\r\nexport function isEmpty(xs) {\r\n    return FSharpList__get_IsEmpty(xs);\r\n}\r\n\r\nexport function length(xs) {\r\n    return FSharpList__get_Length(xs);\r\n}\r\n\r\nexport function head(xs) {\r\n    return FSharpList__get_Head(xs);\r\n}\r\n\r\nexport function tryHead(xs) {\r\n    if (FSharpList__get_IsEmpty(xs)) {\r\n        return void 0;\r\n    }\r\n    else {\r\n        return some(FSharpList__get_Head(xs));\r\n    }\r\n}\r\n\r\nexport function tail(xs) {\r\n    return FSharpList__get_Tail(xs);\r\n}\r\n\r\nexport function tryLast(xs_mut) {\r\n    tryLast:\r\n    while (true) {\r\n        const xs = xs_mut;\r\n        if (FSharpList__get_IsEmpty(xs)) {\r\n            return void 0;\r\n        }\r\n        else {\r\n            const t = FSharpList__get_Tail(xs);\r\n            if (FSharpList__get_IsEmpty(t)) {\r\n                return some(FSharpList__get_Head(xs));\r\n            }\r\n            else {\r\n                xs_mut = t;\r\n                continue tryLast;\r\n            }\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function last(xs) {\r\n    const matchValue = tryLast(xs);\r\n    if (matchValue == null) {\r\n        throw (new Error(SR_inputWasEmpty));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function compareWith(comparer, xs, ys) {\r\n    const loop = (xs_1_mut, ys_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const xs_1 = xs_1_mut, ys_1 = ys_1_mut;\r\n            const matchValue = [FSharpList__get_IsEmpty(xs_1), FSharpList__get_IsEmpty(ys_1)];\r\n            if (matchValue[0]) {\r\n                if (matchValue[1]) {\r\n                    return 0;\r\n                }\r\n                else {\r\n                    return -1;\r\n                }\r\n            }\r\n            else if (matchValue[1]) {\r\n                return 1;\r\n            }\r\n            else {\r\n                const c = comparer(FSharpList__get_Head(xs_1), FSharpList__get_Head(ys_1)) | 0;\r\n                if (c === 0) {\r\n                    xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                    ys_1_mut = FSharpList__get_Tail(ys_1);\r\n                    continue loop;\r\n                }\r\n                else {\r\n                    return c | 0;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(xs, ys) | 0;\r\n}\r\n\r\nexport function toArray(xs) {\r\n    const len = FSharpList__get_Length(xs) | 0;\r\n    const res = fill(new Array(len), 0, len, null);\r\n    const loop = (i_mut, xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, xs_1 = xs_1_mut;\r\n            if (!FSharpList__get_IsEmpty(xs_1)) {\r\n                res[i] = FSharpList__get_Head(xs_1);\r\n                i_mut = (i + 1);\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    loop(0, xs);\r\n    return res;\r\n}\r\n\r\nexport function fold(folder, state, xs) {\r\n    let acc = state;\r\n    let xs_1 = xs;\r\n    while (!FSharpList__get_IsEmpty(xs_1)) {\r\n        acc = folder(acc, FSharpList__get_Head(xs_1));\r\n        xs_1 = FSharpList__get_Tail(xs_1);\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function reverse(xs) {\r\n    return fold((acc, x) => FSharpList_Cons_305B8EAC(x, acc), FSharpList_get_Empty(), xs);\r\n}\r\n\r\nexport function foldBack(folder, xs, state) {\r\n    return foldBack_1(folder, toArray(xs), state);\r\n}\r\n\r\nexport function foldIndexed(folder, state, xs) {\r\n    const loop = (i_mut, acc_mut, xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, acc = acc_mut, xs_1 = xs_1_mut;\r\n            if (FSharpList__get_IsEmpty(xs_1)) {\r\n                return acc;\r\n            }\r\n            else {\r\n                i_mut = (i + 1);\r\n                acc_mut = folder(i, acc, FSharpList__get_Head(xs_1));\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0, state, xs);\r\n}\r\n\r\nexport function fold2(folder, state, xs, ys) {\r\n    let acc = state;\r\n    let xs_1 = xs;\r\n    let ys_1 = ys;\r\n    while ((!FSharpList__get_IsEmpty(xs_1)) && (!FSharpList__get_IsEmpty(ys_1))) {\r\n        acc = folder(acc, FSharpList__get_Head(xs_1), FSharpList__get_Head(ys_1));\r\n        xs_1 = FSharpList__get_Tail(xs_1);\r\n        ys_1 = FSharpList__get_Tail(ys_1);\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function foldBack2(folder, xs, ys, state) {\r\n    return foldBack2_1(folder, toArray(xs), toArray(ys), state);\r\n}\r\n\r\nexport function unfold(gen, state) {\r\n    const loop = (acc_mut, node_mut) => {\r\n        let t;\r\n        loop:\r\n        while (true) {\r\n            const acc = acc_mut, node = node_mut;\r\n            const matchValue = gen(acc);\r\n            if (matchValue != null) {\r\n                acc_mut = matchValue[1];\r\n                node_mut = ((t = (new FSharpList(matchValue[0], void 0)), (node.tail = t, t)));\r\n                continue loop;\r\n            }\r\n            else {\r\n                return node;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const root = FSharpList_get_Empty();\r\n    const node_1 = loop(state, root);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node_1.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function iterate(action, xs) {\r\n    fold((unitVar0, x) => {\r\n        action(x);\r\n    }, void 0, xs);\r\n}\r\n\r\nexport function iterate2(action, xs, ys) {\r\n    fold2((unitVar0, x, y) => {\r\n        action(x, y);\r\n    }, void 0, xs, ys);\r\n}\r\n\r\nexport function iterateIndexed(action, xs) {\r\n    fold((i, x) => {\r\n        action(i, x);\r\n        return (i + 1) | 0;\r\n    }, 0, xs);\r\n}\r\n\r\nexport function iterateIndexed2(action, xs, ys) {\r\n    fold2((i, x, y) => {\r\n        action(i, x, y);\r\n        return (i + 1) | 0;\r\n    }, 0, xs, ys);\r\n}\r\n\r\nexport function toSeq(xs) {\r\n    return xs;\r\n}\r\n\r\nexport function ofArrayWithTail(xs, tail_1) {\r\n    let res = tail_1;\r\n    for (let i = xs.length - 1; i >= 0; i--) {\r\n        res = FSharpList_Cons_305B8EAC(xs[i], res);\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function ofArray(xs) {\r\n    return ofArrayWithTail(xs, FSharpList_get_Empty());\r\n}\r\n\r\nexport function ofSeq(xs) {\r\n    let xs_3, t;\r\n    if (isArrayLike(xs)) {\r\n        return ofArray(xs);\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return xs;\r\n    }\r\n    else {\r\n        const root = FSharpList_get_Empty();\r\n        let node = root;\r\n        const enumerator = getEnumerator(xs);\r\n        try {\r\n            while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                const x = enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n                node = ((xs_3 = node, (t = (new FSharpList(x, void 0)), (xs_3.tail = t, t))));\r\n            }\r\n        }\r\n        finally {\r\n            disposeSafe(enumerator);\r\n        }\r\n        const xs_5 = node;\r\n        const t_2 = FSharpList_get_Empty();\r\n        xs_5.tail = t_2;\r\n        return FSharpList__get_Tail(root);\r\n    }\r\n}\r\n\r\nexport function concat(lists) {\r\n    const root = FSharpList_get_Empty();\r\n    let node = root;\r\n    const action = (xs) => {\r\n        node = fold((acc, x) => {\r\n            const t = new FSharpList(x, void 0);\r\n            acc.tail = t;\r\n            return t;\r\n        }, node, xs);\r\n    };\r\n    if (isArrayLike(lists)) {\r\n        lists.forEach(action);\r\n    }\r\n    else if (lists instanceof FSharpList) {\r\n        iterate(action, lists);\r\n    }\r\n    else {\r\n        const enumerator = getEnumerator(lists);\r\n        try {\r\n            while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                action(enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n            }\r\n        }\r\n        finally {\r\n            disposeSafe(enumerator);\r\n        }\r\n    }\r\n    const xs_6 = node;\r\n    const t_2 = FSharpList_get_Empty();\r\n    xs_6.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function scan(folder, state, xs) {\r\n    let t, xs_4, t_2;\r\n    const root = FSharpList_get_Empty();\r\n    let node = (t = (new FSharpList(state, void 0)), (root.tail = t, t));\r\n    let acc = state;\r\n    let xs_3 = xs;\r\n    while (!FSharpList__get_IsEmpty(xs_3)) {\r\n        acc = folder(acc, FSharpList__get_Head(xs_3));\r\n        node = ((xs_4 = node, (t_2 = (new FSharpList(acc, void 0)), (xs_4.tail = t_2, t_2))));\r\n        xs_3 = FSharpList__get_Tail(xs_3);\r\n    }\r\n    const xs_6 = node;\r\n    const t_4 = FSharpList_get_Empty();\r\n    xs_6.tail = t_4;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function scanBack(folder, xs, state) {\r\n    return ofArray(scanBack_1(folder, toArray(xs), state));\r\n}\r\n\r\nexport function append(xs, ys) {\r\n    return fold((acc, x) => FSharpList_Cons_305B8EAC(x, acc), ys, reverse(xs));\r\n}\r\n\r\nexport function collect(mapping, xs) {\r\n    let xs_1, t;\r\n    const root = FSharpList_get_Empty();\r\n    let node = root;\r\n    let ys = xs;\r\n    while (!FSharpList__get_IsEmpty(ys)) {\r\n        let zs = mapping(FSharpList__get_Head(ys));\r\n        while (!FSharpList__get_IsEmpty(zs)) {\r\n            node = ((xs_1 = node, (t = (new FSharpList(FSharpList__get_Head(zs), void 0)), (xs_1.tail = t, t))));\r\n            zs = FSharpList__get_Tail(zs);\r\n        }\r\n        ys = FSharpList__get_Tail(ys);\r\n    }\r\n    const xs_3 = node;\r\n    const t_2 = FSharpList_get_Empty();\r\n    xs_3.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function mapIndexed(mapping, xs) {\r\n    const root = FSharpList_get_Empty();\r\n    const node = foldIndexed((i, acc, x) => {\r\n        let t;\r\n        return (t = (new FSharpList(mapping(i, x), void 0)), (acc.tail = t, t));\r\n    }, root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function map(mapping, xs) {\r\n    const root = FSharpList_get_Empty();\r\n    const node = fold((acc, x) => {\r\n        let t;\r\n        return (t = (new FSharpList(mapping(x), void 0)), (acc.tail = t, t));\r\n    }, root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function indexed(xs) {\r\n    return mapIndexed((i, x) => [i, x], xs);\r\n}\r\n\r\nexport function map2(mapping, xs, ys) {\r\n    const root = FSharpList_get_Empty();\r\n    const node = fold2((acc, x, y) => {\r\n        let t;\r\n        return (t = (new FSharpList(mapping(x, y), void 0)), (acc.tail = t, t));\r\n    }, root, xs, ys);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function mapIndexed2(mapping, xs, ys) {\r\n    const loop = (i_mut, acc_mut, xs_1_mut, ys_1_mut) => {\r\n        let t;\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, acc = acc_mut, xs_1 = xs_1_mut, ys_1 = ys_1_mut;\r\n            if (FSharpList__get_IsEmpty(xs_1) ? true : FSharpList__get_IsEmpty(ys_1)) {\r\n                return acc;\r\n            }\r\n            else {\r\n                i_mut = (i + 1);\r\n                acc_mut = ((t = (new FSharpList(mapping(i, FSharpList__get_Head(xs_1), FSharpList__get_Head(ys_1)), void 0)), (acc.tail = t, t)));\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                ys_1_mut = FSharpList__get_Tail(ys_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const root = FSharpList_get_Empty();\r\n    const node_1 = loop(0, root, xs, ys);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node_1.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function map3(mapping, xs, ys, zs) {\r\n    const loop = (acc_mut, xs_1_mut, ys_1_mut, zs_1_mut) => {\r\n        let t;\r\n        loop:\r\n        while (true) {\r\n            const acc = acc_mut, xs_1 = xs_1_mut, ys_1 = ys_1_mut, zs_1 = zs_1_mut;\r\n            if ((FSharpList__get_IsEmpty(xs_1) ? true : FSharpList__get_IsEmpty(ys_1)) ? true : FSharpList__get_IsEmpty(zs_1)) {\r\n                return acc;\r\n            }\r\n            else {\r\n                acc_mut = ((t = (new FSharpList(mapping(FSharpList__get_Head(xs_1), FSharpList__get_Head(ys_1), FSharpList__get_Head(zs_1)), void 0)), (acc.tail = t, t)));\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                ys_1_mut = FSharpList__get_Tail(ys_1);\r\n                zs_1_mut = FSharpList__get_Tail(zs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const root = FSharpList_get_Empty();\r\n    const node_1 = loop(root, xs, ys, zs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node_1.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function mapFold(mapping, state, xs) {\r\n    const root = FSharpList_get_Empty();\r\n    const patternInput_1 = fold((tupledArg, x) => {\r\n        let t;\r\n        const patternInput = mapping(tupledArg[1], x);\r\n        return [(t = (new FSharpList(patternInput[0], void 0)), (tupledArg[0].tail = t, t)), patternInput[1]];\r\n    }, [root, state], xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    patternInput_1[0].tail = t_2;\r\n    return [FSharpList__get_Tail(root), patternInput_1[1]];\r\n}\r\n\r\nexport function mapFoldBack(mapping, xs, state) {\r\n    return mapFold((acc, x) => mapping(x, acc), state, reverse(xs));\r\n}\r\n\r\nexport function tryPick(f, xs) {\r\n    const loop = (xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const xs_1 = xs_1_mut;\r\n            if (FSharpList__get_IsEmpty(xs_1)) {\r\n                return void 0;\r\n            }\r\n            else {\r\n                const matchValue = f(FSharpList__get_Head(xs_1));\r\n                if (matchValue == null) {\r\n                    xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                    continue loop;\r\n                }\r\n                else {\r\n                    return matchValue;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(xs);\r\n}\r\n\r\nexport function pick(f, xs) {\r\n    const matchValue = tryPick(f, xs);\r\n    if (matchValue == null) {\r\n        throw (new Error(SR_keyNotFoundAlt));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFind(f, xs) {\r\n    return tryPick((x) => (f(x) ? some(x) : (void 0)), xs);\r\n}\r\n\r\nexport function find(f, xs) {\r\n    const matchValue = tryFind(f, xs);\r\n    if (matchValue == null) {\r\n        throw (new Error(SR_keyNotFoundAlt));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFindBack(f, xs) {\r\n    return tryFindBack_1(f, toArray(xs));\r\n}\r\n\r\nexport function findBack(f, xs) {\r\n    const matchValue = tryFindBack(f, xs);\r\n    if (matchValue == null) {\r\n        throw (new Error(SR_keyNotFoundAlt));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFindIndex(f, xs) {\r\n    const loop = (i_mut, xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, xs_1 = xs_1_mut;\r\n            if (FSharpList__get_IsEmpty(xs_1)) {\r\n                return void 0;\r\n            }\r\n            else if (f(FSharpList__get_Head(xs_1))) {\r\n                return i;\r\n            }\r\n            else {\r\n                i_mut = (i + 1);\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0, xs);\r\n}\r\n\r\nexport function findIndex(f, xs) {\r\n    const matchValue = tryFindIndex(f, xs);\r\n    if (matchValue == null) {\r\n        throw (new Error(SR_keyNotFoundAlt));\r\n    }\r\n    else {\r\n        return matchValue | 0;\r\n    }\r\n}\r\n\r\nexport function tryFindIndexBack(f, xs) {\r\n    return tryFindIndexBack_1(f, toArray(xs));\r\n}\r\n\r\nexport function findIndexBack(f, xs) {\r\n    const matchValue = tryFindIndexBack(f, xs);\r\n    if (matchValue == null) {\r\n        throw (new Error(SR_keyNotFoundAlt));\r\n    }\r\n    else {\r\n        return matchValue | 0;\r\n    }\r\n}\r\n\r\nexport function tryItem(n, xs) {\r\n    const loop = (i_mut, xs_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, xs_1 = xs_1_mut;\r\n            if (FSharpList__get_IsEmpty(xs_1)) {\r\n                return void 0;\r\n            }\r\n            else if (i === n) {\r\n                return some(FSharpList__get_Head(xs_1));\r\n            }\r\n            else {\r\n                i_mut = (i + 1);\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0, xs);\r\n}\r\n\r\nexport function item(n, xs) {\r\n    return FSharpList__get_Item_Z524259A4(xs, n);\r\n}\r\n\r\nexport function filter(f, xs) {\r\n    const root = FSharpList_get_Empty();\r\n    const node = fold((acc, x) => {\r\n        if (f(x)) {\r\n            const t = new FSharpList(x, void 0);\r\n            acc.tail = t;\r\n            return t;\r\n        }\r\n        else {\r\n            return acc;\r\n        }\r\n    }, root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function partition(f, xs) {\r\n    const patternInput = [FSharpList_get_Empty(), FSharpList_get_Empty()];\r\n    const root2 = patternInput[1];\r\n    const root1 = patternInput[0];\r\n    const patternInput_1 = fold(uncurry(2, (tupledArg) => {\r\n        const lacc = tupledArg[0];\r\n        const racc = tupledArg[1];\r\n        return (x) => {\r\n            let t, t_2;\r\n            return f(x) ? [(t = (new FSharpList(x, void 0)), (lacc.tail = t, t)), racc] : [lacc, (t_2 = (new FSharpList(x, void 0)), (racc.tail = t_2, t_2))];\r\n        };\r\n    }), [root1, root2], xs);\r\n    const t_4 = FSharpList_get_Empty();\r\n    patternInput_1[0].tail = t_4;\r\n    const t_5 = FSharpList_get_Empty();\r\n    patternInput_1[1].tail = t_5;\r\n    return [FSharpList__get_Tail(root1), FSharpList__get_Tail(root2)];\r\n}\r\n\r\nexport function choose(f, xs) {\r\n    const root = FSharpList_get_Empty();\r\n    const node = fold((acc, x) => {\r\n        const matchValue = f(x);\r\n        if (matchValue == null) {\r\n            return acc;\r\n        }\r\n        else {\r\n            const t = new FSharpList(value_1(matchValue), void 0);\r\n            acc.tail = t;\r\n            return t;\r\n        }\r\n    }, root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function contains(value, xs, eq) {\r\n    return tryFindIndex((v) => eq.Equals(value, v), xs) != null;\r\n}\r\n\r\nexport function initialize(n, f) {\r\n    let xs, t;\r\n    const root = FSharpList_get_Empty();\r\n    let node = root;\r\n    for (let i = 0; i <= (n - 1); i++) {\r\n        node = ((xs = node, (t = (new FSharpList(f(i), void 0)), (xs.tail = t, t))));\r\n    }\r\n    const xs_2 = node;\r\n    const t_2 = FSharpList_get_Empty();\r\n    xs_2.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function replicate(n, x) {\r\n    return initialize(n, (_arg1) => x);\r\n}\r\n\r\nexport function reduce(f, xs) {\r\n    if (FSharpList__get_IsEmpty(xs)) {\r\n        throw (new Error(SR_inputWasEmpty));\r\n    }\r\n    else {\r\n        return fold(f, head(xs), tail(xs));\r\n    }\r\n}\r\n\r\nexport function reduceBack(f, xs) {\r\n    if (FSharpList__get_IsEmpty(xs)) {\r\n        throw (new Error(SR_inputWasEmpty));\r\n    }\r\n    else {\r\n        return foldBack(f, tail(xs), head(xs));\r\n    }\r\n}\r\n\r\nexport function forAll(f, xs) {\r\n    return fold((acc, x) => (acc && f(x)), true, xs);\r\n}\r\n\r\nexport function forAll2(f, xs, ys) {\r\n    return fold2((acc, x, y) => (acc && f(x, y)), true, xs, ys);\r\n}\r\n\r\nexport function exists(f, xs) {\r\n    return tryFindIndex(f, xs) != null;\r\n}\r\n\r\nexport function exists2(f_mut, xs_mut, ys_mut) {\r\n    exists2:\r\n    while (true) {\r\n        const f = f_mut, xs = xs_mut, ys = ys_mut;\r\n        const matchValue = [FSharpList__get_IsEmpty(xs), FSharpList__get_IsEmpty(ys)];\r\n        let pattern_matching_result;\r\n        if (matchValue[0]) {\r\n            if (matchValue[1]) {\r\n                pattern_matching_result = 0;\r\n            }\r\n            else {\r\n                pattern_matching_result = 2;\r\n            }\r\n        }\r\n        else if (matchValue[1]) {\r\n            pattern_matching_result = 2;\r\n        }\r\n        else {\r\n            pattern_matching_result = 1;\r\n        }\r\n        switch (pattern_matching_result) {\r\n            case 0: {\r\n                return false;\r\n            }\r\n            case 1: {\r\n                if (f(FSharpList__get_Head(xs), FSharpList__get_Head(ys))) {\r\n                    return true;\r\n                }\r\n                else {\r\n                    f_mut = f;\r\n                    xs_mut = FSharpList__get_Tail(xs);\r\n                    ys_mut = FSharpList__get_Tail(ys);\r\n                    continue exists2;\r\n                }\r\n            }\r\n            case 2: {\r\n                throw (new Error((SR_differentLengths + \"\\\\nParameter name: \") + \"list2\"));\r\n            }\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function unzip(xs) {\r\n    return foldBack((tupledArg, tupledArg_1) => [FSharpList_Cons_305B8EAC(tupledArg[0], tupledArg_1[0]), FSharpList_Cons_305B8EAC(tupledArg[1], tupledArg_1[1])], xs, [FSharpList_get_Empty(), FSharpList_get_Empty()]);\r\n}\r\n\r\nexport function unzip3(xs) {\r\n    return foldBack((tupledArg, tupledArg_1) => [FSharpList_Cons_305B8EAC(tupledArg[0], tupledArg_1[0]), FSharpList_Cons_305B8EAC(tupledArg[1], tupledArg_1[1]), FSharpList_Cons_305B8EAC(tupledArg[2], tupledArg_1[2])], xs, [FSharpList_get_Empty(), FSharpList_get_Empty(), FSharpList_get_Empty()]);\r\n}\r\n\r\nexport function zip(xs, ys) {\r\n    return map2((x, y) => [x, y], xs, ys);\r\n}\r\n\r\nexport function zip3(xs, ys, zs) {\r\n    return map3((x, y, z) => [x, y, z], xs, ys, zs);\r\n}\r\n\r\nexport function sortWith(comparer, xs) {\r\n    const arr = toArray(xs);\r\n    arr.sort(comparer);\r\n    return ofArray(arr);\r\n}\r\n\r\nexport function sort(xs, comparer) {\r\n    return sortWith((x, y) => comparer.Compare(x, y), xs);\r\n}\r\n\r\nexport function sortBy(projection, xs, comparer) {\r\n    return sortWith((x, y) => comparer.Compare(projection(x), projection(y)), xs);\r\n}\r\n\r\nexport function sortDescending(xs, comparer) {\r\n    return sortWith((x, y) => (comparer.Compare(x, y) * -1), xs);\r\n}\r\n\r\nexport function sortByDescending(projection, xs, comparer) {\r\n    return sortWith((x, y) => (comparer.Compare(projection(x), projection(y)) * -1), xs);\r\n}\r\n\r\nexport function sum(xs, adder) {\r\n    return fold((acc, x) => adder.Add(acc, x), adder.GetZero(), xs);\r\n}\r\n\r\nexport function sumBy(f, xs, adder) {\r\n    return fold((acc, x) => adder.Add(acc, f(x)), adder.GetZero(), xs);\r\n}\r\n\r\nexport function maxBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function max(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function minBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function min(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function average(xs, averager) {\r\n    let count = 0;\r\n    const total = fold((acc, x) => {\r\n        count = ((count + 1) | 0);\r\n        return averager.Add(acc, x);\r\n    }, averager.GetZero(), xs);\r\n    return averager.DivideByInt(total, count);\r\n}\r\n\r\nexport function averageBy(f, xs, averager) {\r\n    let count = 0;\r\n    const total = fold((acc, x) => {\r\n        count = ((count + 1) | 0);\r\n        return averager.Add(acc, f(x));\r\n    }, averager.GetZero(), xs);\r\n    return averager.DivideByInt(total, count);\r\n}\r\n\r\nexport function permute(f, xs) {\r\n    return ofArray(permute_1(f, toArray(xs)));\r\n}\r\n\r\nexport function chunkBySize(chunkSize, xs) {\r\n    return ofArray(map_1(ofArray, chunkBySize_1(chunkSize, toArray(xs))));\r\n}\r\n\r\nexport function allPairs(xs, ys) {\r\n    const root = FSharpList_get_Empty();\r\n    let node = root;\r\n    iterate((x) => {\r\n        iterate((y) => {\r\n            let xs_1, t;\r\n            node = ((xs_1 = node, (t = (new FSharpList([x, y], void 0)), (xs_1.tail = t, t))));\r\n        }, ys);\r\n    }, xs);\r\n    const xs_3 = node;\r\n    const t_2 = FSharpList_get_Empty();\r\n    xs_3.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function skip(count_mut, xs_mut) {\r\n    skip:\r\n    while (true) {\r\n        const count = count_mut, xs = xs_mut;\r\n        if (count <= 0) {\r\n            return xs;\r\n        }\r\n        else if (FSharpList__get_IsEmpty(xs)) {\r\n            throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"list\"));\r\n        }\r\n        else {\r\n            count_mut = (count - 1);\r\n            xs_mut = FSharpList__get_Tail(xs);\r\n            continue skip;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function skipWhile(predicate_mut, xs_mut) {\r\n    skipWhile:\r\n    while (true) {\r\n        const predicate = predicate_mut, xs = xs_mut;\r\n        if (FSharpList__get_IsEmpty(xs)) {\r\n            return xs;\r\n        }\r\n        else if (!predicate(FSharpList__get_Head(xs))) {\r\n            return xs;\r\n        }\r\n        else {\r\n            predicate_mut = predicate;\r\n            xs_mut = FSharpList__get_Tail(xs);\r\n            continue skipWhile;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function take(count, xs) {\r\n    if (count < 0) {\r\n        throw (new Error((SR_inputMustBeNonNegative + \"\\\\nParameter name: \") + \"count\"));\r\n    }\r\n    const loop = (i_mut, acc_mut, xs_1_mut) => {\r\n        let t;\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, acc = acc_mut, xs_1 = xs_1_mut;\r\n            if (i <= 0) {\r\n                return acc;\r\n            }\r\n            else if (FSharpList__get_IsEmpty(xs_1)) {\r\n                throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"list\"));\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                acc_mut = ((t = (new FSharpList(FSharpList__get_Head(xs_1), void 0)), (acc.tail = t, t)));\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const root = FSharpList_get_Empty();\r\n    const node = loop(count, root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function takeWhile(predicate, xs) {\r\n    const loop = (acc_mut, xs_1_mut) => {\r\n        let t;\r\n        loop:\r\n        while (true) {\r\n            const acc = acc_mut, xs_1 = xs_1_mut;\r\n            if (FSharpList__get_IsEmpty(xs_1)) {\r\n                return acc;\r\n            }\r\n            else if (!predicate(FSharpList__get_Head(xs_1))) {\r\n                return acc;\r\n            }\r\n            else {\r\n                acc_mut = ((t = (new FSharpList(FSharpList__get_Head(xs_1), void 0)), (acc.tail = t, t)));\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const root = FSharpList_get_Empty();\r\n    const node = loop(root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function truncate(count, xs) {\r\n    const loop = (i_mut, acc_mut, xs_1_mut) => {\r\n        let t;\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut, acc = acc_mut, xs_1 = xs_1_mut;\r\n            if (i <= 0) {\r\n                return acc;\r\n            }\r\n            else if (FSharpList__get_IsEmpty(xs_1)) {\r\n                return acc;\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                acc_mut = ((t = (new FSharpList(FSharpList__get_Head(xs_1), void 0)), (acc.tail = t, t)));\r\n                xs_1_mut = FSharpList__get_Tail(xs_1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    const root = FSharpList_get_Empty();\r\n    const node = loop(count, root, xs);\r\n    const t_2 = FSharpList_get_Empty();\r\n    node.tail = t_2;\r\n    return FSharpList__get_Tail(root);\r\n}\r\n\r\nexport function getSlice(startIndex, endIndex, xs) {\r\n    const len = length(xs) | 0;\r\n    const startIndex_1 = defaultArg(startIndex, 0) | 0;\r\n    const endIndex_1 = defaultArg(endIndex, len - 1) | 0;\r\n    if (startIndex_1 < 0) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"startIndex\"));\r\n    }\r\n    else if (endIndex_1 >= len) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"endIndex\"));\r\n    }\r\n    else if (endIndex_1 < startIndex_1) {\r\n        return FSharpList_get_Empty();\r\n    }\r\n    else {\r\n        return take((endIndex_1 - startIndex_1) + 1, skip(startIndex_1, xs));\r\n    }\r\n}\r\n\r\nexport function splitAt(index, xs) {\r\n    if (index < 0) {\r\n        throw (new Error((SR_inputMustBeNonNegative + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    if (index > FSharpList__get_Length(xs)) {\r\n        throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    return [take(index, xs), skip(index, xs)];\r\n}\r\n\r\nexport function exactlyOne(xs) {\r\n    if (FSharpList__get_IsEmpty(xs)) {\r\n        throw (new Error((SR_inputSequenceEmpty + \"\\\\nParameter name: \") + \"list\"));\r\n    }\r\n    else if (FSharpList__get_IsEmpty(FSharpList__get_Tail(xs))) {\r\n        return FSharpList__get_Head(xs);\r\n    }\r\n    else {\r\n        throw (new Error((SR_inputSequenceTooLong + \"\\\\nParameter name: \") + \"list\"));\r\n    }\r\n}\r\n\r\nexport function tryExactlyOne(xs) {\r\n    if ((!FSharpList__get_IsEmpty(xs)) && FSharpList__get_IsEmpty(FSharpList__get_Tail(xs))) {\r\n        return some(FSharpList__get_Head(xs));\r\n    }\r\n    else {\r\n        return void 0;\r\n    }\r\n}\r\n\r\nexport function where(predicate, xs) {\r\n    return filter(predicate, xs);\r\n}\r\n\r\nexport function pairwise(xs) {\r\n    return ofArray(pairwise_1(toArray(xs)));\r\n}\r\n\r\nexport function windowed(windowSize, xs) {\r\n    return ofArray(map_1(ofArray, windowed_1(windowSize, toArray(xs))));\r\n}\r\n\r\nexport function splitInto(chunks, xs) {\r\n    return ofArray(map_1(ofArray, splitInto_1(chunks, toArray(xs))));\r\n}\r\n\r\nexport function transpose(lists) {\r\n    return ofArray(map_1(ofArray, transpose_1(map_1(toArray, Array.from(lists)))));\r\n}\r\n\r\nexport function insertAt(index, y, xs) {\r\n    let i = -1;\r\n    let isDone = false;\r\n    const result = fold((acc, x) => {\r\n        i = ((i + 1) | 0);\r\n        if (i === index) {\r\n            isDone = true;\r\n            return FSharpList_Cons_305B8EAC(x, FSharpList_Cons_305B8EAC(y, acc));\r\n        }\r\n        else {\r\n            return FSharpList_Cons_305B8EAC(x, acc);\r\n        }\r\n    }, FSharpList_get_Empty(), xs);\r\n    return reverse(isDone ? result : (((i + 1) === index) ? FSharpList_Cons_305B8EAC(y, result) : (() => {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    })()));\r\n}\r\n\r\nexport function insertManyAt(index, ys, xs) {\r\n    let i = -1;\r\n    let isDone = false;\r\n    const ys_1 = ofSeq(ys);\r\n    const result = fold((acc, x) => {\r\n        i = ((i + 1) | 0);\r\n        if (i === index) {\r\n            isDone = true;\r\n            return FSharpList_Cons_305B8EAC(x, append(ys_1, acc));\r\n        }\r\n        else {\r\n            return FSharpList_Cons_305B8EAC(x, acc);\r\n        }\r\n    }, FSharpList_get_Empty(), xs);\r\n    return reverse(isDone ? result : (((i + 1) === index) ? append(ys_1, result) : (() => {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    })()));\r\n}\r\n\r\nexport function removeAt(index, xs) {\r\n    let i = -1;\r\n    let isDone = false;\r\n    const ys = filter((_arg1) => {\r\n        i = ((i + 1) | 0);\r\n        if (i === index) {\r\n            isDone = true;\r\n            return false;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }, xs);\r\n    if (!isDone) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    return ys;\r\n}\r\n\r\nexport function removeManyAt(index, count, xs) {\r\n    let i = -1;\r\n    let status = -1;\r\n    const ys = filter((_arg1) => {\r\n        i = ((i + 1) | 0);\r\n        if (i === index) {\r\n            status = 0;\r\n            return false;\r\n        }\r\n        else if (i > index) {\r\n            if (i < (index + count)) {\r\n                return false;\r\n            }\r\n            else {\r\n                status = 1;\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }, xs);\r\n    const status_1 = (((status === 0) && ((i + 1) === (index + count))) ? 1 : status) | 0;\r\n    if (status_1 < 1) {\r\n        const arg = (status_1 < 0) ? \"index\" : \"count\";\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + arg));\r\n    }\r\n    return ys;\r\n}\r\n\r\nexport function updateAt(index, y, xs) {\r\n    let isDone = false;\r\n    const ys = mapIndexed((i, x) => {\r\n        if (i === index) {\r\n            isDone = true;\r\n            return y;\r\n        }\r\n        else {\r\n            return x;\r\n        }\r\n    }, xs);\r\n    if (!isDone) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    return ys;\r\n}\r\n\r\n","\r\nexport const SR_indexOutOfBounds = \"The index was outside the range of elements in the collection.\";\r\n\r\nexport const SR_inputWasEmpty = \"Collection was empty.\";\r\n\r\nexport const SR_inputMustBeNonNegative = \"The input must be non-negative.\";\r\n\r\nexport const SR_inputSequenceEmpty = \"The input sequence was empty.\";\r\n\r\nexport const SR_inputSequenceTooLong = \"The input sequence contains more than one element.\";\r\n\r\nexport const SR_keyNotFoundAlt = \"An index satisfying the predicate was not found in the collection.\";\r\n\r\nexport const SR_differentLengths = \"The collections had different lengths.\";\r\n\r\nexport const SR_notEnoughElements = \"The input sequence has an insufficient number of elements.\";\r\n\r\n","export class CancellationToken {\n    constructor(cancelled = false) {\n        this._id = 0;\n        this._cancelled = cancelled;\n        this._listeners = new Map();\n    }\n    get isCancelled() {\n        return this._cancelled;\n    }\n    cancel() {\n        if (!this._cancelled) {\n            this._cancelled = true;\n            for (const [, listener] of this._listeners) {\n                listener();\n            }\n        }\n    }\n    addListener(f) {\n        const id = this._id;\n        this._listeners.set(this._id++, f);\n        return id;\n    }\n    removeListener(id) {\n        return this._listeners.delete(id);\n    }\n    register(f, state) {\n        const $ = this;\n        const id = this.addListener(state == null ? f : () => f(state));\n        return { Dispose() { $.removeListener(id); } };\n    }\n}\nexport class OperationCanceledError extends Error {\n    constructor() {\n        super(\"The operation was canceled\");\n        Object.setPrototypeOf(this, OperationCanceledError.prototype);\n    }\n}\nexport class Trampoline {\n    constructor() {\n        this.callCount = 0;\n    }\n    static get maxTrampolineCallCount() {\n        return 2000;\n    }\n    incrementAndCheck() {\n        return this.callCount++ > Trampoline.maxTrampolineCallCount;\n    }\n    hijack(f) {\n        this.callCount = 0;\n        setTimeout(f, 0);\n    }\n}\nexport function protectedCont(f) {\n    return (ctx) => {\n        if (ctx.cancelToken.isCancelled) {\n            ctx.onCancel(new OperationCanceledError());\n        }\n        else if (ctx.trampoline.incrementAndCheck()) {\n            ctx.trampoline.hijack(() => {\n                try {\n                    f(ctx);\n                }\n                catch (err) {\n                    ctx.onError(err);\n                }\n            });\n        }\n        else {\n            try {\n                f(ctx);\n            }\n            catch (err) {\n                ctx.onError(err);\n            }\n        }\n    };\n}\nexport function protectedBind(computation, binder) {\n    return protectedCont((ctx) => {\n        computation({\n            onSuccess: (x) => {\n                try {\n                    binder(x)(ctx);\n                }\n                catch (ex) {\n                    ctx.onError(ex);\n                }\n            },\n            onError: ctx.onError,\n            onCancel: ctx.onCancel,\n            cancelToken: ctx.cancelToken,\n            trampoline: ctx.trampoline,\n        });\n    });\n}\nexport function protectedReturn(value) {\n    return protectedCont((ctx) => ctx.onSuccess(value));\n}\nexport class AsyncBuilder {\n    Bind(computation, binder) {\n        return protectedBind(computation, binder);\n    }\n    Combine(computation1, computation2) {\n        return this.Bind(computation1, () => computation2);\n    }\n    Delay(generator) {\n        return protectedCont((ctx) => generator()(ctx));\n    }\n    For(sequence, body) {\n        const iter = sequence[Symbol.iterator]();\n        let cur = iter.next();\n        return this.While(() => !cur.done, this.Delay(() => {\n            const res = body(cur.value);\n            cur = iter.next();\n            return res;\n        }));\n    }\n    Return(value) {\n        return protectedReturn(value);\n    }\n    ReturnFrom(computation) {\n        return computation;\n    }\n    TryFinally(computation, compensation) {\n        return protectedCont((ctx) => {\n            computation({\n                onSuccess: (x) => {\n                    compensation();\n                    ctx.onSuccess(x);\n                },\n                onError: (x) => {\n                    compensation();\n                    ctx.onError(x);\n                },\n                onCancel: (x) => {\n                    compensation();\n                    ctx.onCancel(x);\n                },\n                cancelToken: ctx.cancelToken,\n                trampoline: ctx.trampoline,\n            });\n        });\n    }\n    TryWith(computation, catchHandler) {\n        return protectedCont((ctx) => {\n            computation({\n                onSuccess: ctx.onSuccess,\n                onCancel: ctx.onCancel,\n                cancelToken: ctx.cancelToken,\n                trampoline: ctx.trampoline,\n                onError: (ex) => {\n                    try {\n                        catchHandler(ex)(ctx);\n                    }\n                    catch (ex2) {\n                        ctx.onError(ex2);\n                    }\n                },\n            });\n        });\n    }\n    Using(resource, binder) {\n        return this.TryFinally(binder(resource), () => resource.Dispose());\n    }\n    While(guard, computation) {\n        if (guard()) {\n            return this.Bind(computation, () => this.While(guard, computation));\n        }\n        else {\n            return this.Return(void 0);\n        }\n    }\n    Zero() {\n        return protectedCont((ctx) => ctx.onSuccess(void 0));\n    }\n}\nexport const singleton = new AsyncBuilder();\n","import { Union } from \"./Types.js\";\r\nimport { union_type } from \"./Reflection.js\";\r\nimport { some } from \"./Option.js\";\r\n\r\nexport class FSharpResult$2 extends Union {\r\n    constructor(tag, ...fields) {\r\n        super();\r\n        this.tag = (tag | 0);\r\n        this.fields = fields;\r\n    }\r\n    cases() {\r\n        return [\"Ok\", \"Error\"];\r\n    }\r\n}\r\n\r\nexport function FSharpResult$2$reflection(gen0, gen1) {\r\n    return union_type(\"FSharp.Core.FSharpResult`2\", [gen0, gen1], FSharpResult$2, () => [[[\"ResultValue\", gen0]], [[\"ErrorValue\", gen1]]]);\r\n}\r\n\r\nexport function Result_Map(mapping, result) {\r\n    if (result.tag === 0) {\r\n        return new FSharpResult$2(0, mapping(result.fields[0]));\r\n    }\r\n    else {\r\n        return new FSharpResult$2(1, result.fields[0]);\r\n    }\r\n}\r\n\r\nexport function Result_MapError(mapping, result) {\r\n    if (result.tag === 0) {\r\n        return new FSharpResult$2(0, result.fields[0]);\r\n    }\r\n    else {\r\n        return new FSharpResult$2(1, mapping(result.fields[0]));\r\n    }\r\n}\r\n\r\nexport function Result_Bind(binder, result) {\r\n    if (result.tag === 0) {\r\n        return binder(result.fields[0]);\r\n    }\r\n    else {\r\n        return new FSharpResult$2(1, result.fields[0]);\r\n    }\r\n}\r\n\r\nexport class FSharpChoice$2 extends Union {\r\n    constructor(tag, ...fields) {\r\n        super();\r\n        this.tag = (tag | 0);\r\n        this.fields = fields;\r\n    }\r\n    cases() {\r\n        return [\"Choice1Of2\", \"Choice2Of2\"];\r\n    }\r\n}\r\n\r\nexport function FSharpChoice$2$reflection(gen0, gen1) {\r\n    return union_type(\"FSharp.Core.FSharpChoice`2\", [gen0, gen1], FSharpChoice$2, () => [[[\"Item\", gen0]], [[\"Item\", gen1]]]);\r\n}\r\n\r\nexport class FSharpChoice$3 extends Union {\r\n    constructor(tag, ...fields) {\r\n        super();\r\n        this.tag = (tag | 0);\r\n        this.fields = fields;\r\n    }\r\n    cases() {\r\n        return [\"Choice1Of3\", \"Choice2Of3\", \"Choice3Of3\"];\r\n    }\r\n}\r\n\r\nexport function FSharpChoice$3$reflection(gen0, gen1, gen2) {\r\n    return union_type(\"FSharp.Core.FSharpChoice`3\", [gen0, gen1, gen2], FSharpChoice$3, () => [[[\"Item\", gen0]], [[\"Item\", gen1]], [[\"Item\", gen2]]]);\r\n}\r\n\r\nexport class FSharpChoice$4 extends Union {\r\n    constructor(tag, ...fields) {\r\n        super();\r\n        this.tag = (tag | 0);\r\n        this.fields = fields;\r\n    }\r\n    cases() {\r\n        return [\"Choice1Of4\", \"Choice2Of4\", \"Choice3Of4\", \"Choice4Of4\"];\r\n    }\r\n}\r\n\r\nexport function FSharpChoice$4$reflection(gen0, gen1, gen2, gen3) {\r\n    return union_type(\"FSharp.Core.FSharpChoice`4\", [gen0, gen1, gen2, gen3], FSharpChoice$4, () => [[[\"Item\", gen0]], [[\"Item\", gen1]], [[\"Item\", gen2]], [[\"Item\", gen3]]]);\r\n}\r\n\r\nexport class FSharpChoice$5 extends Union {\r\n    constructor(tag, ...fields) {\r\n        super();\r\n        this.tag = (tag | 0);\r\n        this.fields = fields;\r\n    }\r\n    cases() {\r\n        return [\"Choice1Of5\", \"Choice2Of5\", \"Choice3Of5\", \"Choice4Of5\", \"Choice5Of5\"];\r\n    }\r\n}\r\n\r\nexport function FSharpChoice$5$reflection(gen0, gen1, gen2, gen3, gen4) {\r\n    return union_type(\"FSharp.Core.FSharpChoice`5\", [gen0, gen1, gen2, gen3, gen4], FSharpChoice$5, () => [[[\"Item\", gen0]], [[\"Item\", gen1]], [[\"Item\", gen2]], [[\"Item\", gen3]], [[\"Item\", gen4]]]);\r\n}\r\n\r\nexport class FSharpChoice$6 extends Union {\r\n    constructor(tag, ...fields) {\r\n        super();\r\n        this.tag = (tag | 0);\r\n        this.fields = fields;\r\n    }\r\n    cases() {\r\n        return [\"Choice1Of6\", \"Choice2Of6\", \"Choice3Of6\", \"Choice4Of6\", \"Choice5Of6\", \"Choice6Of6\"];\r\n    }\r\n}\r\n\r\nexport function FSharpChoice$6$reflection(gen0, gen1, gen2, gen3, gen4, gen5) {\r\n    return union_type(\"FSharp.Core.FSharpChoice`6\", [gen0, gen1, gen2, gen3, gen4, gen5], FSharpChoice$6, () => [[[\"Item\", gen0]], [[\"Item\", gen1]], [[\"Item\", gen2]], [[\"Item\", gen3]], [[\"Item\", gen4]], [[\"Item\", gen5]]]);\r\n}\r\n\r\nexport class FSharpChoice$7 extends Union {\r\n    constructor(tag, ...fields) {\r\n        super();\r\n        this.tag = (tag | 0);\r\n        this.fields = fields;\r\n    }\r\n    cases() {\r\n        return [\"Choice1Of7\", \"Choice2Of7\", \"Choice3Of7\", \"Choice4Of7\", \"Choice5Of7\", \"Choice6Of7\", \"Choice7Of7\"];\r\n    }\r\n}\r\n\r\nexport function FSharpChoice$7$reflection(gen0, gen1, gen2, gen3, gen4, gen5, gen6) {\r\n    return union_type(\"FSharp.Core.FSharpChoice`7\", [gen0, gen1, gen2, gen3, gen4, gen5, gen6], FSharpChoice$7, () => [[[\"Item\", gen0]], [[\"Item\", gen1]], [[\"Item\", gen2]], [[\"Item\", gen3]], [[\"Item\", gen4]], [[\"Item\", gen5]], [[\"Item\", gen6]]]);\r\n}\r\n\r\nexport function Choice_makeChoice1Of2(x) {\r\n    return new FSharpChoice$2(0, x);\r\n}\r\n\r\nexport function Choice_makeChoice2Of2(x) {\r\n    return new FSharpChoice$2(1, x);\r\n}\r\n\r\nexport function Choice_tryValueIfChoice1Of2(x) {\r\n    if (x.tag === 0) {\r\n        return some(x.fields[0]);\r\n    }\r\n    else {\r\n        return void 0;\r\n    }\r\n}\r\n\r\nexport function Choice_tryValueIfChoice2Of2(x) {\r\n    if (x.tag === 1) {\r\n        return some(x.fields[0]);\r\n    }\r\n    else {\r\n        return void 0;\r\n    }\r\n}\r\n\r\n","import { OperationCanceledError, Trampoline } from \"./AsyncBuilder.js\";\nimport { CancellationToken } from \"./AsyncBuilder.js\";\nimport { protectedCont } from \"./AsyncBuilder.js\";\nimport { protectedBind } from \"./AsyncBuilder.js\";\nimport { protectedReturn } from \"./AsyncBuilder.js\";\nimport { Choice_makeChoice1Of2, Choice_makeChoice2Of2 } from \"./Choice.js\";\nimport { TimeoutException } from \"./SystemException.js\";\n// Implemented just for type references\nexport class Async {\n}\nfunction emptyContinuation(_x) {\n    // NOP\n}\n// see AsyncBuilder.Delay\nfunction delay(generator) {\n    return protectedCont((ctx) => generator()(ctx));\n}\n// MakeAsync: body:(AsyncActivation<'T> -> AsyncReturn) -> Async<'T>\nexport function makeAsync(body) {\n    return body;\n}\n// Invoke: computation: Async<'T> -> ctxt:AsyncActivation<'T> -> AsyncReturn\nexport function invoke(computation, ctx) {\n    return computation(ctx);\n}\n// CallThenInvoke: ctxt:AsyncActivation<'T> -> result1:'U -> part2:('U -> Async<'T>) -> AsyncReturn\nexport function callThenInvoke(ctx, result1, part2) {\n    return part2(result1)(ctx);\n}\n// Bind: ctxt:AsyncActivation<'T> -> part1:Async<'U> -> part2:('U -> Async<'T>) -> AsyncReturn\nexport function bind(ctx, part1, part2) {\n    return protectedBind(part1, part2)(ctx);\n}\nexport function createCancellationToken(arg) {\n    const token = new CancellationToken(typeof arg === \"boolean\" ? arg : false);\n    if (typeof arg === \"number\") {\n        setTimeout(() => { token.cancel(); }, arg);\n    }\n    return token;\n}\nexport function cancel(token) {\n    token.cancel();\n}\nexport function cancelAfter(token, ms) {\n    setTimeout(() => { token.cancel(); }, ms);\n}\nexport function isCancellationRequested(token) {\n    return token != null && token.isCancelled;\n}\nexport function throwIfCancellationRequested(token) {\n    if (token != null && token.isCancelled) {\n        throw new Error(\"Operation is cancelled\");\n    }\n}\nfunction throwAfter(millisecondsDueTime) {\n    return protectedCont((ctx) => {\n        let tokenId;\n        const timeoutId = setTimeout(() => {\n            ctx.cancelToken.removeListener(tokenId);\n            ctx.onError(new TimeoutException());\n        }, millisecondsDueTime);\n        tokenId = ctx.cancelToken.addListener(() => {\n            clearTimeout(timeoutId);\n            ctx.onCancel(new OperationCanceledError());\n        });\n    });\n}\nexport function startChild(computation, ms) {\n    if (ms) {\n        const computationWithTimeout = protectedBind(parallel2(computation, throwAfter(ms)), xs => protectedReturn(xs[0]));\n        return startChild(computationWithTimeout);\n    }\n    const promise = startAsPromise(computation);\n    // JS Promises are hot, computation has already started\n    // but we delay returning the result\n    return protectedCont((ctx) => protectedReturn(awaitPromise(promise))(ctx));\n}\nexport function awaitPromise(p) {\n    return fromContinuations((conts) => p.then(conts[0]).catch((err) => (err instanceof OperationCanceledError\n        ? conts[2] : conts[1])(err)));\n}\nexport function cancellationToken() {\n    return protectedCont((ctx) => ctx.onSuccess(ctx.cancelToken));\n}\nexport const defaultCancellationToken = new CancellationToken();\nexport function catchAsync(work) {\n    return protectedCont((ctx) => {\n        work({\n            onSuccess: (x) => ctx.onSuccess(Choice_makeChoice1Of2(x)),\n            onError: (ex) => ctx.onSuccess(Choice_makeChoice2Of2(ex)),\n            onCancel: ctx.onCancel,\n            cancelToken: ctx.cancelToken,\n            trampoline: ctx.trampoline,\n        });\n    });\n}\nexport function fromContinuations(f) {\n    return protectedCont((ctx) => f([ctx.onSuccess, ctx.onError, ctx.onCancel]));\n}\nexport function ignore(computation) {\n    return protectedBind(computation, (_x) => protectedReturn(void 0));\n}\nexport function parallel(computations) {\n    return delay(() => awaitPromise(Promise.all(Array.from(computations, (w) => startAsPromise(w)))));\n}\nfunction parallel2(a, b) {\n    return delay(() => awaitPromise(Promise.all([startAsPromise(a), startAsPromise(b)])));\n}\nexport function sequential(computations) {\n    function _sequential(computations) {\n        let pr = Promise.resolve([]);\n        for (const c of computations) {\n            pr = pr.then(results => startAsPromise(c).then(r => results.concat([r])));\n        }\n        return pr;\n    }\n    return delay(() => awaitPromise(_sequential(computations)));\n}\nexport function sleep(millisecondsDueTime) {\n    return protectedCont((ctx) => {\n        let tokenId;\n        const timeoutId = setTimeout(() => {\n            ctx.cancelToken.removeListener(tokenId);\n            ctx.onSuccess(void 0);\n        }, millisecondsDueTime);\n        tokenId = ctx.cancelToken.addListener(() => {\n            clearTimeout(timeoutId);\n            ctx.onCancel(new OperationCanceledError());\n        });\n    });\n}\nexport function runSynchronously() {\n    throw new Error(\"Asynchronous code cannot be run synchronously in JS\");\n}\nexport function start(computation, cancellationToken) {\n    return startWithContinuations(computation, cancellationToken);\n}\nexport function startImmediate(computation, cancellationToken) {\n    return start(computation, cancellationToken);\n}\nexport function startWithContinuations(computation, continuation, exceptionContinuation, cancellationContinuation, cancelToken) {\n    if (typeof continuation !== \"function\") {\n        cancelToken = continuation;\n        continuation = undefined;\n    }\n    const trampoline = new Trampoline();\n    computation({\n        onSuccess: continuation ? continuation : emptyContinuation,\n        onError: exceptionContinuation ? exceptionContinuation : emptyContinuation,\n        onCancel: cancellationContinuation ? cancellationContinuation : emptyContinuation,\n        cancelToken: cancelToken ? cancelToken : defaultCancellationToken,\n        trampoline,\n    });\n}\nexport function startAsPromise(computation, cancellationToken) {\n    return new Promise((resolve, reject) => startWithContinuations(computation, resolve, reject, reject, cancellationToken ? cancellationToken : defaultCancellationToken));\n}\nexport default Async;\n","import { Observer } from \"./Observable.js\";\nimport { some, value } from \"./Option.js\";\nimport { Choice_tryValueIfChoice1Of2, Choice_tryValueIfChoice2Of2 } from \"./Choice.js\";\nexport class Event {\n    constructor() {\n        this.delegates = [];\n    }\n    Add(f) {\n        this._addHandler(f);\n    }\n    get Publish() {\n        return this;\n    }\n    Trigger(senderOrValue, valueOrUndefined) {\n        let sender;\n        let value;\n        if (valueOrUndefined === undefined) {\n            sender = null;\n            value = senderOrValue;\n        }\n        else {\n            sender = senderOrValue;\n            value = valueOrUndefined;\n        }\n        this.delegates.forEach((f) => f.length === 1 ? f(value) : f(sender, value));\n    }\n    // IDelegateEvent<T> methods\n    AddHandler(handler) {\n        this._addHandler(handler);\n    }\n    RemoveHandler(handler) {\n        this._removeHandler(handler);\n    }\n    // IObservable<T> methods\n    Subscribe(arg) {\n        const callback = typeof arg === \"function\"\n            ? arg\n            : arg.OnNext;\n        this._addHandler(callback);\n        return { Dispose: () => { this._removeHandler(callback); } };\n    }\n    _addHandler(f) {\n        this.delegates.push(f);\n    }\n    _removeHandler(f) {\n        const index = this.delegates.indexOf(f);\n        if (index > -1) {\n            this.delegates.splice(index, 1);\n        }\n    }\n}\nexport function add(callback, sourceEvent) {\n    if (sourceEvent instanceof Event) {\n        sourceEvent.Add(callback);\n    }\n    else {\n        sourceEvent.Subscribe(new Observer(callback));\n    }\n}\nexport function choose(chooser, sourceEvent) {\n    const ev = new Event();\n    add((t) => {\n        const u = chooser(t);\n        if (u != null) {\n            ev.Trigger(value(u));\n        }\n    }, sourceEvent);\n    return ev;\n}\nexport function filter(predicate, sourceEvent) {\n    return choose((x) => predicate(x) ? some(x) : undefined, sourceEvent);\n}\nexport function map(mapping, sourceEvent) {\n    const ev = new Event();\n    add((t) => ev.Trigger(mapping(t)), sourceEvent);\n    return ev;\n}\nexport function merge(event1, event2) {\n    const ev = new Event();\n    const fn = (x) => ev.Trigger(x);\n    add(fn, event1);\n    add(fn, event2);\n    return ev;\n}\nexport function pairwise(sourceEvent) {\n    const ev = new Event();\n    let last;\n    let haveLast = false;\n    add((next) => {\n        if (haveLast) {\n            ev.Trigger([last, next]);\n        }\n        last = next;\n        haveLast = true;\n    }, sourceEvent);\n    return ev;\n}\nexport function partition(predicate, sourceEvent) {\n    return [filter(predicate, sourceEvent), filter((x) => !predicate(x), sourceEvent)];\n}\nexport function scan(collector, state, sourceEvent) {\n    return map((t) => state = collector(state, t), sourceEvent);\n}\nexport function split(splitter, sourceEvent) {\n    return [\n        choose((v) => Choice_tryValueIfChoice1Of2(splitter(v)), sourceEvent),\n        choose((v) => Choice_tryValueIfChoice2Of2(splitter(v)), sourceEvent),\n    ];\n}\nexport function createEvent(addHandler, removeHandler) {\n    return {\n        AddHandler(h) { addHandler(h); },\n        RemoveHandler(h) { removeHandler(h); },\n        Subscribe(r) {\n            const h = (_, args) => r.OnNext(args);\n            addHandler(h);\n            return {\n                Dispose() { removeHandler(h); }\n            };\n        }\n    };\n}\nexport default Event;\n","import { Choice_tryValueIfChoice1Of2, Choice_tryValueIfChoice2Of2 } from \"./Choice.js\";\nimport { value } from \"./Option.js\";\nexport class Observer {\n    constructor(onNext, onError, onCompleted) {\n        this.OnNext = onNext;\n        this.OnError = onError || ((_e) => { return; });\n        this.OnCompleted = onCompleted || (() => { return; });\n    }\n}\nclass Observable {\n    constructor(subscribe) {\n        this.Subscribe = subscribe;\n    }\n}\nexport function protect(f, succeed, fail) {\n    try {\n        return succeed(f());\n    }\n    catch (e) {\n        fail(e);\n    }\n}\nexport function add(callback, source) {\n    source.Subscribe(new Observer(callback));\n}\nexport function choose(chooser, source) {\n    return new Observable((observer) => source.Subscribe(new Observer((t) => protect(() => chooser(t), (u) => { if (u != null) {\n        observer.OnNext(value(u));\n    } }, observer.OnError), observer.OnError, observer.OnCompleted)));\n}\nexport function filter(predicate, source) {\n    return choose((x) => predicate(x) ? x : null, source);\n}\nexport function map(mapping, source) {\n    return new Observable((observer) => source.Subscribe(new Observer((t) => {\n        protect(() => mapping(t), observer.OnNext, observer.OnError);\n    }, observer.OnError, observer.OnCompleted)));\n}\nexport function merge(source1, source2) {\n    return new Observable((observer) => {\n        let stopped = false;\n        let completed1 = false;\n        let completed2 = false;\n        const h1 = source1.Subscribe(new Observer((v) => { if (!stopped) {\n            observer.OnNext(v);\n        } }, (e) => {\n            if (!stopped) {\n                stopped = true;\n                observer.OnError(e);\n            }\n        }, () => {\n            if (!stopped) {\n                completed1 = true;\n                if (completed2) {\n                    stopped = true;\n                    observer.OnCompleted();\n                }\n            }\n        }));\n        const h2 = source2.Subscribe(new Observer((v) => { if (!stopped) {\n            observer.OnNext(v);\n        } }, (e) => {\n            if (!stopped) {\n                stopped = true;\n                observer.OnError(e);\n            }\n        }, () => {\n            if (!stopped) {\n                completed2 = true;\n                if (completed1) {\n                    stopped = true;\n                    observer.OnCompleted();\n                }\n            }\n        }));\n        return {\n            Dispose() {\n                h1.Dispose();\n                h2.Dispose();\n            },\n        };\n    });\n}\nexport function pairwise(source) {\n    return new Observable((observer) => {\n        let last;\n        return source.Subscribe(new Observer((next) => {\n            if (last != null) {\n                observer.OnNext([last, next]);\n            }\n            last = next;\n        }, observer.OnError, observer.OnCompleted));\n    });\n}\nexport function partition(predicate, source) {\n    return [filter(predicate, source), filter((x) => !predicate(x), source)];\n}\nexport function scan(collector, state, source) {\n    return new Observable((observer) => {\n        return source.Subscribe(new Observer((t) => {\n            protect(() => collector(state, t), (u) => { state = u; observer.OnNext(u); }, observer.OnError);\n        }, observer.OnError, observer.OnCompleted));\n    });\n}\nexport function split(splitter, source) {\n    return [\n        choose((v) => Choice_tryValueIfChoice1Of2(splitter(v)), source),\n        choose((v) => Choice_tryValueIfChoice2Of2(splitter(v)), source)\n    ];\n}\nexport function subscribe(callback, source) {\n    return source.Subscribe(new Observer(callback));\n}\n","namespace Elmish\n\n(**\nLog\n---------\nBasic cross-platform logging API.\n\n*)\nmodule internal Log =\n\n#if FABLE_COMPILER\n    open Fable.Core.JS\n\n    let onError (text: string, ex: exn) = console.error (text,ex)\n    let toConsole(text: string, o: #obj) = console.log(text,o)\n\n#else\n#if NETSTANDARD2_0\n    let onError (text: string, ex: exn) = System.Diagnostics.Trace.TraceError(\"{0}: {1}\", text, ex)\n    let toConsole(text: string, o: #obj) = printfn \"%s: %A\" text o\n#else\n    let onError (text: string, ex: exn) = System.Console.Error.WriteLine(\"{0}: {1}\", text, ex)\n    let toConsole(text: string, o: #obj) = printfn \"%s: %A\" text o\n#endif\n#endif\n\n#if FABLE_COMPILER\nmodule internal Timer =\n    open System.Timers\n    let delay interval callback =\n        let t = new Timer(float interval, AutoReset = false)\n        t.Elapsed.Add callback\n        t.Enabled <- true\n        t.Start()\n#endif\n","import Event from \"./Event.js\";\nexport class Timer {\n    constructor(interval) {\n        this._enabled = false;\n        this._isDisposed = false;\n        this._intervalId = 0;\n        this._timeoutId = 0;\n        this.Interval = interval && interval > 0 ? interval : 100;\n        this.AutoReset = true;\n        this._elapsed = new Event();\n    }\n    Elapsed() {\n        return this._elapsed;\n    }\n    get Enabled() {\n        return this._enabled;\n    }\n    set Enabled(x) {\n        if (!this._isDisposed && this._enabled !== x) {\n            this._enabled = x;\n            if (this._enabled) {\n                if (this.AutoReset) {\n                    this._intervalId = setInterval(() => {\n                        if (!this.AutoReset) {\n                            this.Enabled = false;\n                        }\n                        this._elapsed.Trigger(new Date());\n                    }, this.Interval);\n                }\n                else {\n                    this._timeoutId = setTimeout(() => {\n                        this.Enabled = false;\n                        this._timeoutId = 0;\n                        if (this.AutoReset) {\n                            this.Enabled = true;\n                        }\n                        this._elapsed.Trigger(new Date());\n                    }, this.Interval);\n                }\n            }\n            else {\n                if (this._timeoutId) {\n                    clearTimeout(this._timeoutId);\n                    this._timeoutId = 0;\n                }\n                if (this._intervalId) {\n                    clearInterval(this._intervalId);\n                    this._intervalId = 0;\n                }\n            }\n        }\n    }\n    Dispose() {\n        this.Enabled = false;\n        this._isDisposed = true;\n    }\n    Close() {\n        this.Dispose();\n    }\n    Start() {\n        this.Enabled = true;\n    }\n    Stop() {\n        this.Enabled = false;\n    }\n}\nexport default Timer;\n","(**\nCmd\n---------\nCore abstractions for dispatching messages in Elmish.\n\n*)\n\nnamespace Elmish\n\nopen System\n\n/// Dispatch - feed new message into the processing loop\ntype Dispatch<'msg> = 'msg -> unit\n\n/// Subscription - return immediately, but may schedule dispatch of a message at any time\ntype Sub<'msg> = Dispatch<'msg> -> unit\n\n/// Cmd - container for subscriptions that may produce messages\ntype Cmd<'msg> = Sub<'msg> list\n\n/// Cmd module for creating and manipulating commands\n[<RequireQualifiedAccess>]\nmodule Cmd =\n    /// Execute the commands using the supplied dispatcher\n    let internal exec onError (dispatch: Dispatch<'msg>) (cmd: Cmd<'msg>) =\n        cmd |> List.iter (fun call -> try call dispatch with ex -> onError ex)\n\n    /// None - no commands, also known as `[]`\n    let none : Cmd<'msg> =\n        []\n\n    /// When emitting the message, map to another type\n    let map (f: 'a -> 'msg) (cmd: Cmd<'a>) : Cmd<'msg> =\n        cmd |> List.map (fun g -> (fun dispatch -> f >> dispatch) >> g)\n\n    /// Aggregate multiple commands\n    let batch (cmds: #seq<Cmd<'msg>>) : Cmd<'msg> =\n        cmds |> List.concat\n\n    /// Command to call the subscriber\n    let ofSub (sub: Sub<'msg>) : Cmd<'msg> =\n        [sub]\n\n    module OfFunc =\n        /// Command to evaluate a simple function and map the result\n        /// into success or error (of exception)\n        let either (task: 'a -> _) (arg: 'a) (ofSuccess: _ -> 'msg) (ofError: _ -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                try\n                    task arg\n                    |> (ofSuccess >> dispatch)\n                with x ->\n                    x |> (ofError >> dispatch)\n            [bind]\n\n        /// Command to evaluate a simple function and map the success to a message\n        /// discarding any possible error\n        let perform (task: 'a -> _) (arg: 'a) (ofSuccess: _ -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                try\n                    task arg\n                    |> (ofSuccess >> dispatch)\n                with x ->\n                    ()\n            [bind]\n\n        /// Command to evaluate a simple function and map the error (in case of exception)\n        let attempt (task: 'a -> unit) (arg: 'a) (ofError: _ -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                try\n                    task arg\n                with x ->\n                    x |> (ofError >> dispatch)\n            [bind]\n\n        /// Command to issue a specific message\n        let result (msg:'msg) : Cmd<'msg> =\n            [fun dispatch -> dispatch msg]\n\n    module OfAsyncWith =\n        /// Command that will evaluate an async block and map the result\n        /// into success or error (of exception)\n        let either (start: Async<unit> -> unit) \n                   (task: 'a -> Async<_>)\n                   (arg: 'a)\n                   (ofSuccess: _ -> 'msg)\n                   (ofError: _ -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                async {\n                    let! r = task arg |> Async.Catch\n                    dispatch (match r with\n                             | Choice1Of2 x -> ofSuccess x\n                             | Choice2Of2 x -> ofError x)\n                }\n            [bind >> start]\n\n        /// Command that will evaluate an async block and map the success\n        let perform (start: Async<unit> -> unit) \n                    (task: 'a -> Async<_>)\n                    (arg: 'a)\n                    (ofSuccess: _ -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                async {\n                    let! r = task arg |> Async.Catch\n                    match r with\n                    | Choice1Of2 x -> dispatch (ofSuccess x)\n                    | _ -> ()\n                }\n            [bind >> start]\n\n        /// Command that will evaluate an async block and map the error (of exception)\n        let attempt (start: Async<unit> -> unit) \n                    (task: 'a -> Async<_>)\n                    (arg: 'a)\n                    (ofError: _ -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                async {\n                    let! r = task arg |> Async.Catch\n                    match r with\n                    | Choice2Of2 x -> dispatch (ofError x)\n                    | _ -> ()\n                }\n            [bind >> start]\n\n        /// Command that will evaluate an async block to the message\n        let result (start: Async<unit> -> unit) \n                   (task: Async<'msg>) : Cmd<'msg> =\n            let bind dispatch =\n                async {\n                    let! r = task\n                    dispatch r\n                }\n            [bind >> start]\n\n    module OfAsync =\n#if FABLE_COMPILER\n        let start x = Timer.delay 0 (fun _ -> Async.StartImmediate x)\n#else\n        let inline start x = Async.Start x\n#endif    \n        /// Command that will evaluate an async block and map the result\n        /// into success or error (of exception)\n        let inline either (task: 'a -> Async<_>)\n                          (arg: 'a)\n                          (ofSuccess: _ -> 'msg)\n                          (ofError: _ -> 'msg) : Cmd<'msg> =\n            OfAsyncWith.either start task arg ofSuccess ofError\n\n        /// Command that will evaluate an async block and map the success\n        let inline perform (task: 'a -> Async<_>)\n                           (arg: 'a)\n                           (ofSuccess: _ -> 'msg) : Cmd<'msg> =\n            OfAsyncWith.perform start task arg ofSuccess\n\n        /// Command that will evaluate an async block and map the error (of exception)\n        let inline attempt (task: 'a -> Async<_>)\n                           (arg: 'a)\n                           (ofError: _ -> 'msg) : Cmd<'msg> =\n            OfAsyncWith.attempt start task arg ofError\n\n        /// Command that will evaluate an async block to the message\n        let inline result (task: Async<'msg>) : Cmd<'msg> =\n            OfAsyncWith.result start task\n\n    module OfAsyncImmediate =\n        /// Command that will evaluate an async block and map the result\n        /// into success or error (of exception)\n        let inline either (task: 'a -> Async<_>)\n                          (arg: 'a)\n                          (ofSuccess: _ -> 'msg)\n                          (ofError: _ -> 'msg) : Cmd<'msg> =\n            OfAsyncWith.either Async.StartImmediate task arg ofSuccess ofError\n\n        /// Command that will evaluate an async block and map the success\n        let inline perform (task: 'a -> Async<_>)\n                           (arg: 'a)\n                           (ofSuccess: _ -> 'msg) : Cmd<'msg> =\n            OfAsyncWith.perform Async.StartImmediate task arg ofSuccess\n\n        /// Command that will evaluate an async block and map the error (of exception)\n        let inline attempt (task: 'a -> Async<_>)\n                           (arg: 'a)\n                           (ofError: _ -> 'msg) : Cmd<'msg> =\n            OfAsyncWith.attempt Async.StartImmediate task arg ofError\n\n        /// Command that will evaluate an async block to the message\n        let inline result (task: Async<'msg>) : Cmd<'msg> =\n            OfAsyncWith.result Async.StartImmediate task\n\n#if FABLE_COMPILER\n    module OfPromise =\n        /// Command to call `promise` block and map the results\n        let either (task: 'a -> Fable.Core.JS.Promise<_>)\n                   (arg:'a)\n                   (ofSuccess: _ -> 'msg)\n                   (ofError: #exn -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                (task arg)\n                    .``then``(ofSuccess >> dispatch)\n                    .catch(unbox >> ofError >> dispatch)\n                    |> ignore\n            [bind]\n\n        /// Command to call `promise` block and map the success\n        let perform (task: 'a -> Fable.Core.JS.Promise<_>)\n                   (arg:'a)\n                   (ofSuccess: _ -> 'msg) =\n            let bind dispatch =\n                (task arg)\n                    .``then``(ofSuccess >> dispatch)\n                    |> ignore\n            [bind]\n\n        /// Command to call `promise` block and map the error\n        let attempt (task: 'a -> Fable.Core.JS.Promise<_>)\n                    (arg:'a)\n                    (ofError: #exn -> 'msg) : Cmd<'msg> =\n            let bind dispatch =\n                (task arg)\n                    .catch(unbox >> ofError >> dispatch)\n                    |> ignore\n            [bind]\n\n        /// Command to dispatch the `promise` result\n        let result (task: Fable.Core.JS.Promise<'msg>) =\n            let bind dispatch =\n                task.``then`` dispatch\n                |> ignore\n            [bind]\n\n    [<Obsolete(\"Use `OfPromise.either` instead\")>]\n    let inline ofPromise (task: 'a -> Fable.Core.JS.Promise<_>)\n                         (arg:'a)\n                         (ofSuccess: _ -> 'msg)\n                         (ofError: _ -> 'msg) : Cmd<'msg> =\n        OfPromise.either task arg ofSuccess ofError                     \n#else\n    open System.Threading.Tasks\n    module OfTask =\n        /// Command to call a task and map the results\n        let inline either (task: 'a -> Task<_>)\n                          (arg:'a)\n                          (ofSuccess: _ -> 'msg)\n                          (ofError: _ -> 'msg) : Cmd<'msg> =\n            OfAsync.either (task >> Async.AwaitTask) arg ofSuccess ofError\n\n        /// Command to call a task and map the success\n        let inline perform (task: 'a -> Task<_>)\n                           (arg:'a)\n                           (ofSuccess: _ -> 'msg) : Cmd<'msg> =\n            OfAsync.perform (task >> Async.AwaitTask) arg ofSuccess\n\n        /// Command to call a task and map the error\n        let inline attempt (task: 'a -> Task<_>)\n                           (arg:'a)\n                           (ofError: _ -> 'msg) : Cmd<'msg> =\n            OfAsync.attempt (task >> Async.AwaitTask) arg ofError\n\n        /// Command and map the task success\n        let inline result (task: Task<'msg>) : Cmd<'msg> =\n            OfAsync.result (task |> Async.AwaitTask)\n\n    [<Obsolete(\"Use OfTask.either instead\")>]\n    let inline ofTask (task: 'a -> Task<_>)\n                      (arg:'a)\n                      (ofSuccess: _ -> 'msg)\n                      (ofError: _ -> 'msg) : Cmd<'msg> =\n        OfTask.either task arg ofSuccess ofError\n#endif\n\n    // Synonymous with `OfFunc.result`, may be removed in the future\n    let inline ofMsg (msg:'msg) : Cmd<'msg> =\n        OfFunc.result msg\n\n    [<Obsolete(\"Use `Cmd.OfAsync.either` instead\")>]\n    let inline ofAsync (task: 'a -> Async<_>)\n                       (arg: 'a)\n                       (ofSuccess: _ -> 'msg)\n                       (ofError: _ -> 'msg) : Cmd<'msg> =\n        OfAsync.either task arg ofSuccess ofError\n\n    [<Obsolete(\"Use `Cmd.OfFunc.either` instead\")>]\n    let inline ofFunc (task: 'a -> _) (arg: 'a) (ofSuccess: _ -> 'msg) (ofError: _ -> 'msg) : Cmd<'msg> =\n        OfFunc.either task arg ofSuccess ofError\n\n    [<Obsolete(\"Use `Cmd.OfFunc.perform` instead\")>]\n    let inline performFunc (task: 'a -> _) (arg: 'a) (ofSuccess: _ -> 'msg) : Cmd<'msg> =\n        OfFunc.perform task arg ofSuccess\n\n    [<Obsolete(\"Use `Cmd.OfFunc.attempt` instead\")>]\n    let attemptFunc (task: 'a -> unit) (arg: 'a) (ofError: _ -> 'msg) : Cmd<'msg> =\n        OfFunc.attempt task arg ofError\n\n","import { clear, equals, isArrayLike, isDisposable, toIterator, disposeSafe, getEnumerator } from \"./Util.js\";\r\nimport { toString } from \"./Types.js\";\r\nimport { class_type } from \"./Reflection.js\";\r\nimport { some, value as value_1 } from \"./Option.js\";\r\nimport { Operators_Lock, Operators_NullArg } from \"./FSharp.Core.js\";\r\nimport { chunkBySize as chunkBySize_1, permute as permute_1, transpose as transpose_1, windowed as windowed_1, splitInto as splitInto_1, map as map_1, pairwise as pairwise_1, scanBack as scanBack_1, reverse as reverse_1, mapFoldBack as mapFoldBack_1, mapFold as mapFold_1, tryItem as tryItem_1, tryHead as tryHead_1, foldBack2 as foldBack2_1, foldBack as foldBack_1, tryFindIndexBack as tryFindIndexBack_1, tryFindBack as tryFindBack_1, singleton as singleton_1 } from \"./Array.js\";\r\nimport { length as length_1, tryItem as tryItem_2, isEmpty as isEmpty_1, tryHead as tryHead_2, ofSeq as ofSeq_1, ofArray as ofArray_1, toArray as toArray_1, FSharpList } from \"./List.js\";\r\nimport { SR_indexOutOfBounds } from \"./Global.js\";\r\n\r\nexport const SR_enumerationAlreadyFinished = \"Enumeration already finished.\";\r\n\r\nexport const SR_enumerationNotStarted = \"Enumeration has not started. Call MoveNext.\";\r\n\r\nexport const SR_inputSequenceEmpty = \"The input sequence was empty.\";\r\n\r\nexport const SR_inputSequenceTooLong = \"The input sequence contains more than one element.\";\r\n\r\nexport const SR_keyNotFoundAlt = \"An index satisfying the predicate was not found in the collection.\";\r\n\r\nexport const SR_notEnoughElements = \"The input sequence has an insufficient number of elements.\";\r\n\r\nexport const SR_resetNotSupported = \"Reset is not supported on this enumerator.\";\r\n\r\nexport function Enumerator_noReset() {\r\n    throw (new Error(SR_resetNotSupported));\r\n}\r\n\r\nexport function Enumerator_notStarted() {\r\n    throw (new Error(SR_enumerationNotStarted));\r\n}\r\n\r\nexport function Enumerator_alreadyFinished() {\r\n    throw (new Error(SR_enumerationAlreadyFinished));\r\n}\r\n\r\nexport class Enumerator_Seq {\r\n    constructor(f) {\r\n        this.f = f;\r\n    }\r\n    toString() {\r\n        const xs = this;\r\n        const maxCount = 4;\r\n        let i = 0;\r\n        let str = \"seq [\";\r\n        const e = getEnumerator(xs);\r\n        try {\r\n            while ((i < maxCount) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                if (i > 0) {\r\n                    str = (str + \"; \");\r\n                }\r\n                str = (str + toString(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()));\r\n                i = ((i + 1) | 0);\r\n            }\r\n            if (i === maxCount) {\r\n                str = (str + \"; ...\");\r\n            }\r\n            return str + \"]\";\r\n        }\r\n        finally {\r\n            disposeSafe(e);\r\n        }\r\n    }\r\n    GetEnumerator() {\r\n        const x = this;\r\n        return x.f();\r\n    }\r\n    [Symbol.iterator]() {\r\n        return toIterator(this.GetEnumerator());\r\n    }\r\n    [\"System.Collections.IEnumerable.GetEnumerator\"]() {\r\n        const x = this;\r\n        return x.f();\r\n    }\r\n}\r\n\r\nexport function Enumerator_Seq$reflection(gen0) {\r\n    return class_type(\"SeqModule.Enumerator.Seq\", [gen0], Enumerator_Seq);\r\n}\r\n\r\nexport function Enumerator_Seq_$ctor_673A07F2(f) {\r\n    return new Enumerator_Seq(f);\r\n}\r\n\r\nexport class Enumerator_FromFunctions$1 {\r\n    constructor(current, next, dispose) {\r\n        this.current = current;\r\n        this.next = next;\r\n        this.dispose = dispose;\r\n    }\r\n    [\"System.Collections.Generic.IEnumerator`1.get_Current\"]() {\r\n        const __ = this;\r\n        return __.current();\r\n    }\r\n    [\"System.Collections.IEnumerator.get_Current\"]() {\r\n        const __ = this;\r\n        return __.current();\r\n    }\r\n    [\"System.Collections.IEnumerator.MoveNext\"]() {\r\n        const __ = this;\r\n        return __.next();\r\n    }\r\n    [\"System.Collections.IEnumerator.Reset\"]() {\r\n        Enumerator_noReset();\r\n    }\r\n    Dispose() {\r\n        const __ = this;\r\n        __.dispose();\r\n    }\r\n}\r\n\r\nexport function Enumerator_FromFunctions$1$reflection(gen0) {\r\n    return class_type(\"SeqModule.Enumerator.FromFunctions`1\", [gen0], Enumerator_FromFunctions$1);\r\n}\r\n\r\nexport function Enumerator_FromFunctions$1_$ctor_58C54629(current, next, dispose) {\r\n    return new Enumerator_FromFunctions$1(current, next, dispose);\r\n}\r\n\r\nexport function Enumerator_cast(e) {\r\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => e[\"System.Collections.IEnumerator.get_Current\"](), () => e[\"System.Collections.IEnumerator.MoveNext\"](), () => {\r\n        if (isDisposable(e)) {\r\n            disposeSafe(e);\r\n        }\r\n    });\r\n}\r\n\r\nexport function Enumerator_concat(sources) {\r\n    let outerOpt = void 0;\r\n    let innerOpt = void 0;\r\n    let started = false;\r\n    let finished = false;\r\n    let curr = void 0;\r\n    const finish = () => {\r\n        finished = true;\r\n        if (innerOpt != null) {\r\n            const inner = innerOpt;\r\n            try {\r\n                disposeSafe(inner);\r\n            }\r\n            finally {\r\n                innerOpt = (void 0);\r\n            }\r\n        }\r\n        if (outerOpt != null) {\r\n            const outer = outerOpt;\r\n            try {\r\n                disposeSafe(outer);\r\n            }\r\n            finally {\r\n                outerOpt = (void 0);\r\n            }\r\n        }\r\n    };\r\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => {\r\n        if (!started) {\r\n            Enumerator_notStarted();\r\n        }\r\n        else if (finished) {\r\n            Enumerator_alreadyFinished();\r\n        }\r\n        if (curr != null) {\r\n            return value_1(curr);\r\n        }\r\n        else {\r\n            return Enumerator_alreadyFinished();\r\n        }\r\n    }, () => {\r\n        let copyOfStruct;\r\n        if (!started) {\r\n            started = true;\r\n        }\r\n        if (finished) {\r\n            return false;\r\n        }\r\n        else {\r\n            let res = void 0;\r\n            while (res == null) {\r\n                const matchValue = [outerOpt, innerOpt];\r\n                if (matchValue[0] != null) {\r\n                    if (matchValue[1] != null) {\r\n                        const inner_1 = matchValue[1];\r\n                        if (inner_1[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                            curr = some(inner_1[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n                            res = true;\r\n                        }\r\n                        else {\r\n                            try {\r\n                                disposeSafe(inner_1);\r\n                            }\r\n                            finally {\r\n                                innerOpt = (void 0);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        const outer_1 = matchValue[0];\r\n                        if (outer_1[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                            const ie = outer_1[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n                            innerOpt = ((copyOfStruct = ie, getEnumerator(copyOfStruct)));\r\n                        }\r\n                        else {\r\n                            finish();\r\n                            res = false;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    outerOpt = getEnumerator(sources);\r\n                }\r\n            }\r\n            return value_1(res);\r\n        }\r\n    }, () => {\r\n        if (!finished) {\r\n            finish();\r\n        }\r\n    });\r\n}\r\n\r\nexport function Enumerator_enumerateThenFinally(f, e) {\r\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => e[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), () => e[\"System.Collections.IEnumerator.MoveNext\"](), () => {\r\n        try {\r\n            disposeSafe(e);\r\n        }\r\n        finally {\r\n            f();\r\n        }\r\n    });\r\n}\r\n\r\nexport function Enumerator_generateWhileSome(openf, compute, closef) {\r\n    let started = false;\r\n    let curr = void 0;\r\n    let state = some(openf());\r\n    const dispose = () => {\r\n        if (state != null) {\r\n            const x_1 = value_1(state);\r\n            try {\r\n                closef(x_1);\r\n            }\r\n            finally {\r\n                state = (void 0);\r\n            }\r\n        }\r\n    };\r\n    const finish = () => {\r\n        try {\r\n            dispose();\r\n        }\r\n        finally {\r\n            curr = (void 0);\r\n        }\r\n    };\r\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => {\r\n        if (!started) {\r\n            Enumerator_notStarted();\r\n        }\r\n        if (curr != null) {\r\n            return value_1(curr);\r\n        }\r\n        else {\r\n            return Enumerator_alreadyFinished();\r\n        }\r\n    }, () => {\r\n        if (!started) {\r\n            started = true;\r\n        }\r\n        if (state != null) {\r\n            const s = value_1(state);\r\n            let matchValue_1;\r\n            try {\r\n                matchValue_1 = compute(s);\r\n            }\r\n            catch (matchValue) {\r\n                finish();\r\n                throw matchValue;\r\n            }\r\n            if (matchValue_1 != null) {\r\n                curr = matchValue_1;\r\n                return true;\r\n            }\r\n            else {\r\n                finish();\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }, dispose);\r\n}\r\n\r\nexport function Enumerator_unfold(f, state) {\r\n    let curr = void 0;\r\n    let acc = state;\r\n    return Enumerator_FromFunctions$1_$ctor_58C54629(() => {\r\n        if (curr != null) {\r\n            const x = curr[0];\r\n            const st = curr[1];\r\n            return x;\r\n        }\r\n        else {\r\n            return Enumerator_notStarted();\r\n        }\r\n    }, () => {\r\n        curr = f(acc);\r\n        if (curr != null) {\r\n            const x_1 = curr[0];\r\n            const st_1 = curr[1];\r\n            acc = st_1;\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }, () => {\r\n    });\r\n}\r\n\r\nexport function indexNotFound() {\r\n    throw (new Error(SR_keyNotFoundAlt));\r\n}\r\n\r\nexport function checkNonNull(argName, arg) {\r\n    if (arg == null) {\r\n        Operators_NullArg(argName);\r\n    }\r\n}\r\n\r\nexport function mkSeq(f) {\r\n    return Enumerator_Seq_$ctor_673A07F2(f);\r\n}\r\n\r\nexport function ofSeq(xs) {\r\n    checkNonNull(\"source\", xs);\r\n    return getEnumerator(xs);\r\n}\r\n\r\nexport function delay(generator) {\r\n    return mkSeq(() => getEnumerator(generator()));\r\n}\r\n\r\nexport function concat(sources) {\r\n    return mkSeq(() => Enumerator_concat(sources));\r\n}\r\n\r\nexport function unfold(generator, state) {\r\n    return mkSeq(() => Enumerator_unfold(generator, state));\r\n}\r\n\r\nexport function empty() {\r\n    return delay(() => (new Array(0)));\r\n}\r\n\r\nexport function singleton(x) {\r\n    return delay(() => singleton_1(x));\r\n}\r\n\r\nexport function ofArray(arr) {\r\n    return arr;\r\n}\r\n\r\nexport function toArray(xs) {\r\n    if (xs instanceof FSharpList) {\r\n        return toArray_1(xs);\r\n    }\r\n    else {\r\n        return Array.from(xs);\r\n    }\r\n}\r\n\r\nexport function ofList(xs) {\r\n    return xs;\r\n}\r\n\r\nexport function toList(xs) {\r\n    if (isArrayLike(xs)) {\r\n        return ofArray_1(xs);\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return xs;\r\n    }\r\n    else {\r\n        return ofSeq_1(xs);\r\n    }\r\n}\r\n\r\nexport function generate(create, compute, dispose) {\r\n    return mkSeq(() => Enumerator_generateWhileSome(create, compute, dispose));\r\n}\r\n\r\nexport function generateIndexed(create, compute, dispose) {\r\n    return mkSeq(() => {\r\n        let i = -1;\r\n        return Enumerator_generateWhileSome(create, (x) => {\r\n            i = ((i + 1) | 0);\r\n            return compute(i, x);\r\n        }, dispose);\r\n    });\r\n}\r\n\r\nexport function append(xs, ys) {\r\n    return concat([xs, ys]);\r\n}\r\n\r\nexport function cast(xs) {\r\n    return mkSeq(() => {\r\n        checkNonNull(\"source\", xs);\r\n        return Enumerator_cast(getEnumerator(xs));\r\n    });\r\n}\r\n\r\nexport function choose(chooser, xs) {\r\n    return generate(() => ofSeq(xs), (e) => {\r\n        let curr = void 0;\r\n        while ((curr == null) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            curr = chooser(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        return curr;\r\n    }, (e_1) => {\r\n        disposeSafe(e_1);\r\n    });\r\n}\r\n\r\nexport function compareWith(comparer, xs, ys) {\r\n    const e1 = ofSeq(xs);\r\n    try {\r\n        const e2 = ofSeq(ys);\r\n        try {\r\n            let c = 0;\r\n            let b1 = e1[\"System.Collections.IEnumerator.MoveNext\"]();\r\n            let b2 = e2[\"System.Collections.IEnumerator.MoveNext\"]();\r\n            while (((c === 0) && b1) && b2) {\r\n                c = (comparer(e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) | 0);\r\n                if (c === 0) {\r\n                    b1 = e1[\"System.Collections.IEnumerator.MoveNext\"]();\r\n                    b2 = e2[\"System.Collections.IEnumerator.MoveNext\"]();\r\n                }\r\n            }\r\n            return ((c !== 0) ? c : (b1 ? 1 : (b2 ? -1 : 0))) | 0;\r\n        }\r\n        finally {\r\n            disposeSafe(e2);\r\n        }\r\n    }\r\n    finally {\r\n        disposeSafe(e1);\r\n    }\r\n}\r\n\r\nexport function contains(value, xs, comparer) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        let found = false;\r\n        while ((!found) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            found = comparer.Equals(value, e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        return found;\r\n    }\r\n    finally {\r\n        disposeSafe(e);\r\n    }\r\n}\r\n\r\nexport function enumerateFromFunctions(create, moveNext, current) {\r\n    return generate(create, (x) => (moveNext(x) ? some(current(x)) : (void 0)), (x_1) => {\r\n        const matchValue = x_1;\r\n        if (isDisposable(matchValue)) {\r\n            disposeSafe(matchValue);\r\n        }\r\n    });\r\n}\r\n\r\nexport function enumerateThenFinally(source, compensation) {\r\n    const compensation_1 = compensation;\r\n    return mkSeq(() => {\r\n        try {\r\n            return Enumerator_enumerateThenFinally(compensation_1, ofSeq(source));\r\n        }\r\n        catch (matchValue) {\r\n            compensation_1();\r\n            throw matchValue;\r\n        }\r\n    });\r\n}\r\n\r\nexport function enumerateUsing(resource, source) {\r\n    const compensation = () => {\r\n        if (equals(resource, null)) {\r\n        }\r\n        else {\r\n            let copyOfStruct = resource;\r\n            disposeSafe(copyOfStruct);\r\n        }\r\n    };\r\n    return mkSeq(() => {\r\n        try {\r\n            return Enumerator_enumerateThenFinally(compensation, (ofSeq)(source(resource)));\r\n        }\r\n        catch (matchValue_1) {\r\n            compensation();\r\n            throw matchValue_1;\r\n        }\r\n    });\r\n}\r\n\r\nexport function enumerateWhile(guard, xs) {\r\n    return concat(unfold((i) => (guard() ? [xs, i + 1] : (void 0)), 0));\r\n}\r\n\r\nexport function filter(f, xs) {\r\n    return choose((x) => {\r\n        if (f(x)) {\r\n            return some(x);\r\n        }\r\n        else {\r\n            return void 0;\r\n        }\r\n    }, xs);\r\n}\r\n\r\nexport function exists(predicate, xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        let found = false;\r\n        while ((!found) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            found = predicate(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        return found;\r\n    }\r\n    finally {\r\n        disposeSafe(e);\r\n    }\r\n}\r\n\r\nexport function exists2(predicate, xs, ys) {\r\n    const e1 = ofSeq(xs);\r\n    try {\r\n        const e2 = ofSeq(ys);\r\n        try {\r\n            let found = false;\r\n            while (((!found) && e1[\"System.Collections.IEnumerator.MoveNext\"]()) && e2[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                found = predicate(e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n            }\r\n            return found;\r\n        }\r\n        finally {\r\n            disposeSafe(e2);\r\n        }\r\n    }\r\n    finally {\r\n        disposeSafe(e1);\r\n    }\r\n}\r\n\r\nexport function exactlyOne(xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            const v = e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n            if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                throw (new Error((SR_inputSequenceTooLong + \"\\\\nParameter name: \") + \"source\"));\r\n            }\r\n            else {\r\n                return v;\r\n            }\r\n        }\r\n        else {\r\n            throw (new Error((SR_inputSequenceEmpty + \"\\\\nParameter name: \") + \"source\"));\r\n        }\r\n    }\r\n    finally {\r\n        disposeSafe(e);\r\n    }\r\n}\r\n\r\nexport function tryExactlyOne(xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            const v = e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n            return e[\"System.Collections.IEnumerator.MoveNext\"]() ? (void 0) : some(v);\r\n        }\r\n        else {\r\n            return void 0;\r\n        }\r\n    }\r\n    finally {\r\n        disposeSafe(e);\r\n    }\r\n}\r\n\r\nexport function tryFind(predicate, xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        let res = void 0;\r\n        while ((res == null) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            const c = e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n            if (predicate(c)) {\r\n                res = some(c);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    finally {\r\n        disposeSafe(e);\r\n    }\r\n}\r\n\r\nexport function find(predicate, xs) {\r\n    const matchValue = tryFind(predicate, xs);\r\n    if (matchValue == null) {\r\n        return indexNotFound();\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFindBack(predicate, xs) {\r\n    return tryFindBack_1(predicate, toArray(xs));\r\n}\r\n\r\nexport function findBack(predicate, xs) {\r\n    const matchValue = tryFindBack(predicate, xs);\r\n    if (matchValue == null) {\r\n        return indexNotFound();\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFindIndex(predicate, xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        const loop = (i_mut) => {\r\n            loop:\r\n            while (true) {\r\n                const i = i_mut;\r\n                if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                    if (predicate(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) {\r\n                        return i;\r\n                    }\r\n                    else {\r\n                        i_mut = (i + 1);\r\n                        continue loop;\r\n                    }\r\n                }\r\n                else {\r\n                    return void 0;\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        return loop(0);\r\n    }\r\n    finally {\r\n        disposeSafe(e);\r\n    }\r\n}\r\n\r\nexport function findIndex(predicate, xs) {\r\n    const matchValue = tryFindIndex(predicate, xs);\r\n    if (matchValue == null) {\r\n        return indexNotFound() | 0;\r\n    }\r\n    else {\r\n        return matchValue | 0;\r\n    }\r\n}\r\n\r\nexport function tryFindIndexBack(predicate, xs) {\r\n    return tryFindIndexBack_1(predicate, toArray(xs));\r\n}\r\n\r\nexport function findIndexBack(predicate, xs) {\r\n    const matchValue = tryFindIndexBack(predicate, xs);\r\n    if (matchValue == null) {\r\n        return indexNotFound() | 0;\r\n    }\r\n    else {\r\n        return matchValue | 0;\r\n    }\r\n}\r\n\r\nexport function fold(folder, state, xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        let acc = state;\r\n        while (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            acc = folder(acc, e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        return acc;\r\n    }\r\n    finally {\r\n        disposeSafe(e);\r\n    }\r\n}\r\n\r\nexport function foldBack(folder, xs, state) {\r\n    return foldBack_1(folder, toArray(xs), state);\r\n}\r\n\r\nexport function fold2(folder, state, xs, ys) {\r\n    const e1 = ofSeq(xs);\r\n    try {\r\n        const e2 = ofSeq(ys);\r\n        try {\r\n            let acc = state;\r\n            while (e1[\"System.Collections.IEnumerator.MoveNext\"]() && e2[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                acc = folder(acc, e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n            }\r\n            return acc;\r\n        }\r\n        finally {\r\n            disposeSafe(e2);\r\n        }\r\n    }\r\n    finally {\r\n        disposeSafe(e1);\r\n    }\r\n}\r\n\r\nexport function foldBack2(folder, xs, ys, state) {\r\n    return foldBack2_1(folder, toArray(xs), toArray(ys), state);\r\n}\r\n\r\nexport function forAll(predicate, xs) {\r\n    return !exists((x) => (!predicate(x)), xs);\r\n}\r\n\r\nexport function forAll2(predicate, xs, ys) {\r\n    return !exists2((x, y) => (!predicate(x, y)), xs, ys);\r\n}\r\n\r\nexport function tryHead(xs) {\r\n    if (isArrayLike(xs)) {\r\n        return tryHead_1(xs);\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return tryHead_2(xs);\r\n    }\r\n    else {\r\n        const e = ofSeq(xs);\r\n        try {\r\n            return e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) : (void 0);\r\n        }\r\n        finally {\r\n            disposeSafe(e);\r\n        }\r\n    }\r\n}\r\n\r\nexport function head(xs) {\r\n    const matchValue = tryHead(xs);\r\n    if (matchValue == null) {\r\n        throw (new Error((SR_inputSequenceEmpty + \"\\\\nParameter name: \") + \"source\"));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function initialize(count, f) {\r\n    return unfold((i) => ((i < count) ? [f(i), i + 1] : (void 0)), 0);\r\n}\r\n\r\nexport function initializeInfinite(f) {\r\n    return initialize(2147483647, f);\r\n}\r\n\r\nexport function isEmpty(xs) {\r\n    if (isArrayLike(xs)) {\r\n        return xs.length === 0;\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return isEmpty_1(xs);\r\n    }\r\n    else {\r\n        const e = ofSeq(xs);\r\n        try {\r\n            return !e[\"System.Collections.IEnumerator.MoveNext\"]();\r\n        }\r\n        finally {\r\n            disposeSafe(e);\r\n        }\r\n    }\r\n}\r\n\r\nexport function tryItem(index, xs) {\r\n    if (isArrayLike(xs)) {\r\n        return tryItem_1(index, xs);\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return tryItem_2(index, xs);\r\n    }\r\n    else {\r\n        const e = ofSeq(xs);\r\n        try {\r\n            const loop = (index_1_mut) => {\r\n                loop:\r\n                while (true) {\r\n                    const index_1 = index_1_mut;\r\n                    if (!e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                        return void 0;\r\n                    }\r\n                    else if (index_1 === 0) {\r\n                        return some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n                    }\r\n                    else {\r\n                        index_1_mut = (index_1 - 1);\r\n                        continue loop;\r\n                    }\r\n                    break;\r\n                }\r\n            };\r\n            return loop(index);\r\n        }\r\n        finally {\r\n            disposeSafe(e);\r\n        }\r\n    }\r\n}\r\n\r\nexport function item(index, xs) {\r\n    const matchValue = tryItem(index, xs);\r\n    if (matchValue == null) {\r\n        throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function iterate(action, xs) {\r\n    fold((unitVar0, x) => {\r\n        action(x);\r\n    }, void 0, xs);\r\n}\r\n\r\nexport function iterate2(action, xs, ys) {\r\n    fold2((unitVar0, x, y) => {\r\n        action(x, y);\r\n    }, void 0, xs, ys);\r\n}\r\n\r\nexport function iterateIndexed(action, xs) {\r\n    fold((i, x) => {\r\n        action(i, x);\r\n        return (i + 1) | 0;\r\n    }, 0, xs);\r\n}\r\n\r\nexport function iterateIndexed2(action, xs, ys) {\r\n    fold2((i, x, y) => {\r\n        action(i, x, y);\r\n        return (i + 1) | 0;\r\n    }, 0, xs, ys);\r\n}\r\n\r\nexport function tryLast(xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        const loop = (acc_mut) => {\r\n            loop:\r\n            while (true) {\r\n                const acc = acc_mut;\r\n                if (!e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                    return acc;\r\n                }\r\n                else {\r\n                    acc_mut = e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n                    continue loop;\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        return e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(loop(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : (void 0);\r\n    }\r\n    finally {\r\n        disposeSafe(e);\r\n    }\r\n}\r\n\r\nexport function last(xs) {\r\n    const matchValue = tryLast(xs);\r\n    if (matchValue == null) {\r\n        throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"source\"));\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function length(xs) {\r\n    if (isArrayLike(xs)) {\r\n        return xs.length | 0;\r\n    }\r\n    else if (xs instanceof FSharpList) {\r\n        return length_1(xs) | 0;\r\n    }\r\n    else {\r\n        const e = ofSeq(xs);\r\n        try {\r\n            let count = 0;\r\n            while (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                count = ((count + 1) | 0);\r\n            }\r\n            return count | 0;\r\n        }\r\n        finally {\r\n            disposeSafe(e);\r\n        }\r\n    }\r\n}\r\n\r\nexport function map(mapping, xs) {\r\n    return generate(() => ofSeq(xs), (e) => (e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(mapping(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : (void 0)), (e_1) => {\r\n        disposeSafe(e_1);\r\n    });\r\n}\r\n\r\nexport function mapIndexed(mapping, xs) {\r\n    return generateIndexed(() => ofSeq(xs), (i, e) => (e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(mapping(i, e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : (void 0)), (e_1) => {\r\n        disposeSafe(e_1);\r\n    });\r\n}\r\n\r\nexport function indexed(xs) {\r\n    return mapIndexed((i, x) => [i, x], xs);\r\n}\r\n\r\nexport function map2(mapping, xs, ys) {\r\n    return generate(() => [ofSeq(xs), ofSeq(ys)], (tupledArg) => {\r\n        const e1 = tupledArg[0];\r\n        const e2 = tupledArg[1];\r\n        return (e1[\"System.Collections.IEnumerator.MoveNext\"]() && e2[\"System.Collections.IEnumerator.MoveNext\"]()) ? some(mapping(e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : (void 0);\r\n    }, (tupledArg_1) => {\r\n        try {\r\n            disposeSafe(tupledArg_1[0]);\r\n        }\r\n        finally {\r\n            disposeSafe(tupledArg_1[1]);\r\n        }\r\n    });\r\n}\r\n\r\nexport function mapIndexed2(mapping, xs, ys) {\r\n    return generateIndexed(() => [ofSeq(xs), ofSeq(ys)], (i, tupledArg) => {\r\n        const e1 = tupledArg[0];\r\n        const e2 = tupledArg[1];\r\n        return (e1[\"System.Collections.IEnumerator.MoveNext\"]() && e2[\"System.Collections.IEnumerator.MoveNext\"]()) ? some(mapping(i, e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : (void 0);\r\n    }, (tupledArg_1) => {\r\n        try {\r\n            disposeSafe(tupledArg_1[0]);\r\n        }\r\n        finally {\r\n            disposeSafe(tupledArg_1[1]);\r\n        }\r\n    });\r\n}\r\n\r\nexport function map3(mapping, xs, ys, zs) {\r\n    return generate(() => [ofSeq(xs), ofSeq(ys), ofSeq(zs)], (tupledArg) => {\r\n        const e1 = tupledArg[0];\r\n        const e2 = tupledArg[1];\r\n        const e3 = tupledArg[2];\r\n        return ((e1[\"System.Collections.IEnumerator.MoveNext\"]() && e2[\"System.Collections.IEnumerator.MoveNext\"]()) && e3[\"System.Collections.IEnumerator.MoveNext\"]()) ? some(mapping(e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), e3[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) : (void 0);\r\n    }, (tupledArg_1) => {\r\n        try {\r\n            disposeSafe(tupledArg_1[0]);\r\n        }\r\n        finally {\r\n            try {\r\n                disposeSafe(tupledArg_1[1]);\r\n            }\r\n            finally {\r\n                disposeSafe(tupledArg_1[2]);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function readOnly(xs) {\r\n    checkNonNull(\"source\", xs);\r\n    return map((x) => x, xs);\r\n}\r\n\r\nexport class CachedSeq$1 {\r\n    constructor(cleanup, res) {\r\n        this.cleanup = cleanup;\r\n        this.res = res;\r\n    }\r\n    Dispose() {\r\n        const _ = this;\r\n        _.cleanup();\r\n    }\r\n    GetEnumerator() {\r\n        const _ = this;\r\n        return getEnumerator(_.res);\r\n    }\r\n    [Symbol.iterator]() {\r\n        return toIterator(this.GetEnumerator());\r\n    }\r\n    [\"System.Collections.IEnumerable.GetEnumerator\"]() {\r\n        const _ = this;\r\n        return getEnumerator(_.res);\r\n    }\r\n}\r\n\r\nexport function CachedSeq$1$reflection(gen0) {\r\n    return class_type(\"SeqModule.CachedSeq`1\", [gen0], CachedSeq$1);\r\n}\r\n\r\nexport function CachedSeq$1_$ctor_Z7A8347D4(cleanup, res) {\r\n    return new CachedSeq$1(cleanup, res);\r\n}\r\n\r\nexport function CachedSeq$1__Clear(_) {\r\n    _.cleanup();\r\n}\r\n\r\nexport function cache(source) {\r\n    checkNonNull(\"source\", source);\r\n    const prefix = [];\r\n    let enumeratorR = void 0;\r\n    return CachedSeq$1_$ctor_Z7A8347D4(() => {\r\n        Operators_Lock(prefix, () => {\r\n            clear(prefix);\r\n            let pattern_matching_result, e;\r\n            if (enumeratorR != null) {\r\n                if (value_1(enumeratorR) != null) {\r\n                    pattern_matching_result = 0;\r\n                    e = value_1(enumeratorR);\r\n                }\r\n                else {\r\n                    pattern_matching_result = 1;\r\n                }\r\n            }\r\n            else {\r\n                pattern_matching_result = 1;\r\n            }\r\n            switch (pattern_matching_result) {\r\n                case 0: {\r\n                    disposeSafe(e);\r\n                    break;\r\n                }\r\n            }\r\n            enumeratorR = (void 0);\r\n        });\r\n    }, unfold((i_1) => Operators_Lock(prefix, () => {\r\n        if (i_1 < prefix.length) {\r\n            return [prefix[i_1], i_1 + 1];\r\n        }\r\n        else {\r\n            if (i_1 >= prefix.length) {\r\n                let optEnumerator_2;\r\n                if (enumeratorR != null) {\r\n                    optEnumerator_2 = value_1(enumeratorR);\r\n                }\r\n                else {\r\n                    const optEnumerator = getEnumerator(source);\r\n                    enumeratorR = some(optEnumerator);\r\n                    optEnumerator_2 = optEnumerator;\r\n                }\r\n                if (optEnumerator_2 == null) {\r\n                }\r\n                else {\r\n                    const enumerator = optEnumerator_2;\r\n                    if (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                        void (prefix.push(enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()));\r\n                    }\r\n                    else {\r\n                        disposeSafe(enumerator);\r\n                        enumeratorR = some(void 0);\r\n                    }\r\n                }\r\n            }\r\n            return (i_1 < prefix.length) ? [prefix[i_1], i_1 + 1] : (void 0);\r\n        }\r\n    }), 0));\r\n}\r\n\r\nexport function allPairs(xs, ys) {\r\n    const ysCache = cache(ys);\r\n    return delay(() => concat(map((x) => map((y) => [x, y], ysCache), xs)));\r\n}\r\n\r\nexport function mapFold(mapping, state, xs) {\r\n    const patternInput = mapFold_1(mapping, state, toArray(xs));\r\n    return [readOnly(patternInput[0]), patternInput[1]];\r\n}\r\n\r\nexport function mapFoldBack(mapping, xs, state) {\r\n    const patternInput = mapFoldBack_1(mapping, toArray(xs), state);\r\n    return [readOnly(patternInput[0]), patternInput[1]];\r\n}\r\n\r\nexport function tryPick(chooser, xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        let res = void 0;\r\n        while ((res == null) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            res = chooser(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        return res;\r\n    }\r\n    finally {\r\n        disposeSafe(e);\r\n    }\r\n}\r\n\r\nexport function pick(chooser, xs) {\r\n    const matchValue = tryPick(chooser, xs);\r\n    if (matchValue == null) {\r\n        return indexNotFound();\r\n    }\r\n    else {\r\n        return value_1(matchValue);\r\n    }\r\n}\r\n\r\nexport function reduce(folder, xs) {\r\n    const e = ofSeq(xs);\r\n    try {\r\n        const loop = (acc_mut) => {\r\n            loop:\r\n            while (true) {\r\n                const acc = acc_mut;\r\n                if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                    acc_mut = folder(acc, e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n                    continue loop;\r\n                }\r\n                else {\r\n                    return acc;\r\n                }\r\n                break;\r\n            }\r\n        };\r\n        if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            return loop(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        else {\r\n            throw (new Error(SR_inputSequenceEmpty));\r\n        }\r\n    }\r\n    finally {\r\n        disposeSafe(e);\r\n    }\r\n}\r\n\r\nexport function reduceBack(folder, xs) {\r\n    const arr = toArray(xs);\r\n    if (arr.length > 0) {\r\n        return arr.reduceRight(folder);\r\n    }\r\n    else {\r\n        throw (new Error(SR_inputSequenceEmpty));\r\n    }\r\n}\r\n\r\nexport function replicate(n, x) {\r\n    return initialize(n, (_arg1) => x);\r\n}\r\n\r\nexport function reverse(xs) {\r\n    return delay(() => ofArray(reverse_1(toArray(xs))));\r\n}\r\n\r\nexport function scan(folder, state, xs) {\r\n    return delay(() => {\r\n        let acc = state;\r\n        return concat([singleton(state), map((x) => {\r\n            acc = folder(acc, x);\r\n            return acc;\r\n        }, xs)]);\r\n    });\r\n}\r\n\r\nexport function scanBack(folder, xs, state) {\r\n    return delay(() => ofArray(scanBack_1(folder, toArray(xs), state)));\r\n}\r\n\r\nexport function skip(count, source) {\r\n    return mkSeq(() => {\r\n        const e = ofSeq(source);\r\n        try {\r\n            for (let _ = 1; _ <= count; _++) {\r\n                if (!e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                    throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"source\"));\r\n                }\r\n            }\r\n            return Enumerator_enumerateThenFinally(() => {\r\n            }, e);\r\n        }\r\n        catch (matchValue) {\r\n            disposeSafe(e);\r\n            throw matchValue;\r\n        }\r\n    });\r\n}\r\n\r\nexport function skipWhile(predicate, xs) {\r\n    return delay(() => {\r\n        let skipped = true;\r\n        return filter((x) => {\r\n            if (skipped) {\r\n                skipped = predicate(x);\r\n            }\r\n            return !skipped;\r\n        }, xs);\r\n    });\r\n}\r\n\r\nexport function tail(xs) {\r\n    return skip(1, xs);\r\n}\r\n\r\nexport function take(count, xs) {\r\n    return generateIndexed(() => ofSeq(xs), (i, e) => {\r\n        if (i < count) {\r\n            if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                return some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n            }\r\n            else {\r\n                throw (new Error((SR_notEnoughElements + \"\\\\nParameter name: \") + \"source\"));\r\n            }\r\n        }\r\n        else {\r\n            return void 0;\r\n        }\r\n    }, (e_1) => {\r\n        disposeSafe(e_1);\r\n    });\r\n}\r\n\r\nexport function takeWhile(predicate, xs) {\r\n    return generate(() => ofSeq(xs), (e) => ((e[\"System.Collections.IEnumerator.MoveNext\"]() && predicate(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]())) ? some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) : (void 0)), (e_1) => {\r\n        disposeSafe(e_1);\r\n    });\r\n}\r\n\r\nexport function truncate(count, xs) {\r\n    return generateIndexed(() => ofSeq(xs), (i, e) => (((i < count) && e[\"System.Collections.IEnumerator.MoveNext\"]()) ? some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) : (void 0)), (e_1) => {\r\n        disposeSafe(e_1);\r\n    });\r\n}\r\n\r\nexport function zip(xs, ys) {\r\n    return map2((x, y) => [x, y], xs, ys);\r\n}\r\n\r\nexport function zip3(xs, ys, zs) {\r\n    return map3((x, y, z) => [x, y, z], xs, ys, zs);\r\n}\r\n\r\nexport function collect(mapping, xs) {\r\n    return delay(() => concat(map(mapping, xs)));\r\n}\r\n\r\nexport function where(predicate, xs) {\r\n    return filter(predicate, xs);\r\n}\r\n\r\nexport function pairwise(xs) {\r\n    return delay(() => ofArray(pairwise_1(toArray(xs))));\r\n}\r\n\r\nexport function splitInto(chunks, xs) {\r\n    return delay(() => ofArray(map_1(ofArray, splitInto_1(chunks, toArray(xs)))));\r\n}\r\n\r\nexport function windowed(windowSize, xs) {\r\n    return delay(() => ofArray(map_1(ofArray, windowed_1(windowSize, toArray(xs)))));\r\n}\r\n\r\nexport function transpose(xss) {\r\n    return delay(() => ofArray(map_1(ofArray, transpose_1(map_1(toArray, toArray(xss))))));\r\n}\r\n\r\nexport function sortWith(comparer, xs) {\r\n    return delay(() => {\r\n        const arr = toArray(xs);\r\n        arr.sort(comparer);\r\n        return ofArray(arr);\r\n    });\r\n}\r\n\r\nexport function sort(xs, comparer) {\r\n    return sortWith((x, y) => comparer.Compare(x, y), xs);\r\n}\r\n\r\nexport function sortBy(projection, xs, comparer) {\r\n    return sortWith((x, y) => comparer.Compare(projection(x), projection(y)), xs);\r\n}\r\n\r\nexport function sortDescending(xs, comparer) {\r\n    return sortWith((x, y) => (comparer.Compare(x, y) * -1), xs);\r\n}\r\n\r\nexport function sortByDescending(projection, xs, comparer) {\r\n    return sortWith((x, y) => (comparer.Compare(projection(x), projection(y)) * -1), xs);\r\n}\r\n\r\nexport function sum(xs, adder) {\r\n    return fold((acc, x) => adder.Add(acc, x), adder.GetZero(), xs);\r\n}\r\n\r\nexport function sumBy(f, xs, adder) {\r\n    return fold((acc, x) => adder.Add(acc, f(x)), adder.GetZero(), xs);\r\n}\r\n\r\nexport function maxBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function max(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function minBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function min(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function average(xs, averager) {\r\n    let count = 0;\r\n    const total = fold((acc, x) => {\r\n        count = ((count + 1) | 0);\r\n        return averager.Add(acc, x);\r\n    }, averager.GetZero(), xs);\r\n    if (count === 0) {\r\n        throw (new Error((SR_inputSequenceEmpty + \"\\\\nParameter name: \") + \"source\"));\r\n    }\r\n    else {\r\n        return averager.DivideByInt(total, count);\r\n    }\r\n}\r\n\r\nexport function averageBy(f, xs, averager) {\r\n    let count = 0;\r\n    const total = fold((acc, x) => {\r\n        count = ((count + 1) | 0);\r\n        return averager.Add(acc, f(x));\r\n    }, averager.GetZero(), xs);\r\n    if (count === 0) {\r\n        throw (new Error((SR_inputSequenceEmpty + \"\\\\nParameter name: \") + \"source\"));\r\n    }\r\n    else {\r\n        return averager.DivideByInt(total, count);\r\n    }\r\n}\r\n\r\nexport function permute(f, xs) {\r\n    return delay(() => ofArray(permute_1(f, toArray(xs))));\r\n}\r\n\r\nexport function chunkBySize(chunkSize, xs) {\r\n    return delay(() => ofArray(map_1(ofArray, chunkBySize_1(chunkSize, toArray(xs)))));\r\n}\r\n\r\nexport function insertAt(index, y, xs) {\r\n    let isDone = false;\r\n    if (index < 0) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    return generateIndexed(() => ofSeq(xs), (i, e) => {\r\n        if ((isDone ? true : (i < index)) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            return some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        else if (i === index) {\r\n            isDone = true;\r\n            return some(y);\r\n        }\r\n        else {\r\n            if (!isDone) {\r\n                throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n            }\r\n            return void 0;\r\n        }\r\n    }, (e_1) => {\r\n        disposeSafe(e_1);\r\n    });\r\n}\r\n\r\nexport function insertManyAt(index, ys, xs) {\r\n    let status = -1;\r\n    if (index < 0) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    return generateIndexed(() => [ofSeq(xs), ofSeq(ys)], (i, tupledArg) => {\r\n        const e1 = tupledArg[0];\r\n        const e2 = tupledArg[1];\r\n        if (i === index) {\r\n            status = 0;\r\n        }\r\n        let inserted;\r\n        if (status === 0) {\r\n            if (e2[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                inserted = some(e2[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n            }\r\n            else {\r\n                status = 1;\r\n                inserted = (void 0);\r\n            }\r\n        }\r\n        else {\r\n            inserted = (void 0);\r\n        }\r\n        if (inserted == null) {\r\n            if (e1[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                return some(e1[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n            }\r\n            else {\r\n                if (status < 1) {\r\n                    throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n                }\r\n                return void 0;\r\n            }\r\n        }\r\n        else {\r\n            return some(value_1(inserted));\r\n        }\r\n    }, (tupledArg_1) => {\r\n        disposeSafe(tupledArg_1[0]);\r\n        disposeSafe(tupledArg_1[1]);\r\n    });\r\n}\r\n\r\nexport function removeAt(index, xs) {\r\n    let isDone = false;\r\n    if (index < 0) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    return generateIndexed(() => ofSeq(xs), (i, e) => {\r\n        if ((isDone ? true : (i < index)) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            return some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        else if ((i === index) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            isDone = true;\r\n            return e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) : (void 0);\r\n        }\r\n        else {\r\n            if (!isDone) {\r\n                throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n            }\r\n            return void 0;\r\n        }\r\n    }, (e_1) => {\r\n        disposeSafe(e_1);\r\n    });\r\n}\r\n\r\nexport function removeManyAt(index, count, xs) {\r\n    if (index < 0) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    return generateIndexed(() => ofSeq(xs), (i, e) => {\r\n        if (i < index) {\r\n            if (e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                return some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n            }\r\n            else {\r\n                throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n            }\r\n        }\r\n        else {\r\n            if (i === index) {\r\n                for (let _ = 1; _ <= count; _++) {\r\n                    if (!e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n                        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"count\"));\r\n                    }\r\n                }\r\n            }\r\n            return e[\"System.Collections.IEnumerator.MoveNext\"]() ? some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]()) : (void 0);\r\n        }\r\n    }, (e_1) => {\r\n        disposeSafe(e_1);\r\n    });\r\n}\r\n\r\nexport function updateAt(index, y, xs) {\r\n    let isDone = false;\r\n    if (index < 0) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    return generateIndexed(() => ofSeq(xs), (i, e) => {\r\n        if ((isDone ? true : (i < index)) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            return some(e[\"System.Collections.Generic.IEnumerator`1.get_Current\"]());\r\n        }\r\n        else if ((i === index) && e[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            isDone = true;\r\n            return some(y);\r\n        }\r\n        else {\r\n            if (!isDone) {\r\n                throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n            }\r\n            return void 0;\r\n        }\r\n    }, (e_1) => {\r\n        disposeSafe(e_1);\r\n    });\r\n}\r\n\r\n","import { disposeSafe, structuralHash, equals } from \"./Util.js\";\r\nimport { HashIdentity_Structural, ComparisonIdentity_Structural } from \"./FSharp.Collections.js\";\r\nimport { StringBuilder__Append_Z721C83C5 } from \"./System.Text.js\";\r\n\r\nexport const LanguagePrimitives_GenericEqualityComparer = {\r\n    [\"System.Collections.IEqualityComparer.Equals541DA560\"](x, y) {\r\n        return equals(x, y);\r\n    },\r\n    [\"System.Collections.IEqualityComparer.GetHashCode4E60E31B\"](x_1) {\r\n        return structuralHash(x_1);\r\n    },\r\n};\r\n\r\nexport const LanguagePrimitives_GenericEqualityERComparer = {\r\n    [\"System.Collections.IEqualityComparer.Equals541DA560\"](x, y) {\r\n        return equals(x, y);\r\n    },\r\n    [\"System.Collections.IEqualityComparer.GetHashCode4E60E31B\"](x_1) {\r\n        return structuralHash(x_1);\r\n    },\r\n};\r\n\r\nexport function LanguagePrimitives_FastGenericComparer() {\r\n    return ComparisonIdentity_Structural();\r\n}\r\n\r\nexport function LanguagePrimitives_FastGenericComparerFromTable() {\r\n    return ComparisonIdentity_Structural();\r\n}\r\n\r\nexport function LanguagePrimitives_FastGenericEqualityComparer() {\r\n    return HashIdentity_Structural();\r\n}\r\n\r\nexport function LanguagePrimitives_FastGenericEqualityComparerFromTable() {\r\n    return HashIdentity_Structural();\r\n}\r\n\r\nexport function Operators_Failure(message) {\r\n    return new Error(message);\r\n}\r\n\r\nexport function Operators_FailurePattern(exn) {\r\n    return exn.message;\r\n}\r\n\r\nexport function Operators_NullArg(x) {\r\n    throw (new Error(x));\r\n}\r\n\r\nexport function Operators_Using(resource, action) {\r\n    try {\r\n        return action(resource);\r\n    }\r\n    finally {\r\n        if (equals(resource, null)) {\r\n        }\r\n        else {\r\n            disposeSafe(resource);\r\n        }\r\n    }\r\n}\r\n\r\nexport function Operators_Lock(_lockObj, action) {\r\n    return action();\r\n}\r\n\r\nexport function ExtraTopLevelOperators_LazyPattern(input) {\r\n    return input.Value;\r\n}\r\n\r\nexport function PrintfModule_PrintFormatToStringBuilderThen(continuation, builder, format) {\r\n    return format.cont((s) => {\r\n        StringBuilder__Append_Z721C83C5(builder, s);\r\n        return continuation();\r\n    });\r\n}\r\n\r\nexport function PrintfModule_PrintFormatToStringBuilder(builder, format) {\r\n    return PrintfModule_PrintFormatToStringBuilderThen(() => {\r\n    }, builder, format);\r\n}\r\n\r\n","import { compare } from \"./Util.js\";\r\nimport { unfold, delay } from \"./Seq.js\";\r\nimport { op_Addition, fromZero } from \"./BigInt.js\";\r\nimport { op_Addition as op_Addition_1, fromParts } from \"./Decimal.js\";\r\nimport { op_Addition as op_Addition_2, fromBits } from \"./Long.js\";\r\n\r\nexport function makeRangeStepFunction(step, stop, zero, add) {\r\n    const stepComparedWithZero = compare(step, zero) | 0;\r\n    if (stepComparedWithZero === 0) {\r\n        throw (new Error(\"The step of a range cannot be zero\"));\r\n    }\r\n    const stepGreaterThanZero = stepComparedWithZero > 0;\r\n    return (x) => {\r\n        const comparedWithLast = compare(x, stop) | 0;\r\n        return ((stepGreaterThanZero && (comparedWithLast <= 0)) ? true : ((!stepGreaterThanZero) && (comparedWithLast >= 0))) ? [x, add(x, step)] : (void 0);\r\n    };\r\n}\r\n\r\nexport function integralRangeStep(start, step, stop, zero, add) {\r\n    const stepFn = makeRangeStepFunction(step, stop, zero, add);\r\n    return delay(() => unfold(stepFn, start));\r\n}\r\n\r\nexport function rangeBigInt(start, step, stop) {\r\n    return integralRangeStep(start, step, stop, fromZero(), op_Addition);\r\n}\r\n\r\nexport function rangeDecimal(start, step, stop) {\r\n    return integralRangeStep(start, step, stop, fromParts(0, 0, 0, false, 0), op_Addition_1);\r\n}\r\n\r\nexport function rangeDouble(start, step, stop) {\r\n    return integralRangeStep(start, step, stop, 0, (x, y) => (x + y));\r\n}\r\n\r\nexport function rangeInt64(start, step, stop) {\r\n    return integralRangeStep(start, step, stop, fromBits(0, 0, false), op_Addition_2);\r\n}\r\n\r\nexport function rangeUInt64(start, step, stop) {\r\n    return integralRangeStep(start, step, stop, fromBits(0, 0, true), op_Addition_2);\r\n}\r\n\r\nexport function rangeChar(start, stop) {\r\n    const intStop = stop.charCodeAt(0) | 0;\r\n    return delay(() => unfold((c) => {\r\n        if (c <= intStop) {\r\n            return [String.fromCharCode(c), c + 1];\r\n        }\r\n        else {\r\n            return void 0;\r\n        }\r\n    }, start.charCodeAt(0)));\r\n}\r\n\r\n","namespace Elmish\nopen System\n\n[<Struct>]\ntype internal RingState<'item> =\n    | Writable of wx:'item array * ix:int\n    | ReadWritable of rw:'item array * wix:int * rix:int\n\ntype internal RingBuffer<'item>(size) =\n    let doubleSize ix (items: 'item array) =\n        seq { yield! items |> Seq.skip ix\n              yield! items |> Seq.take ix\n              for _ in 0..items.Length do\n                yield Unchecked.defaultof<'item> }\n        |> Array.ofSeq\n\n    let mutable state : 'item RingState =\n        Writable (Array.zeroCreate (max size 10), 0)\n\n    member __.Pop() =\n        match state with\n        | ReadWritable (items, wix, rix) ->\n            let rix' = (rix + 1) % items.Length\n            match rix' = wix with\n            | true -> \n                state <- Writable(items, wix)\n            | _ ->\n                state <- ReadWritable(items, wix, rix')\n            Some items.[rix]\n        | _ ->\n            None\n\n    member __.Push (item:'item) =\n        match state with\n        | Writable (items, ix) ->\n            items.[ix] <- item\n            let wix = (ix + 1) % items.Length\n            state <- ReadWritable(items, wix, ix)\n        | ReadWritable (items, wix, rix) ->\n            items.[wix] <- item\n            let wix' = (wix + 1) % items.Length\n            match wix' = rix with\n            | true -> \n                state <- ReadWritable(items |> doubleSize rix, items.Length, 0)\n            | _ -> \n                state <- ReadWritable(items, wix', rix)","namespace Elmish.React\n\nopen Fable.React\nopen Elmish\n\ntype LazyProps<'model> = {\n    model:'model\n    render:unit->ReactElement\n    equal:'model->'model->bool\n}\n\nmodule Components =\n    type LazyView<'model>(props) =\n        inherit Component<LazyProps<'model>,obj>(props)\n\n        override this.shouldComponentUpdate(nextProps, _nextState) =\n            not <| this.props.equal this.props.model nextProps.model\n\n        override this.render () =\n            this.props.render ()\n\n[<AutoOpen>]\nmodule Common =\n    /// Avoid rendering the view unless the model has changed.\n    /// equal: function to compare the previous and the new states\n    /// view: function to render the model\n    /// state: new state to render\n    let lazyViewWith (equal:'model->'model->bool)\n                     (view:'model->ReactElement)\n                     (state:'model) =\n        ofType<Components.LazyView<_>,_,_>\n            { render = fun () -> view state\n              equal = equal\n              model = state }\n            []\n\n    /// Avoid rendering the view unless the model has changed.\n    /// equal: function to compare the previous and the new states\n    /// view: function to render the model using the dispatch\n    /// state: new state to render\n    /// dispatch: dispatch function\n    let lazyView2With (equal:'model->'model->bool)\n                      (view:'model->'msg Dispatch->ReactElement)\n                      (state:'model)\n                      (dispatch:'msg Dispatch) =\n        ofType<Components.LazyView<_>,_,_>\n            { render = fun () -> view state dispatch\n              equal = equal\n              model = state }\n            []\n\n    /// Avoid rendering the view unless the model has changed.\n    /// equal: function to compare the previous and the new model (a tuple of two states)\n    /// view: function to render the model using the dispatch\n    /// state1: new state to render\n    /// state2: new state to render\n    /// dispatch: dispatch function\n    let lazyView3With (equal:_->_->bool) (view:_->_->_->ReactElement) state1 state2 (dispatch:'msg Dispatch) =\n        ofType<Components.LazyView<_>,_,_>\n            { render = fun () -> view state1 state2 dispatch\n              equal = equal\n              model = (state1,state2) }\n            []\n\n    /// Avoid rendering the view unless the model has changed.\n    /// view: function of model to render the view\n    let lazyView (view:'model->ReactElement) =\n        lazyViewWith (=) view\n\n    /// Avoid rendering the view unless the model has changed.\n    /// view: function of two arguments to render the model using the dispatch\n    let lazyView2 (view:'model->'msg Dispatch->ReactElement) =\n        lazyView2With (=) view\n\n    /// Avoid rendering the view unless the model has changed.\n    /// view: function of three arguments to render the model using the dispatch\n    let lazyView3 (view:_->_->_->ReactElement) =\n        lazyView3With (=) view\n\n\n","﻿namespace CineMol.Types\r\n\r\nopen System\r\nopen CineMol.Helpers\r\n    \r\n/// <summary>\r\n/// Color describes a color in RGB int values or Hex string.\r\n/// </summary>\r\ntype Color = Color of int * int * int\r\n    with\r\n    override this.ToString () =\r\n        let (Color (r, g, b)) = this \r\n        $\"rgb(%i{r},%i{g},%i{b})\"\r\n    \r\n    member this.ToHex =\r\n        let (Color (r, g, b)) = this\r\n        $\"#{r:x2}{g:x2}{b:x2}\"\r\n\r\n    member this.Diffuse alpha =\r\n        let alpha = clamp 0.0 1.0 alpha\r\n        let (Color (r, g, b)) = this\r\n        let diffuseChannel c = (float c) * alpha |> int\r\n        ( diffuseChannel r,\r\n          diffuseChannel g,\r\n          diffuseChannel b ) |> Color\r\n        \r\n/// <summary>\r\n/// Model styles.\r\n/// </summary>\r\ntype ModelStyle =\r\n    | SpaceFilling\r\n    | BallAndStick\r\n    | WireFrame\r\n    \r\n/// <summary>\r\n/// Art styles.\r\n/// </summary>\r\ntype ArtStyle =\r\n    | Cartoon\r\n    | Glossy \r\n\r\nmodule Geometry =\r\n\r\n    /// <summary>\r\n    /// Point2D resembles a point in two-dimensional Euclidean space.\r\n    /// </summary>\r\n    type Point2D = { X: float; Y: float }\r\n        with\r\n        static member (+) (p1, p2) = { X = p1.X + p2.X; Y = p1.Y + p2.Y }\r\n        \r\n        static member (-) (p1, p2) = { X = p1.X - p2.X; Y = p1.Y - p2.Y }\r\n        \r\n        static member (*) (p1, p2) = { X = p1.X * p2.X; Y = p1.Y * p2.Y }\r\n        \r\n        member this.Add v = { X = this.X + v; Y = this.Y + v }\r\n        \r\n        member this.Mul v = { X = this.X * v; Y = this.X * v }\r\n        \r\n        member this.Div v = { X = this.X / v; Y = this.Y / v }\r\n        \r\n        member this.Pow v = { X = this.X ** v; Y = this.Y ** v }\r\n        \r\n        member this.Sum () = this.X + this.Y\r\n        \r\n        member this.Dist other = ((this - other).Pow 2.0).Sum() |> Math.Sqrt\r\n        \r\n        member this.Midpoint other = (this + other).Div 2.0\r\n        \r\n        member this.CreateVector (other: Point2D) : Vector2D = { X = other.X - this.X; Y = other.Y - this.Y }\r\n\r\n        static member Centroid (ps: Point2D list) =\r\n            ps |> List.fold (fun pSum p -> pSum + p) { X = 0.0; Y = 0.0 } |> (fun p -> p.Div (float ps.Length))\r\n            \r\n    and Vector2D = { X: float; Y: float }\r\n        with\r\n        member this.Cross (other: Vector2D) = this.X * other.Y - this.Y * other.X\r\n        \r\n    /// <summary>\r\n    /// Point3D resembles a point in three-dimensional Euclidean space.\r\n    /// </summary>\r\n    and Point3D = { X: float; Y: float; Z: float }\r\n        with\r\n        static member (+) (p1, p2) = { X = p1.X + p2.X; Y = p1.Y + p2.Y; Z = p1.Z + p2.Z }\r\n        \r\n        static member (-) (p1, p2) = { X = p1.X - p2.X; Y = p1.Y - p2.Y; Z = p1.Z - p2.Z }\r\n        \r\n        static member (*) (p1, p2) = { X = p1.X * p2.X; Y = p1.Y * p2.Y; Z = p1.Z * p2.Z }\r\n        \r\n        member this.Add v = { X = this.X + v; Y = this.Y + v; Z = this.Z + v }\r\n        \r\n        member this.Mul v = { X = this.X * v; Y = this.Y * v; Z = this.Z * v }\r\n        \r\n        member this.Div v = { X = this.X / v; Y = this.Y / v; Z = this.Z / v }\r\n        \r\n        member this.Pow v = { X = this.X ** v; Y = this.Y ** v; Z = this.Z ** v }\r\n        \r\n        member this.Sum () = this.X + this.Y + this.Z\r\n        \r\n        member this.Dist other = ((this - other).Pow 2.0).Sum() |> Math.Sqrt\r\n        \r\n        member this.Midpoint other = (this + other).Div 2.0\r\n        \r\n        member this.VectorTo other : Vector3D = { X = other.X - this.X; Y = other.Y - this.Y; Z = other.Z - this.Z }\r\n        \r\n        member this.MoveTowards other (distance: float) =\r\n            let dist = this.Dist other\r\n            let vector = this.VectorTo other\r\n            match dist - distance with\r\n            | newDist when newDist <= 0.0 -> other\r\n            | newDist ->\r\n                let norm = vector.Normalize ()\r\n                this + { X = norm.X * newDist; Y = norm.Y * newDist; Z = norm.Z * newDist }\r\n            \r\n        member p.Rotate axis rad =\r\n            match axis with\r\n            | X ->\r\n               { X = p.X\r\n                 Y = p.Y * Math.Cos(rad) - p.Z * Math.Sin(rad)\r\n                 Z = p.Y * Math.Sin(rad) + p.Z * Math.Cos(rad) }\r\n            | Y ->\r\n               { X = p.X * Math.Cos(rad) + p.Z * Math.Sin(rad)\r\n                 Y = p.Y\r\n                 Z = p.Z * Math.Cos(rad) - p.X * Math.Sin(rad) }\r\n            | Z ->\r\n               { X = p.X * Math.Cos(rad) - p.Y * Math.Sin(rad)\r\n                 Y = p.X * Math.Sin(rad) + p.Y * Math.Cos(rad)\r\n                 Z = p.Z }\r\n               \r\n        member this.ToPoint2D () = { X = this.X; Y = this.Y }\r\n        \r\n        static member Centroid (ps: Point3D list) =\r\n            ps |> List.fold (fun pSum p -> pSum + p) { X = 0.0; Y = 0.0; Z = 0.0 } |> (fun p -> p.Div (float ps.Length))\r\n    \r\n    and Vector3D = { X: float; Y: float; Z: float }\r\n        with\r\n        member this.Normalize () =\r\n            let length = Math.Sqrt (this.X * this.X + this.Y * this.Y + this.Z * this.Z)\r\n            { X = this.X / length; Y = this.Y / length; Z = this.Z / length }\r\n    \r\n    /// <summary>\r\n    /// Axis describes a plane in a three-dimensional Euclidean space.\r\n    /// </summary>\r\n    and Axis = | X | Y | Z\r\n        with\r\n        static member Origin () : Point3D = { X = 0.0; Y = 0.0; Z = 0.0 }\r\n    \r\n    /// <summary>\r\n    /// Definition for a circle in two-dimensional Euclidean space.\r\n    /// </summary>\r\n    and Circle =\r\n        { Center : Point2D\r\n          Radius : float }\r\n    \r\n    /// <summary>\r\n    /// Definition for a sphere.\r\n    /// </summary>\r\n    and Sphere =\r\n        { Center: Point3D\r\n          Radius : float }\r\n        with\r\n        member this.Encloses (o: Sphere) : bool =\r\n            let dist = this.Center.Dist o.Center\r\n            dist + o.Radius <= this.Radius\r\n            \r\n        member this.Intersects (o: Sphere) : bool =\r\n            let dist = this.Center.Dist o.Center\r\n            dist <= this.Radius + o.Radius\r\n            \r\n        member this.PointsOnSphere (resolution : int) : Point3D list =\r\n            let N = float resolution \r\n            \r\n            // Calculate polar angles.\r\n            let numPointsPhi = N / 2.0 |> int\r\n            let phis =\r\n                [ for i in [ 1 .. 1 .. numPointsPhi ] do\r\n                    yield ((float i) / (( float numPointsPhi) - 1.0)) * Math.PI ]\r\n            \r\n            // Calculate azimuthal angles.\r\n            let numPointsTheta = N / 2.0 |> int\r\n            let thetas =\r\n                [ for i in [ 0 .. 1 .. numPointsTheta ] do\r\n                    yield ((float i) / (float numPointsTheta)) * 2.0 * Math.PI ]\r\n            \r\n            // Calculate points on sphere.\r\n            let points = \r\n                [\r\n                    for phi in phis do\r\n                        \r\n                        // Only calculate points on half of sphere we can see over the z-axis.\r\n                        let z = this.Center.Z + this.Radius * Math.Cos(phi)\r\n                        match z with\r\n                        | z when z < this.Center.Z -> () // We can never see this part of the sphere.\r\n                        | _ ->\r\n                            // let points : Point3D list =\r\n                            //     [\r\n                            //         for theta in thetas do\r\n                            //             let x = this.Center.X + this.Radius * Math.Sin(phi) * Math.Cos(theta)\r\n                            //             let y = this.Center.Y + this.Radius * Math.Sin(phi) * Math.Sin(theta)\r\n                            //             yield { X = x; Y = y; Z = z } \r\n                            //     ]\r\n                            //     |> List.rev // Point furthest away from us first.\r\n                            //\r\n                            // match points with\r\n                            // | [] -> ()\r\n                            // | _ -> yield points\r\n                            \r\n                            for theta in thetas do \r\n                                let x = this.Center.X + this.Radius * Math.Sin(phi) * Math.Cos(theta)\r\n                                let y = this.Center.Y + this.Radius * Math.Sin(phi) * Math.Sin(theta)\r\n                                let point : Point3D = { X = x; Y = y; Z = z }\r\n                                yield point \r\n                ]\r\n                \r\n            // Transpose the list of lists.\r\n            // quadrants |> List.transpose\r\n            \r\n            points\r\n            \r\n    /// <summary>\r\n    /// Definition for a cylinder.\r\n    /// </summary>\r\n    type Cylinder =\r\n        { Start : Point3D\r\n          End : Point3D\r\n          Radius : float }\r\n        with\r\n        member this.IsInside (point: Point3D) : bool =\r\n            let cylinderDirection = this.End - this.Start\r\n            let pointToStart = point - this.Start\r\n            let projection =\r\n                let nominator = pointToStart |> fun p -> p.X * cylinderDirection.X + p.Y * cylinderDirection.Y + p.Z * cylinderDirection.Z\r\n                let denominator = cylinderDirection |> fun c -> c.X * c.X + c.Y * c.Y + c.Z * c.Z\r\n                nominator / denominator\r\n                \r\n            if projection < 0.0 then false // The point is behind the cylinder's start point\r\n            elif projection > 1.0 then false // The point is beyond the cylinder's end point\r\n            else\r\n                let closestPointOnAxis = this.Start.Add(projection) * cylinderDirection\r\n                let distanceSquared = (point - closestPointOnAxis) |> fun d -> d.X * d.X + d.Y * d.Y + d.Z * d.Z\r\n                let radiusSquared = this.Radius * this.Radius\r\n                distanceSquared <= radiusSquared\r\n                \r\n        member this.PointsOnCylinder (resolution : int) : Point3D list =\r\n            let N = resolution\r\n            \r\n            let latitudeDivisions = N / 2\r\n            let longitudeDivisions = N\r\n            \r\n            [\r\n                for lat = 0 to latitudeDivisions do\r\n                    let theta = float lat * Math.PI / float latitudeDivisions\r\n                    let sinTheta = sin theta\r\n                    let cosTheta = cos theta\r\n\r\n                    for lon = 0 to longitudeDivisions do\r\n                        let phi = float lon * 2.0 * Math.PI / float longitudeDivisions\r\n                        let sinPhi = sin phi\r\n                        let cosPhi = cos phi\r\n\r\n                        let x = this.Radius * sinTheta * cosPhi\r\n                        let y = this.Radius * sinTheta * sinPhi\r\n                        let z = this.Radius * cosTheta\r\n\r\n                        let point : Point3D = { X = x; Y = y; Z = z }\r\n                        yield point \r\n            ]\r\n            \r\n    /// <summary>\r\n    /// Calculate the centroid of a list of points.\r\n    /// </summary>\r\n    let calcCentroid (points : Point2D list) : Point2D =\r\n        let start : Point2D = { X = 0.0; Y = 0.0 }\r\n        let sum = points |> List.fold (fun pSum p -> pSum + p) start\r\n        let count = float points.Length\r\n        sum.Div count \r\n\r\nmodule Chem =\r\n\r\n    open Geometry\r\n    \r\n    /// <summary>\r\n    /// AtomType describes the atomic number of an atom.\r\n    /// </summary>\r\n    type AtomType =\r\n        | H                                                                                  | He\r\n        | Li | Be                                                   | B  | C  | N  | O  | F  | Ne\r\n        | Na | Mg                                                   | Al | Si | P  | S  | Cl | Ar\r\n        | K  | Ca | Sc | Ti | V  | Cr | Mn | Fe | Co | Ni | Cu | Zn | Ga | Ge | As | Se | Br | Kr\r\n        | Rb | Sr | Y  | Zr | Nb | Mo | Tc | Ru | Rh | Pd | Ag | Cd | In | Sn | Sb | Te | I  | Xe\r\n        | Cs | Ba | Lu | Hf | Ta | W  | Re | Os | Ir | Pt | Au | Hg | Tl | Pb | Bi | Po | At | Rn\r\n        | Fr | Ra\r\n        with\r\n        static member FromString (atomString: string) =\r\n            match atomString with\r\n            | \"H\"  -> Some H  | \"He\" -> Some He | \"Li\" -> Some Li | \"Be\" -> Some Be | \"B\"  -> Some B \r\n            | \"C\"  -> Some C  | \"N\"  -> Some N  | \"O\"  -> Some O  | \"F\"  -> Some F  | \"Ne\" -> Some Ne\r\n            | \"Na\" -> Some Na | \"Mg\" -> Some Mg | \"Al\" -> Some Al | \"Si\" -> Some Si | \"P\"  -> Some P\r\n            | \"S\"  -> Some S  | \"Cl\" -> Some Cl | \"Ar\" -> Some Ar | \"K\"  -> Some K  | \"Ca\" -> Some Ca\r\n            | \"Sc\" -> Some Sc | \"Ti\" -> Some Ti | \"V\"  -> Some V  | \"Cr\" -> Some Cr | \"Mn\" -> Some Mn\r\n            | \"Fe\" -> Some Fe | \"Co\" -> Some Co | \"Ni\" -> Some Ni | \"Cu\" -> Some Cu | \"Zn\" -> Some Zn\r\n            | \"Ga\" -> Some Ga | \"Ge\" -> Some Ge | \"As\" -> Some As | \"Se\" -> Some Se | \"Br\" -> Some Br\r\n            | \"Kr\" -> Some Kr | \"Rb\" -> Some Rb | \"Sr\" -> Some Sr | \"Y\"  -> Some Y  | \"Zr\" -> Some Zr\r\n            | \"Nb\" -> Some Nb | \"Mo\" -> Some Mo | \"Tc\" -> Some Tc | \"Ru\" -> Some Ru | \"Rh\" -> Some Rh\r\n            | \"Pd\" -> Some Pd | \"Ag\" -> Some Ag | \"Cd\" -> Some Cd | \"In\" -> Some In | \"Sn\" -> Some Sn\r\n            | \"Sb\" -> Some Sb | \"Te\" -> Some Te | \"I\"  -> Some I  | \"Xe\" -> Some Xe | \"Cs\" -> Some Cs\r\n            | \"Ba\" -> Some Ba | \"Lu\" -> Some Lu | \"Hf\" -> Some Hf | \"Ta\" -> Some Ta | \"W\"  -> Some W\r\n            | \"Re\" -> Some Re | \"Os\" -> Some Os | \"Ir\" -> Some Ir | \"Pt\" -> Some Pt | \"Au\" -> Some Au\r\n            | \"Hg\" -> Some Hg | \"Tl\" -> Some Tl | \"Pb\" -> Some Pb | \"Bi\" -> Some Bi | \"Po\" -> Some Po\r\n            | \"At\" -> Some At | \"Rn\" -> Some Rn | \"Fr\" -> Some Fr | \"Ra\" -> Some Ra | _    -> None \r\n    \r\n    /// <summary>\r\n    /// BondType describes the type of bond between two atoms.\r\n    /// </summary>\r\n    type BondType = | Single | Double | Triple | Aromatic\r\n        with \r\n        static member FromString (bondString: string) =\r\n            match bondString with\r\n            | \"1\" | \"SINGLE\"   | \"Single\"   -> Some Single\r\n            | \"2\" | \"DOUBLE\"   | \"Double\"   -> Some Double\r\n            | \"3\" | \"TRIPLE\"   | \"Triple\"   -> Some Triple\r\n            | \"4\" | \"AROMATIC\" | \"Aromatic\" -> Some Aromatic\r\n            | _                             -> None \r\n\r\n    /// <summary>\r\n    /// Atom3D describes an atom in three-dimensional Euclidean space.\r\n    /// </summary>\r\n    type Atom =\r\n        { Index : int\r\n          Type : AtomType\r\n          Color : Color\r\n          Opacity : float \r\n          Position : Point3D\r\n          Radius : float }\r\n    \r\n    /// <summary>\r\n    /// Bond describes a bond between two Atoms in two-dimensional or three-dimensional Euclidean space.\r\n    /// </summary>\r\n    type Bond =\r\n        { BeginIndex : int\r\n          EndIndex : int \r\n          Type : BondType\r\n          BeginAtomIndex : int\r\n          EndAtomIndex : int\r\n          Opacity : float option \r\n          Color : Color option\r\n          Radius : float }\r\n    \r\n    /// <summary>\r\n    /// Molecule describes a molecule, which contains of Atoms and Bonds.\r\n    /// </summary>\r\n    type Molecule = { Atoms: Atom list; Bonds: Bond list }\r\n        with\r\n        member this.AdjustForCentroid () =\r\n            let centroid = this.Atoms |> List.map (fun atom -> atom.Position) |> Point3D.Centroid\r\n            let adjustedAtoms = this.Atoms |> List.map (fun atom -> { atom with Position = atom.Position - centroid })\r\n            { this with Atoms = adjustedAtoms }\r\n            \r\n        member this.GetAtom (atomIndex: int) : Atom option =\r\n            try this.Atoms |> List.find (fun atom -> atom.Index = atomIndex) |> Some \r\n            with _ -> None\r\n            \r\n        member this.GetBonds (includeHydrogenAtoms : bool) (atomIndex: int) : Bond list =\r\n            this.Bonds\r\n            |> List.filter (fun bond -> bond.BeginAtomIndex = atomIndex || bond.EndAtomIndex = atomIndex)\r\n            |> List.filter (fun bond ->\r\n                let beginAtom = this.GetAtom bond.BeginAtomIndex\r\n                let endAtom = this.GetAtom bond.EndAtomIndex\r\n                match beginAtom, endAtom with\r\n                | Some beginAtom, Some endAtom ->\r\n                    if includeHydrogenAtoms then true\r\n                    else beginAtom.Type <> H && endAtom.Type <> H\r\n                | _ -> false)\r\n\r\nmodule Svg =\r\n    \r\n    open Geometry\r\n    \r\n    /// <summary>\r\n    /// ViewBox defines the boundaries of the SVG view box.\r\n    /// </summary>\r\n    type ViewBox = { MinX: float; MinY: float; Width: float; Height: float }\r\n        with\r\n        override this.ToString () =\r\n            $\"viewBox=\\\"%.3f{this.MinX} %.3f{this.MinY} %.3f{this.Width} %.3f{this.Height}\\\"\"\r\n\r\n    /// <summary>\r\n    /// SVG fills.\r\n    /// </summary>\r\n    type Fill =\r\n        | RadialGradient of int * Point2D * float * Color\r\n        | LinearGradient of int * Point2D * Point2D * Color\r\n        with\r\n        override this.ToString () =\r\n            match this with\r\n            | LinearGradient (index, start, stop, color) ->\r\n                let x1 = start.X\r\n                let y1 = start.Y\r\n                let x2 = stop.X\r\n                let y2 = stop.Y\r\n                let startColor = color\r\n                let stopColor = color.Diffuse 0.5\r\n                $\"<linearGradient id=\\\"item-{index}\\\" x1=\\\"%.3f{x1}\\\" x2=\\\"%.3f{x2}\\\" y1=\\\"%.3f{y1}\\\" y2=\\\"%.3f{y2}\\\" gradientUnits=\\\"userSpaceOnUse\\\" spreadMethod=\\\"reflect\\\"><stop offset=\\\"0.00\\\" stop-color=\\\"{startColor}\\\"/><stop offset=\\\"1.00\\\" stop-color=\\\"{stopColor}\\\"/></linearGradient>\"\r\n            \r\n            | RadialGradient (index, center, radius, color) ->\r\n                let cx = center.X\r\n                let cy = center.Y\r\n                let r = radius * 1.5 // Make the gradient a bit larger than the object.\r\n                let startColor = color \r\n                let stopColor = color.Diffuse 0.5\r\n                $\"<radialGradient id=\\\"item-{index}\\\" cx=\\\"%.3f{cx}\\\" cy=\\\"%.3f{cy}\\\" r=\\\"%.3f{r}\\\" fx=\\\"%.3f{cx}\\\" fy=\\\"%.3f{cy}\\\" gradientTransform=\\\"matrix(1,0,0,1,0,0)\\\" gradientUnits=\\\"userSpaceOnUse\\\"><stop offset=\\\"0.00\\\" stop-color=\\\"{startColor}\\\"/><stop offset=\\\"1.00\\\" stop-color=\\\"{stopColor}\\\"/></radialGradient>\"\r\n    \r\n    /// <summary>\r\n    /// Shape is a collection of supported shapes to draw in two-dimensional Euclidean space as SVG XML objects.\r\n    /// </summary>\r\n    type Shape =\r\n        | Circle of int * Color * Circle * float \r\n        | Polygon of int * Color * Point2D list * float \r\n        | BondPolygon of int * Color * Point2D * Point2D * Point2D * Point2D * float // Bonds have a different gradient fill for Glossy style.\r\n        | Line of int * Color * Point2D * Point2D * float \r\n        with\r\n        member this.ToSvg (style : ArtStyle) =\r\n            match this with \r\n            | Circle (index, color, circle, opacity) -> \r\n                let x = circle.Center.X\r\n                let y = circle.Center.Y\r\n                \r\n                match style with\r\n                | Cartoon ->\r\n                    $\"<circle cx=\\\"%.3f{x}\\\" cy=\\\"%.3f{y}\\\" r=\\\"%.3f{circle.Radius}\\\" fill=\\\"{color}\\\" style=\\\"stroke:black;stroke-width:0.05\\\" fill-opacity=\\\"{opacity}\\\" stroke-opacity=\\\"{opacity}\\\"/>\"\r\n                \r\n                | Glossy ->\r\n                    $\"<circle class=\\\"item-{index}\\\" cx=\\\"%.3f{x}\\\" cy=\\\"%.3f{y}\\\" r=\\\"%.3f{circle.Radius}\\\" fill-opacity=\\\"{opacity}\\\"/>\"\r\n                \r\n            | Polygon (index, color, points, opacity) ->\r\n                let pointsStr = points |> List.map (fun p -> $\"%.3f{p.X},%.3f{p.Y}\") |> String.concat \" \"\r\n                \r\n                match style with\r\n                | Cartoon -> \r\n                    $\"<polygon points=\\\"{pointsStr}\\\" fill=\\\"{color}\\\" style=\\\"stroke:black;stroke-width:0.05\\\" stroke-linejoin=\\\"round\\\" fill-opacity=\\\"{opacity}\\\" stroke-opacity=\\\"{opacity}\\\"/>\"\r\n                    \r\n                | Glossy ->\r\n                    $\"<polygon class=\\\"item-{index}\\\" points=\\\"{pointsStr}\\\" fill-opacity=\\\"{opacity}\\\"/>\"\r\n                    \r\n            | BondPolygon (index, color, p1, p2, p3, p4, opacity) -> \r\n                let r1 = (p1.Dist p2) / 2.0\r\n                let r2 = (p3.Dist p4) / 2.0\r\n                \r\n                let path = $\"M %.3f{p1.X} %.3f{p1.Y} A %.3f{r1} %.3f{r1} 0 0 1 %.3f{p2.X} %.3f{p2.Y} L %.3f{p3.X} %.3f{p3.Y} A %.3f{r2} %.3f{r2} 0 0 1 %.3f{p4.X} %.3f{p4.Y} Z\"\r\n                \r\n                match style with\r\n                | Cartoon ->\r\n                    $\"<path d=\\\"{path}\\\" fill=\\\"{color}\\\" style=\\\"stroke:black;stroke-width:0.05\\\" stroke-linejoin=\\\"round\\\" fill-opacity=\\\"{opacity}\\\" stroke-opacity=\\\"{opacity}\\\"/>\"\r\n                \r\n                | Glossy ->\r\n                    $\"<path class=\\\"item-{index}\\\" d=\\\"{path}\\\" fill-opacity=\\\"{opacity}\\\"/>\"\r\n            \r\n            | Line (index, color, p1, p2, opacity) ->\r\n                let x1 = p1.X\r\n                let y1 = p1.Y\r\n                let x2 = p2.X\r\n                let y2 = p2.Y\r\n                $\"<line class=\\\"item-{index}\\\" x1=\\\"%.3f{x1}\\\" y1=\\\"%.3f{y1}\\\" x2=\\\"%.3f{x2}\\\" y2=\\\"%.3f{y2}\\\" stroke=\\\"{color}\\\" stroke-width=\\\"0.1\\\" stroke-linecap=\\\"round\\\" stroke-opacity=\\\"{opacity}\\\"/>\"\r\n        \r\n        member this.Fill (style : ArtStyle) : Fill option =\r\n            match style with\r\n            | Cartoon -> None\r\n            | Glossy ->\r\n                match this with\r\n                | Circle (index, color, circle, _) ->\r\n                    (index, circle.Center, circle.Radius, color) |> RadialGradient |> Some \r\n                \r\n                | Polygon (index, color, points, _) ->\r\n                    let centroid = calcCentroid points\r\n                    let maxDist = points |> List.map (fun p -> p.Dist centroid) |> List.max\r\n                    (index, centroid, maxDist, color) |> RadialGradient |> Some    \r\n                \r\n                // | BondPolygon (index, color, points) ->    \r\n                | BondPolygon (index, color, p1, p2, p3, p4, _) ->\r\n                    let midPoint1 = p1.Midpoint p3\r\n                    let midPoint2 = p2.Midpoint p4\r\n                    (index, midPoint1, midPoint2, color) |> LinearGradient |> Some\r\n\r\n                | _ -> None\r\n        \r\n    and Index = int \r\n                \r\n    /// <summary>\r\n    /// Header describes the SVG ID and the SVG view box.\r\n    /// </summary>\r\n    type Header = Header of version: float * encoding: string \r\n        with\r\n        static member New () = Header (1.0, \"UTF-8\")\r\n        override this.ToString () : string =\r\n            let (Header (version, encoding)) = this\r\n            $\"<?xml version=\\\"%.1f{version}\\\" encoding=\\\"{encoding}\\\"?>\"\r\n    \r\n    /// <summary>\r\n    /// SVG encapsulates all individual elements in the SVG image.\r\n    /// </summary>\r\n    type SVG =\r\n        { Header : Header\r\n          ID : string\r\n          ViewBox : ViewBox\r\n          Objects : Shape list\r\n          Style : ArtStyle }\r\n        with\r\n        override this.ToString () =            \r\n            // Concatenate definitions, objects, and header strings. \r\n            this.Header.ToString() + this.Body() \r\n            \r\n        member this.Body() =\r\n            // Format style references.\r\n            let formatStyleReference (o: Shape) : string =\r\n                match o with\r\n                | Circle (index, _, _, _)\r\n                | Polygon (index, _, _, _)\r\n                | BondPolygon (index, _, _, _, _, _, _)\r\n                | Line (index, _, _, _, _) ->\r\n                    $\".item-{index}{{fill:url(#item-{index});}}\"\r\n            \r\n            // Get style references.\r\n            let styles = this.Objects |> List.map (fun x -> formatStyleReference x) |> String.concat \"\\n\"\r\n            \r\n            // Convert all objects to a single string.\r\n            let objs = this.Objects |> List.map (fun x -> x.ToSvg this.Style) |> String.concat \"\\n\"\r\n            \r\n            // Combine items into SVG body.\r\n            match this.Style with\r\n            | Cartoon ->\r\n                $\"<svg id=\\\"{this.ID}\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" {this.ViewBox.ToString()}>\\n{objs}\\n</svg>\"\r\n                \r\n            | Glossy ->\r\n                let defs : string = this.Objects |> List.map (fun o -> o.Fill(this.Style).ToString()) |> String.concat \"\\n\"\r\n                 \r\n                $\"\\n<svg id=\\\"{this.ID}\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" {this.ViewBox.ToString()}>\\n<defs>\\n<style>\\n{styles}\\n</style>\\n{defs}\\n</defs>\\n{objs}\\n</svg>\"\r\n            \r\nmodule Drawing =\r\n    \r\n    open Svg\r\n    \r\n    /// <summary>\r\n    /// Drawing options.\r\n    /// </summary>\r\n    type DrawingOptions =\r\n        { ViewBox : ViewBox option\r\n          ArtStyle : ArtStyle\r\n          ModelStyle : ModelStyle\r\n          DisplayHydrogenAtoms : bool \r\n          Resolution : int }\r\n        with\r\n        static member New () =\r\n            { ViewBox = None\r\n              ArtStyle = Cartoon \r\n              ModelStyle = SpaceFilling\r\n              DisplayHydrogenAtoms = false\r\n              Resolution = 40 }","module CineMol.Helpers\n\nopen System\n\n/// <summary>\n/// Round floating point number to desired number of digits.\n/// </summary>\nlet round (digits: int) (v: float) = Math.Round(v, digits)\n\n/// <summary>\n/// Take absolute value of floating point number.\n/// </summary>\nlet abs (v: float) = Math.Sqrt(v ** 2.0)\n\n/// <summary>\n/// Clamp a floating point value between two other floating point values.\n/// </summary>\nlet clamp lowerBound upperBound (v: float) =\n    if v < lowerBound then lowerBound\n    elif v > upperBound then upperBound\n    else v\n    \n/// <summary>\n/// Try to cast string.\n/// </summary>\nlet inline tryCast (cast: string -> 'a) s =\n    try s |> cast |> Some \n    with :? FormatException -> None\n    \n/// <summary>\n/// Enumerate a list.\n/// </summary>\nlet inline enumerate (items: 'a list) = List.zip [0 .. 1 .. items.Length] items ","import { Record, Union } from \"./Types.js\";\nimport { combineHashCodes, equalArraysWith, stringHash } from \"./Util.js\";\nimport Decimal from \"./Decimal.js\";\nimport { fromInt as int64FromInt } from \"./Long.js\";\nexport class CaseInfo {\n    constructor(declaringType, tag, name, fields) {\n        this.declaringType = declaringType;\n        this.tag = tag;\n        this.name = name;\n        this.fields = fields;\n    }\n}\nexport class MethodInfo {\n    constructor(name, parameters, returnType) {\n        this.name = name;\n        this.parameters = parameters;\n        this.returnType = returnType;\n    }\n}\nexport class TypeInfo {\n    constructor(fullname, generics, construct, parent, fields, cases, enumCases) {\n        this.fullname = fullname;\n        this.generics = generics;\n        this.construct = construct;\n        this.parent = parent;\n        this.fields = fields;\n        this.cases = cases;\n        this.enumCases = enumCases;\n    }\n    toString() {\n        return fullName(this);\n    }\n    GetHashCode() {\n        return getHashCode(this);\n    }\n    Equals(other) {\n        return equals(this, other);\n    }\n}\nexport class GenericParameter extends TypeInfo {\n    constructor(name) {\n        super(name);\n    }\n}\nexport function getGenerics(t) {\n    return t.generics != null ? t.generics : [];\n}\nexport function getHashCode(t) {\n    const fullnameHash = stringHash(t.fullname);\n    const genHashes = getGenerics(t).map(getHashCode);\n    return combineHashCodes([fullnameHash, ...genHashes]);\n}\nexport function equals(t1, t2) {\n    if (t1.fullname === \"\") { // Anonymous records\n        return t2.fullname === \"\"\n            && equalArraysWith(getRecordElements(t1), getRecordElements(t2), ([k1, v1], [k2, v2]) => k1 === k2 && equals(v1, v2));\n    }\n    else {\n        return t1.fullname === t2.fullname\n            && equalArraysWith(getGenerics(t1), getGenerics(t2), equals);\n    }\n}\nexport function class_type(fullname, generics, construct, parent) {\n    return new TypeInfo(fullname, generics, construct, parent);\n}\nexport function record_type(fullname, generics, construct, fields) {\n    return new TypeInfo(fullname, generics, construct, undefined, fields);\n}\nexport function anonRecord_type(...fields) {\n    return new TypeInfo(\"\", undefined, undefined, undefined, () => fields);\n}\nexport function union_type(fullname, generics, construct, cases) {\n    const t = new TypeInfo(fullname, generics, construct, undefined, undefined, () => {\n        const caseNames = construct.prototype.cases();\n        return cases().map((fields, i) => new CaseInfo(t, i, caseNames[i], fields));\n    });\n    return t;\n}\nexport function tuple_type(...generics) {\n    return new TypeInfo(\"System.Tuple`\" + generics.length, generics);\n}\nexport function delegate_type(...generics) {\n    return new TypeInfo(\"System.Func`\" + generics.length, generics);\n}\nexport function lambda_type(argType, returnType) {\n    return new TypeInfo(\"Microsoft.FSharp.Core.FSharpFunc`2\", [argType, returnType]);\n}\nexport function option_type(generic) {\n    return new TypeInfo(\"Microsoft.FSharp.Core.FSharpOption`1\", [generic]);\n}\nexport function list_type(generic) {\n    return new TypeInfo(\"Microsoft.FSharp.Collections.FSharpList`1\", [generic]);\n}\nexport function array_type(generic) {\n    return new TypeInfo(\"[]\", [generic]);\n}\nexport function enum_type(fullname, underlyingType, enumCases) {\n    return new TypeInfo(fullname, [underlyingType], undefined, undefined, undefined, undefined, enumCases);\n}\nexport function measure_type(fullname) {\n    return new TypeInfo(fullname);\n}\nexport function generic_type(name) {\n    return new GenericParameter(name);\n}\nexport const obj_type = new TypeInfo(\"System.Object\");\nexport const unit_type = new TypeInfo(\"Microsoft.FSharp.Core.Unit\");\nexport const char_type = new TypeInfo(\"System.Char\");\nexport const string_type = new TypeInfo(\"System.String\");\nexport const bool_type = new TypeInfo(\"System.Boolean\");\nexport const int8_type = new TypeInfo(\"System.SByte\");\nexport const uint8_type = new TypeInfo(\"System.Byte\");\nexport const int16_type = new TypeInfo(\"System.Int16\");\nexport const uint16_type = new TypeInfo(\"System.UInt16\");\nexport const int32_type = new TypeInfo(\"System.Int32\");\nexport const uint32_type = new TypeInfo(\"System.UInt32\");\nexport const float32_type = new TypeInfo(\"System.Single\");\nexport const float64_type = new TypeInfo(\"System.Double\");\nexport const decimal_type = new TypeInfo(\"System.Decimal\");\nexport function name(info) {\n    if (Array.isArray(info)) {\n        return info[0];\n    }\n    else if (info instanceof TypeInfo) {\n        const elemType = getElementType(info);\n        if (elemType != null) {\n            return name(elemType) + \"[]\";\n        }\n        else {\n            const i = info.fullname.lastIndexOf(\".\");\n            return i === -1 ? info.fullname : info.fullname.substr(i + 1);\n        }\n    }\n    else {\n        return info.name;\n    }\n}\nexport function fullName(t) {\n    const elemType = getElementType(t);\n    if (elemType != null) {\n        return fullName(elemType) + \"[]\";\n    }\n    else if (t.generics == null || t.generics.length === 0) {\n        return t.fullname;\n    }\n    else {\n        return t.fullname + \"[\" + t.generics.map((x) => fullName(x)).join(\",\") + \"]\";\n    }\n}\nexport function namespace(t) {\n    const elemType = getElementType(t);\n    if (elemType != null) {\n        return namespace(elemType);\n    }\n    else {\n        const i = t.fullname.lastIndexOf(\".\");\n        return i === -1 ? \"\" : t.fullname.substr(0, i);\n    }\n}\nexport function isArray(t) {\n    return getElementType(t) != null;\n}\nexport function getElementType(t) {\n    var _a;\n    return t.fullname === \"[]\" && ((_a = t.generics) === null || _a === void 0 ? void 0 : _a.length) === 1 ? t.generics[0] : undefined;\n}\nexport function isGenericType(t) {\n    return t.generics != null && t.generics.length > 0;\n}\nexport function isGenericParameter(t) {\n    return t instanceof GenericParameter;\n}\nexport function isEnum(t) {\n    return t.enumCases != null && t.enumCases.length > 0;\n}\nexport function isSubclassOf(t1, t2) {\n    return (t2.fullname === obj_type.fullname) || (t1.parent != null && (t1.parent.Equals(t2) || isSubclassOf(t1.parent, t2)));\n}\nfunction isErasedToNumber(t) {\n    return isEnum(t) || [\n        int8_type.fullname,\n        uint8_type.fullname,\n        int16_type.fullname,\n        uint16_type.fullname,\n        int32_type.fullname,\n        uint32_type.fullname,\n        float32_type.fullname,\n        float64_type.fullname,\n    ].includes(t.fullname);\n}\nexport function isInstanceOfType(t, o) {\n    if (t.fullname === obj_type.fullname)\n        return true;\n    switch (typeof o) {\n        case \"boolean\":\n            return t.fullname === bool_type.fullname;\n        case \"string\":\n            return t.fullname === string_type.fullname;\n        case \"function\":\n            return isFunction(t);\n        case \"number\":\n            return isErasedToNumber(t);\n        default:\n            return t.construct != null && o instanceof t.construct;\n    }\n}\n/**\n * This doesn't replace types for fields (records) or cases (unions)\n * but it should be enough for type comparison purposes\n */\nexport function getGenericTypeDefinition(t) {\n    return t.generics == null ? t : new TypeInfo(t.fullname, t.generics.map(() => obj_type));\n}\nexport function getEnumUnderlyingType(t) {\n    var _a;\n    return (_a = t.generics) === null || _a === void 0 ? void 0 : _a[0];\n}\nexport function getEnumValues(t) {\n    if (isEnum(t) && t.enumCases != null) {\n        return t.enumCases.map((kv) => kv[1]);\n    }\n    else {\n        throw new Error(`${t.fullname} is not an enum type`);\n    }\n}\nexport function getEnumNames(t) {\n    if (isEnum(t) && t.enumCases != null) {\n        return t.enumCases.map((kv) => kv[0]);\n    }\n    else {\n        throw new Error(`${t.fullname} is not an enum type`);\n    }\n}\nfunction getEnumCase(t, v) {\n    if (t.enumCases != null) {\n        if (typeof v === \"string\") {\n            for (const kv of t.enumCases) {\n                if (kv[0] === v) {\n                    return kv;\n                }\n            }\n            throw new Error(`'${v}' was not found in ${t.fullname}`);\n        }\n        else {\n            for (const kv of t.enumCases) {\n                if (kv[1] === v) {\n                    return kv;\n                }\n            }\n            // .NET returns the number even if it doesn't match any of the cases\n            return [\"\", v];\n        }\n    }\n    else {\n        throw new Error(`${t.fullname} is not an enum type`);\n    }\n}\nexport function parseEnum(t, str) {\n    // TODO: better int parsing here, parseInt ceils floats: \"4.8\" -> 4\n    const value = parseInt(str, 10);\n    return getEnumCase(t, isNaN(value) ? str : value)[1];\n}\nexport function tryParseEnum(t, str, defValue) {\n    try {\n        defValue.contents = parseEnum(t, str);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexport function getEnumName(t, v) {\n    return getEnumCase(t, v)[0];\n}\nexport function isEnumDefined(t, v) {\n    try {\n        const kv = getEnumCase(t, v);\n        return kv[0] != null && kv[0] !== \"\";\n    }\n    catch (_a) {\n        // supress error\n    }\n    return false;\n}\n// FSharpType\nexport function getUnionCases(t) {\n    if (t.cases != null) {\n        return t.cases();\n    }\n    else {\n        throw new Error(`${t.fullname} is not an F# union type`);\n    }\n}\nexport function getRecordElements(t) {\n    if (t.fields != null) {\n        return t.fields();\n    }\n    else {\n        throw new Error(`${t.fullname} is not an F# record type`);\n    }\n}\nexport function getTupleElements(t) {\n    if (isTuple(t) && t.generics != null) {\n        return t.generics;\n    }\n    else {\n        throw new Error(`${t.fullname} is not a tuple type`);\n    }\n}\nexport function getFunctionElements(t) {\n    if (isFunction(t) && t.generics != null) {\n        const gen = t.generics;\n        return [gen[0], gen[1]];\n    }\n    else {\n        throw new Error(`${t.fullname} is not an F# function type`);\n    }\n}\nexport function isUnion(t) {\n    return t instanceof TypeInfo ? t.cases != null : t instanceof Union;\n}\nexport function isRecord(t) {\n    return t instanceof TypeInfo ? t.fields != null : t instanceof Record;\n}\nexport function isTuple(t) {\n    return t.fullname.startsWith(\"System.Tuple\");\n}\n// In .NET this is false for delegates\nexport function isFunction(t) {\n    return t.fullname === \"Microsoft.FSharp.Core.FSharpFunc`2\";\n}\n// FSharpValue\nexport function getUnionFields(v, t) {\n    const cases = getUnionCases(t);\n    const case_ = cases[v.tag];\n    if (case_ == null) {\n        throw new Error(`Cannot find case ${v.name} in union type`);\n    }\n    return [case_, v.fields];\n}\nexport function getUnionCaseFields(uci) {\n    return uci.fields == null ? [] : uci.fields;\n}\n// This is used as replacement of `FSharpValue.GetRecordFields`\n// For `FSharpTypes.GetRecordFields` see `getRecordElements`\n// Object.keys returns keys in the order they were added to the object\nexport function getRecordFields(v) {\n    return Object.keys(v).map((k) => v[k]);\n}\nexport function getRecordField(v, field) {\n    return v[field[0]];\n}\nexport function getTupleFields(v) {\n    return v;\n}\nexport function getTupleField(v, i) {\n    return v[i];\n}\nexport function makeUnion(uci, values) {\n    const expectedLength = (uci.fields || []).length;\n    if (values.length !== expectedLength) {\n        throw new Error(`Expected an array of length ${expectedLength} but got ${values.length}`);\n    }\n    return uci.declaringType.construct != null\n        ? new uci.declaringType.construct(uci.tag, ...values)\n        : {};\n}\nexport function makeRecord(t, values) {\n    const fields = getRecordElements(t);\n    if (fields.length !== values.length) {\n        throw new Error(`Expected an array of length ${fields.length} but got ${values.length}`);\n    }\n    return t.construct != null\n        ? new t.construct(...values)\n        : fields.reduce((obj, [key, _t], i) => {\n            obj[key] = values[i];\n            return obj;\n        }, {});\n}\nexport function makeTuple(values, _t) {\n    return values;\n}\nexport function makeGenericType(t, generics) {\n    return new TypeInfo(t.fullname, generics, t.construct, t.parent, t.fields, t.cases);\n}\nexport function createInstance(t, consArgs) {\n    // TODO: Check if consArgs length is same as t.construct?\n    // (Arg types can still be different)\n    if (typeof t.construct === \"function\") {\n        return new t.construct(...(consArgs !== null && consArgs !== void 0 ? consArgs : []));\n    }\n    else if (isErasedToNumber(t)) {\n        return 0;\n    }\n    else {\n        switch (t.fullname) {\n            case obj_type.fullname:\n                return {};\n            case bool_type.fullname:\n                return false;\n            case \"System.Int64\":\n            case \"System.UInt64\":\n                // typeof<int64> and typeof<uint64> get transformed to class_type(\"System.Int64\")\n                // and class_type(\"System.UInt64\") respectively. Test for the name of the primitive type.\n                return int64FromInt(0);\n            case decimal_type.fullname:\n                return new Decimal(0);\n            case char_type.fullname:\n                // Even though char is a value type, it's erased to string, and Unchecked.defaultof<char> is null\n                return null;\n            default:\n                throw new Error(`Cannot access constructor of ${t.fullname}`);\n        }\n    }\n}\nexport function getValue(propertyInfo, v) {\n    return v[propertyInfo[0]];\n}\n// Fable.Core.Reflection\nfunction assertUnion(x) {\n    if (!(x instanceof Union)) {\n        throw new Error(`Value is not an F# union type`);\n    }\n}\nexport function getCaseTag(x) {\n    assertUnion(x);\n    return x.tag;\n}\nexport function getCaseName(x) {\n    assertUnion(x);\n    return x.cases()[x.tag];\n}\nexport function getCaseFields(x) {\n    assertUnion(x);\n    return x.fields;\n}\n","namespace Fulma\r\n\r\nopen Fable.React\r\nopen Fable.React.Props\r\n\r\nmodule Reflection =\r\n\r\n    open Microsoft.FSharp.Reflection\r\n    open System\r\n\r\n    let getCaseName (case : 'T) =\r\n#if FABLE_COMPILER\r\n        Fable.Core.Reflection.getCaseName case\r\n#else\r\n        // Get UnionCaseInfo value from the F# reflection tools\r\n        let (caseInfo, _args) = FSharpValue.GetUnionFields(case, typeof<'T>)\r\n        caseInfo.GetCustomAttributes()\r\n        |> Seq.tryPick (function\r\n                        | :? CompiledNameAttribute as att -> Some att.CompiledName\r\n                        | _ -> None)\r\n        |> Option.defaultWith (fun () -> caseInfo.Name)\r\n#endif\r\n\r\n    let getCaseTag (case : 'T) =\r\n#if FABLE_COMPILER\r\n        Fable.Core.Reflection.getCaseTag case\r\n#else\r\n        let (caseInfo, _args) = FSharpValue.GetUnionFields(case, typeof<'T>)\r\n        caseInfo.Tag\r\n#endif\r\n\r\n[<RequireQualifiedAccess>]\r\ntype Screen =\r\n    | All\r\n    | [<CompiledName(\"desktop\")>] Desktop\r\n    | [<CompiledName(\"tablet\")>] Tablet\r\n    | [<CompiledName(\"mobile\")>] Mobile\r\n    | [<CompiledName(\"widescreen\")>] WideScreen\r\n    | [<CompiledName(\"touch\")>] Touch\r\n    | [<CompiledName(\"fullhd\")>] FullHD\r\n\r\n    static member ToString (screen : Screen) =\r\n        match screen with\r\n        | All -> \"\"\r\n        | Desktop\r\n        | Tablet\r\n        | Mobile\r\n        | WideScreen\r\n        | Touch\r\n        | FullHD -> \"-\" + Reflection.getCaseName screen\r\n\r\n[<AutoOpen>]\r\nmodule Color =\r\n\r\n    type IColor =\r\n        | [<CompiledName(\"is-black\")>] IsBlack\r\n        | [<CompiledName(\"is-dark\")>] IsDark\r\n        | [<CompiledName(\"is-light\")>] IsLight\r\n        | [<CompiledName(\"is-white\")>] IsWhite\r\n        | [<CompiledName(\"is-primary\")>] IsPrimary\r\n        | [<CompiledName(\"is-info\")>] IsInfo\r\n        | [<CompiledName(\"is-success\")>] IsSuccess\r\n        | [<CompiledName(\"is-warning\")>] IsWarning\r\n        | [<CompiledName(\"is-danger\")>] IsDanger\r\n        | [<CompiledName(\"is-link\")>] IsLink\r\n        | [<CompiledName(\"is-black-bis\")>] IsBlackBis\r\n        | [<CompiledName(\"is-black-ter\")>] IsBlackTer\r\n        | [<CompiledName(\"is-grey-darker\")>] IsGreyDarker\r\n        | [<CompiledName(\"is-grey-dark\")>] IsGreyDark\r\n        | [<CompiledName(\"is-grey\")>] IsGrey\r\n        | [<CompiledName(\"is-grey-light\")>] IsGreyLight\r\n        | [<CompiledName(\"is-grey-lighter\")>] IsGreyLighter\r\n        | [<CompiledName(\"is-white-ter\")>] IsWhiteTer\r\n        | [<CompiledName(\"is-white-bis\")>] IsWhiteBis\r\n        /// Allow you to specify a custom color. The color will be prefixed by \"is-\"\r\n        | IsCustomColor of string\r\n        /// Allow you to specify a NoColor case.\r\n        | NoColor\r\n\r\n    let ofColor level =\r\n        match level with\r\n        | NoColor -> \"\"\r\n        | IsCustomColor color -> \"is-\" + color\r\n        | IsBlack\r\n        | IsDark\r\n        | IsLight\r\n        | IsWhite\r\n        | IsPrimary\r\n        | IsInfo\r\n        | IsSuccess\r\n        | IsWarning\r\n        | IsDanger\r\n        | IsLink\r\n        | IsBlackBis\r\n        | IsBlackTer\r\n        | IsGreyDarker\r\n        | IsGreyDark\r\n        | IsGrey\r\n        | IsGreyLight\r\n        | IsGreyLighter\r\n        | IsWhiteTer\r\n        | IsWhiteBis -> Reflection.getCaseName level\r\n\r\n[<AutoOpen>]\r\nmodule Size =\r\n\r\n    type ISize =\r\n        | [<CompiledName(\"is-small\")>] IsSmall\r\n        | [<CompiledName(\"is-medium\")>] IsMedium\r\n        | [<CompiledName(\"is-large\")>] IsLarge\r\n\r\n    let inline ofSize size =\r\n        Reflection.getCaseName size\r\n\r\n[<RequireQualifiedAccess>]\r\nmodule TextSize =\r\n    type Option =\r\n        | Is1\r\n        | Is2\r\n        | Is3\r\n        | Is4\r\n        | Is5\r\n        | Is6\r\n        | Is7\r\n\r\n        static member ToString (x: Option) =\r\n            Reflection.getCaseTag x + 1 |> string\r\n\r\n    let inline generic screen size =\r\n        \"is-size-\" + Option.ToString size + Screen.ToString screen\r\n\r\n    let inline only screen size =\r\n        match screen with\r\n        | Screen.Tablet\r\n        | Screen.Desktop\r\n        | Screen.WideScreen ->\r\n            \"is-size-\" + Option.ToString size + Screen.ToString screen + \"-only\"\r\n        | x ->\r\n            Fable.Core.JS.console.warn(sprintf \"Screen `%s` does not support `is-size-xxx-only`.\" (string x))\r\n            \"\"\r\n\r\n[<RequireQualifiedAccess>]\r\nmodule TextAlignment =\r\n\r\n    type Option =\r\n        /// Add `has-text-centered`\r\n        | [<CompiledName(\"has-text-centered\")>] Centered\r\n        /// Add `has-text-justified`\r\n        | [<CompiledName(\"has-text-justified\")>] Justified\r\n        /// Add `has-text-left`\r\n        | [<CompiledName(\"has-text-left\")>] Left\r\n        /// Add `has-text-right`\r\n        | [<CompiledName(\"has-text-right\")>] Right\r\n\r\n        static member inline ToString opt =\r\n            Reflection.getCaseName opt\r\n\r\n    let inline generic screen alignment =\r\n        Option.ToString alignment + Screen.ToString screen\r\n\r\n    let inline only screen alignment =\r\n        match screen with\r\n        | Screen.Tablet\r\n        | Screen.Desktop\r\n        | Screen.WideScreen ->\r\n            Option.ToString alignment + Screen.ToString screen + \"-only\"\r\n        | x ->\r\n            Fable.Core.JS.console.warn(sprintf \"Screen `%s` does not support `is-size-xxx-only`.\" (string x))\r\n            \"\"\r\n\r\n[<RequireQualifiedAccess>]\r\nmodule FlexDirection =\r\n\r\n    type Option =\r\n        /// <summary>Add <c>is-flex-direction-row</c></summary>\r\n        | [<CompiledName(\"is-flex-direction-row\")>] Row\r\n        /// <summary>Add <c>is-flex-direction-row-reverse</c></summary>\r\n        | [<CompiledName(\"is-flex-direction-row-reverse\")>] RowReverse\r\n        /// <summary>Add <c>is-flex-direction-column</c></summary>\r\n        | [<CompiledName(\"is-flex-direction-column\")>] Column\r\n        /// <summary>Add <c>is-flex-direction-column-reverse</c></summary>\r\n        | [<CompiledName(\"is-flex-direction-column-reverse\")>] ColumnReverse\r\n\r\n        static member inline toClass (opt : Option) =\r\n            Reflection.getCaseName opt\r\n\r\n[<RequireQualifiedAccess>]\r\nmodule FlexWrap =\r\n\r\n    type Option =\r\n        /// <summary>Add <c>is-flex-wrap-nowrap</c></summary>\r\n        | [<CompiledName(\"is-flex-wrap-nowrap\")>] NoWrap\r\n        /// <summary>Add <c>is-flex-wrap-wrap</c></summary>\r\n        | [<CompiledName(\"is-flex-wrap-wrap\")>] Wrap\r\n        /// <summary>Add <c>is-flex-wrap-wrap-reverse</c></summary>\r\n        | [<CompiledName(\"is-flex-wrap-wrap-reverse\")>] WrapReverse\r\n\r\n        static member inline toClass (opt : Option) =\r\n            Reflection.getCaseName opt\r\n\r\n[<RequireQualifiedAccess>]\r\nmodule FlexJustifyContent =\r\n\r\n    type Option =\r\n        /// <summary>Add <c>is-justify-content-flex-start</c></summary>\r\n        | [<CompiledName(\"is-justify-content-flex-start\")>] FlexStart\r\n        /// <summary>Add <c>is-justify-content-flex-end</c></summary>\r\n        | [<CompiledName(\"is-justify-content-flex-end\")>] FlexEnd\r\n        /// <summary>Add <c>is-justify-content-center</c></summary>\r\n        | [<CompiledName(\"is-justify-content-center\")>] Center\r\n        /// <summary>Add <c>is-justify-content-space-between</c></summary>\r\n        | [<CompiledName(\"is-justify-content-space-between\")>] SpaceBetween\r\n        /// <summary>Add <c>is-justify-content-space-around</c></summary>\r\n        | [<CompiledName(\"is-justify-content-space-around\")>] SpaceAround\r\n        /// <summary>Add <c>is-justify-content-space-evenly</c></summary>\r\n        | [<CompiledName(\"is-justify-content-space-evenly\")>] SpaceEvenly\r\n        /// <summary>Add <c>is-justify-content-start</c></summary>\r\n        | [<CompiledName(\"is-justify-content-start\")>] Start\r\n        /// <summary>Add <c>is-justify-content-end</c></summary>\r\n        | [<CompiledName(\"is-justify-content-end\")>] End\r\n        /// <summary>Add <c>is-justify-content-left</c></summary>\r\n        | [<CompiledName(\"is-justify-content-left\")>] Left\r\n        /// <summary>Add <c>is-justify-content-right</c></summary>\r\n        | [<CompiledName(\"is-justify-content-right\")>] Right\r\n\r\n        static member inline toClass (opt : Option) =\r\n            Reflection.getCaseName opt\r\n\r\n[<RequireQualifiedAccess>]\r\nmodule FlexAlignContent =\r\n\r\n    type Option =\r\n        /// <summary>Add <c>is-align-content-flex-start</c></summary>\r\n        | [<CompiledName(\"is-align-content-flex-start\")>] FlexStart\r\n        /// <summary>Add <c>is-align-content-flex-end</c></summary>\r\n        | [<CompiledName(\"is-align-content-flex-end\")>] FlexEnd\r\n        /// <summary>Add <c>is-align-content-center</c></summary>\r\n        | [<CompiledName(\"is-align-content-center\")>] Center\r\n        /// <summary>Add <c>is-align-content-space-between</c></summary>\r\n        | [<CompiledName(\"is-align-content-space-between\")>] SpaceBetween\r\n        /// <summary>Add <c>is-align-content-space-around</c></summary>\r\n        | [<CompiledName(\"is-align-content-space-around\")>] SpaceAround\r\n        /// <summary>Add <c>is-align-content-space-evenly</c></summary>\r\n        | [<CompiledName(\"is-align-content-space-evenly\")>] SpaceEvenly\r\n        /// <summary>Add <c>is-align-content-stretch</c></summary>\r\n        | [<CompiledName(\"is-align-content-stretch\")>] Stretch\r\n        /// <summary>Add <c>is-align-content-start</c></summary>\r\n        | [<CompiledName(\"is-align-content-start\")>] Start\r\n        /// <summary>Add <c>is-align-content-end</c></summary>\r\n        | [<CompiledName(\"is-align-content-end\")>] End\r\n        /// <summary>Add <c>is-align-content-baseline</c></summary>\r\n        | [<CompiledName(\"is-align-content-baseline\")>] Baseline\r\n\r\n        static member inline toClass (opt : Option) =\r\n            Reflection.getCaseName opt\r\n\r\n\r\n[<RequireQualifiedAccess>]\r\nmodule FlexAlignItems =\r\n\r\n    type Option =\r\n        /// <summary>Add <c>is-align-items-stretch</c></summary>\r\n        | [<CompiledName(\"is-align-items-stretch\")>] Stretch\r\n        /// <summary>Add <c>is-align-items-flex-start</c></summary>\r\n        | [<CompiledName(\"is-align-items-flex-start\")>] FlexStart\r\n        /// <summary>Add <c>is-align-items-flex-end</c></summary>\r\n        | [<CompiledName(\"is-align-items-flex-end\")>] FlexEnd\r\n        /// <summary>Add <c>is-align-items-center</c></summary>\r\n        | [<CompiledName(\"is-align-items-center\")>] Center\r\n        /// <summary>Add <c>is-align-items-baseline</c></summary>\r\n        | [<CompiledName(\"is-align-items-baseline\")>] Baseline\r\n        /// <summary>Add <c>is-align-items-start</c></summary>\r\n        | [<CompiledName(\"is-align-items-start\")>] Start\r\n        /// <summary>Add <c>is-align-items-end</c></summary>\r\n        | [<CompiledName(\"is-align-items-end\")>] End\r\n        /// <summary>Add <c>is-align-items-self-start</c></summary>\r\n        | [<CompiledName(\"is-align-items-self-start\")>] SelfStart\r\n        /// <summary>Add <c>is-align-items-self-end</c></summary>\r\n        | [<CompiledName(\"is-align-items-self-end\")>] SelfEnd\r\n\r\n        static member inline toClass (opt : Option) =\r\n            Reflection.getCaseName opt\r\n\r\n[<RequireQualifiedAccess>]\r\nmodule FlexAlignSelf =\r\n\r\n    type Option =\r\n        /// <summary>Add <c>is-align-self-auto</c></summary>\r\n        | [<CompiledName(\"is-align-self-auto\")>] Auto\r\n        /// <summary>Add <c>is-align-self-flex-start</c></summary>\r\n        | [<CompiledName(\"is-align-self-flex-start\")>] FlexStart\r\n        /// <summary>Add <c>is-align-self-flex-end</c></summary>\r\n        | [<CompiledName(\"is-align-self-flex-end\")>] FlexEnd\r\n        /// <summary>Add <c>is-align-self-center</c></summary>\r\n        | [<CompiledName(\"is-align-self-center\")>] Center\r\n        /// <summary>Add <c>is-align-self-baseline</c></summary>\r\n        | [<CompiledName(\"is-align-self-baseline\")>] Baseline\r\n        /// <summary>Add <c>is-align-self-stretch</c></summary>\r\n        | [<CompiledName(\"is-align-self-stretch\")>] Stretch\r\n\r\n        static member inline toClass (opt : Option) =\r\n            Reflection.getCaseName opt\r\n\r\n[<RequireQualifiedAccess>]\r\nmodule FlexGrow =\r\n\r\n    type Option =\r\n        /// <summary>Add <c>is-flex-grow-0</c></summary>\r\n        | [<CompiledName(\"is-flex-grow-0\")>] Is0\r\n        /// <summary>Add <c>is-flex-grow-1</c></summary>\r\n        | [<CompiledName(\"is-flex-grow-1\")>] Is1\r\n        /// <summary>Add <c>is-flex-grow-2</c></summary>\r\n        | [<CompiledName(\"is-flex-grow-2\")>] Is2\r\n        /// <summary>Add <c>is-flex-grow-3</c></summary>\r\n        | [<CompiledName(\"is-flex-grow-3\")>] Is3\r\n        /// <summary>Add <c>is-flex-grow-4</c></summary>\r\n        | [<CompiledName(\"is-flex-grow-4\")>] Is4\r\n        /// <summary>Add <c>is-flex-grow-5</c></summary>\r\n        | [<CompiledName(\"is-flex-grow-5\")>] Is5\r\n\r\n        static member inline toClass (opt : Option) =\r\n            Reflection.getCaseName opt\r\n\r\n[<RequireQualifiedAccess>]\r\nmodule FlexShrink =\r\n\r\n    type Option =\r\n        /// <summary>Add <c>is-flex-shrink-0</c></summary>\r\n        | [<CompiledName(\"is-flex-shrink-0\")>] Is0\r\n        /// <summary>Add <c>is-flex-shrink-1</c></summary>\r\n        | [<CompiledName(\"is-flex-shrink-1\")>] Is1\r\n        /// <summary>Add <c>is-flex-shrink-2</c></summary>\r\n        | [<CompiledName(\"is-flex-shrink-2\")>] Is2\r\n        /// <summary>Add <c>is-flex-shrink-3</c></summary>\r\n        | [<CompiledName(\"is-flex-shrink-3\")>] Is3\r\n        /// <summary>Add <c>is-flex-shrink-4</c></summary>\r\n        | [<CompiledName(\"is-flex-shrink-4\")>] Is4\r\n        /// <summary>Add <c>is-flex-shrink-5</c></summary>\r\n        | [<CompiledName(\"is-flex-shrink-5\")>] Is5\r\n\r\n        static member inline toClass (opt : Option) =\r\n            Reflection.getCaseName opt\r\n\r\n\r\n[<RequireQualifiedAccess>]\r\nmodule TextWeight =\r\n\r\n    type Option =\r\n        /// Add `has-text-weight-light`\r\n        | [<CompiledName(\"has-text-weight-light\")>] Light\r\n        /// Add `has-text-weight-normal`\r\n        | [<CompiledName(\"has-text-weight-normal\")>] Normal\r\n        /// Add `has-text-weight-semibold`\r\n        | [<CompiledName(\"has-text-weight-semibold\")>] SemiBold\r\n        /// Add `has-text-weight-bold`\r\n        | [<CompiledName(\"has-text-weight-bold\")>] Bold\r\n        /// Add `has-text-weight-medium`\r\n        | [<CompiledName(\"has-text-weight-medium\")>] Medium\r\n\r\n    let inline internal ofOption opt =\r\n        Reflection.getCaseName opt\r\n\r\n[<RequireQualifiedAccess>]\r\nmodule TextTransform =\r\n\r\n    type Option =\r\n        /// Add `is-capitalized`\r\n        | [<CompiledName(\"is-capitalized\")>] Capitalized\r\n        /// Add `is-lowercase`\r\n        | [<CompiledName(\"is-lowercase\")>] LowerCase\r\n        /// Add `is-uppercase`\r\n        | [<CompiledName(\"is-uppercase\")>] UpperCase\r\n        /// Add `is-italic`\r\n        | [<CompiledName(\"is-italic\")>] Italic\r\n        /// Add `is-underlined`\r\n        | [<CompiledName(\"is-underlined\")>] Underlined\r\n\r\n        static member inline toClass opt =\r\n            Reflection.getCaseName opt\r\n\r\n[<RequireQualifiedAccess>]\r\nmodule Display =\r\n\r\n    type Option =\r\n        | [<CompiledName(\"block\")>] Block\r\n        | [<CompiledName(\"flex\")>] Flex\r\n        | [<CompiledName(\"inline\")>] Inline\r\n        | [<CompiledName(\"inline-block\")>] InlineBlock\r\n        | [<CompiledName(\"inline-flex\")>] InlineFlex\r\n\r\n        static member inline toClass opt =\r\n            Reflection.getCaseName opt\r\n\r\n    let internal toDisplayClass screen display =\r\n        let display = Option.toClass display\r\n        let screen = Screen.ToString screen\r\n\r\n        \"is-\" + display + screen\r\n\r\n    let internal toDisplayOnlyClass screen display =\r\n        match screen with\r\n        | Screen.Tablet\r\n        | Screen.Desktop\r\n        | Screen.WideScreen ->\r\n            let display = Option.toClass display\r\n            let screen = Screen.ToString screen\r\n            \"is-\" + display + screen + \"-only\"\r\n\r\n        | x ->\r\n            Fable.Core.JS.console.warn(sprintf \"Screen `%s` does not support display only.\" (string x))\r\n            \"\"\r\n\r\n[<RequireQualifiedAccess>]\r\nmodule Spacing =\r\n    type TypeAndDirection =\r\n        | [<CompiledName(\"m\")>] Margin\r\n        | [<CompiledName(\"mt\")>] MarginTop\r\n        | [<CompiledName(\"mr\")>] MarginRight\r\n        | [<CompiledName(\"mb\")>] MarginBottom\r\n        | [<CompiledName(\"ml\")>] MarginLeft\r\n        | [<CompiledName(\"my\")>] MarginTopAndBottom\r\n        | [<CompiledName(\"mx\")>] MarginLeftAndRight\r\n        | [<CompiledName(\"p\")>] Padding\r\n        | [<CompiledName(\"pt\")>] PaddingTop\r\n        | [<CompiledName(\"pr\")>] PaddingRight\r\n        | [<CompiledName(\"pb\")>] PaddingBottom\r\n        | [<CompiledName(\"pl\")>] PaddingLeft\r\n        | [<CompiledName(\"py\")>] PaddingTopAndBottom\r\n        | [<CompiledName(\"px\")>] PaddingLeftAndRight\r\n\r\n        static member inline toClass opt =\r\n            Reflection.getCaseName opt\r\n\r\n    type Amount =\r\n        | [<CompiledName(\"auto\")>] IsAuto\r\n        | [<CompiledName(\"0\")>] Is0\r\n        | [<CompiledName(\"1\")>] Is1\r\n        | [<CompiledName(\"2\")>] Is2\r\n        | [<CompiledName(\"3\")>] Is3\r\n        | [<CompiledName(\"4\")>] Is4\r\n        | [<CompiledName(\"5\")>] Is5\r\n        | [<CompiledName(\"6\")>] Is6\r\n\r\n        static member inline toClass opt =\r\n            Reflection.getCaseName opt\r\n\r\n    let internal toSpacingClass typ amount =\r\n        let typ = TypeAndDirection.toClass typ\r\n        let amount = Amount.toClass amount\r\n\r\n        typ + \"-\" + amount\r\n\r\n[<RequireQualifiedAccess>]\r\nmodule Modifier =\r\n    let internal ofBackground level =\r\n        match level with\r\n        | NoColor -> \"\"\r\n        | IsCustomColor color -> \"has-background-\" + color\r\n        | IsBlack\r\n        | IsDark\r\n        | IsLight\r\n        | IsWhite\r\n        | IsPrimary\r\n        | IsInfo\r\n        | IsSuccess\r\n        | IsWarning\r\n        | IsDanger\r\n        | IsLink\r\n        | IsBlackBis\r\n        | IsBlackTer\r\n        | IsGreyDarker\r\n        | IsGreyDark\r\n        | IsGrey\r\n        | IsGreyLight\r\n        | IsGreyLighter\r\n        | IsWhiteTer\r\n        | IsWhiteBis -> \"has-background-\" + (Reflection.getCaseName level).[3..]\r\n\r\n    let internal ofText level =\r\n        match level with\r\n        | NoColor -> \"\"\r\n        | IsCustomColor color -> \"has-text-\" + color\r\n        | IsBlack\r\n        | IsDark\r\n        | IsLight\r\n        | IsWhite\r\n        | IsPrimary\r\n        | IsInfo\r\n        | IsSuccess\r\n        | IsWarning\r\n        | IsDanger\r\n        | IsLink\r\n        | IsBlackBis\r\n        | IsBlackTer\r\n        | IsGreyDarker\r\n        | IsGreyDark\r\n        | IsGrey\r\n        | IsGreyLight\r\n        | IsGreyLighter\r\n        | IsWhiteTer\r\n        | IsWhiteBis -> \"has-text-\" + (Reflection.getCaseName level).[3..]\r\n\r\n    let internal ofInvisible screen =\r\n        \"is-invisible\" + Screen.ToString screen\r\n\r\n    let internal ofHidden screen =\r\n        \"is-hidden\" + Screen.ToString screen\r\n\r\n    let internal ofInvisibleOnly screen =\r\n        match screen with\r\n        | Screen.Tablet\r\n        | Screen.Desktop\r\n        | Screen.WideScreen ->\r\n            \"is-invisible\" + Screen.ToString screen + \"-only\"\r\n        | x ->\r\n            Fable.Core.JS.console.warn(sprintf \"Screen `%s` does not support `is-invisible-xxx-only`.\" (string x))\r\n            \"\"\r\n\r\n    let internal ofHiddenOnly screen =\r\n        match screen with\r\n        | Screen.Tablet\r\n        | Screen.Desktop\r\n        | Screen.WideScreen ->\r\n            \"is-hidden\" + Screen.ToString screen + \"-only\"\r\n        | x ->\r\n            Fable.Core.JS.console.warn(sprintf \"Screen `%s` does not support `is-hidden-xxx-only`.\" (string x))\r\n            \"\"\r\n\r\n    type IModifier =\r\n        | BackgroundColor of IColor\r\n        | TextColor of IColor\r\n        | TextWeight of TextWeight.Option\r\n        | TextSize of Screen * TextSize.Option\r\n        | TextSizeOnly of Screen * TextSize.Option\r\n        | TextAlignment of Screen * TextAlignment.Option\r\n        | TextAlignmentOnly of Screen * TextAlignment.Option\r\n        | TextTransform of TextTransform.Option\r\n        | Display of Screen * Display.Option\r\n        | DisplayOnly of Screen * Display.Option\r\n        | [<CompiledName(\"is-clearfix\")>] IsClearfix\r\n        | [<CompiledName(\"is-pulled-left\")>] IsPulledLeft\r\n        | [<CompiledName(\"is-pulled-right\")>] IsPulledRight\r\n        | [<CompiledName(\"is-marginless\")>] IsMarginless\r\n        | [<CompiledName(\"is-paddingless\")>] IsPaddingless\r\n        | [<CompiledName(\"is-overlay\")>] IsOverlay\r\n        | [<CompiledName(\"is-clipped\")>] IsClipped\r\n        | [<CompiledName(\"is-radiusless\")>] IsRadiusless\r\n        | [<CompiledName(\"is-shadowless\")>] IsShadowless\r\n        | [<CompiledName(\"is-unselectable\")>] IsUnselectable\r\n        | [<CompiledName(\"is-clickable\")>] IsClickable\r\n        | [<CompiledName(\"is-relative\")>] IsRelative\r\n        | [<CompiledName(\"is-flex\")>] IsFlex\r\n        | IsInvisible of Screen * bool\r\n        | IsHidden of Screen * bool\r\n        | IsInvisibleOnly of Screen * bool\r\n        | IsHiddenOnly of Screen * bool\r\n        | IsSrOnly\r\n        | IsScreenReaderOnly\r\n        | Spacing of Spacing.TypeAndDirection * Spacing.Amount\r\n        // Flexbox helpers\r\n        | FlexDirection of FlexDirection.Option\r\n        | FlexWrap of FlexWrap.Option\r\n        | FlexJustifyContent of FlexJustifyContent.Option\r\n        | FlexAlignContent of FlexAlignContent.Option\r\n        | FlexAlignItems of FlexAlignItems.Option\r\n        | FlexAlignSelf of FlexAlignSelf.Option\r\n        | FlexGrow of FlexGrow.Option\r\n        | FlexShrink of FlexShrink.Option\r\n\r\n\r\n\r\n                //     | IsGap (screen, size) ->\r\n                // if not (List.contains \"is-variable\" result.Classes) then\r\n                //     result.AddClass(\"is-variable\").AddClass(gapSizeGeneric screen size)\r\n                // else\r\n                //     result.AddClass(gapSizeGeneric screen size)\r\n\r\n\r\n\r\n    let parseModifiers options =\r\n        let parseOptions result option =\r\n            match option with\r\n            | BackgroundColor color             -> (ofBackground color)::result\r\n            | TextColor color                   -> (ofText color)::result\r\n            | TextWeight textWeight             -> (TextWeight.ofOption textWeight)::result\r\n            | TextSize (screen, size)           -> (TextSize.generic screen size)::result\r\n            | TextSizeOnly (screen, size)       -> (TextSize.only screen size)::result\r\n            | TextAlignment (screen, size)      -> (TextAlignment.generic screen size)::result\r\n            | TextAlignmentOnly (screen, size)  -> (TextAlignment.only screen size)::result\r\n            | TextTransform transform           -> (TextTransform.Option.toClass transform)::result\r\n            | Display (screen, display)         -> (Display.toDisplayClass screen display)::result\r\n            | DisplayOnly (screen, display)     -> (Display.toDisplayOnlyClass screen display)::result\r\n            | IsInvisible (screen, b)           -> if b then (ofInvisible screen)::result else result\r\n            | IsInvisibleOnly (screen, b)       -> if b then (ofInvisibleOnly screen)::result else result\r\n            | IsHidden (screen, b)              -> if b then (ofHidden screen)::result else result\r\n            | IsHiddenOnly (screen, b)          -> if b then (ofHiddenOnly screen)::result else result\r\n            | IsSrOnly\r\n            | IsScreenReaderOnly -> \"is-sr-only\"::result\r\n            | IsClearfix\r\n            | IsPulledLeft\r\n            | IsPulledRight\r\n            | IsMarginless\r\n            | IsPaddingless\r\n            | IsOverlay\r\n            | IsClipped\r\n            | IsRadiusless\r\n            | IsShadowless\r\n            | IsClickable\r\n            | IsUnselectable\r\n            | IsFlex\r\n            | IsRelative -> (Reflection.getCaseName option)::result\r\n            | Spacing (typ, amount) -> (Spacing.toSpacingClass typ amount)::result\r\n            | FlexDirection direction ->\r\n                if not (List.contains \"is-flex\" result) then\r\n                    \"is-flex\"::(FlexDirection.Option.toClass direction)::result\r\n                else\r\n                    (FlexDirection.Option.toClass direction)::result\r\n            | FlexWrap option ->\r\n                if not (List.contains \"is-flex\" result) then\r\n                    \"is-flex\"::(FlexWrap.Option.toClass option)::result\r\n                else\r\n                    (FlexWrap.Option.toClass option)::result\r\n            | FlexJustifyContent option ->\r\n                if not (List.contains \"is-flex\" result) then\r\n                    \"is-flex\"::(FlexJustifyContent.Option.toClass option)::result\r\n                else\r\n                    (FlexJustifyContent.Option.toClass option)::result\r\n            | FlexAlignContent option ->\r\n                if not (List.contains \"is-flex\" result) then\r\n                    \"is-flex\"::(FlexAlignContent.Option.toClass option)::result\r\n                else\r\n                    (FlexAlignContent.Option.toClass option)::result\r\n            | FlexAlignItems option ->\r\n                if not (List.contains \"is-flex\" result) then\r\n                    \"is-flex\"::(FlexAlignItems.Option.toClass option)::result\r\n                else\r\n                    (FlexAlignItems.Option.toClass option)::result\r\n\r\n            | FlexAlignSelf option ->\r\n                (FlexAlignSelf.Option.toClass option)::result\r\n\r\n            | FlexGrow size ->\r\n                (FlexGrow.Option.toClass size)::result\r\n\r\n            | FlexShrink size ->\r\n                (FlexShrink.Option.toClass size)::result\r\n\r\n        options |> List.fold parseOptions []\r\n\r\n[<AutoOpen>]\r\nmodule Common =\r\n    type GenericOption =\r\n        | CustomClass of string\r\n        | Props of IHTMLProp list\r\n        | Modifiers of Modifier.IModifier list\r\n\r\n    type GenericOptions =\r\n        { Props : IHTMLProp list\r\n          Classes : string list\r\n          RemovedClasses : string list }\r\n\r\n        static member Empty =\r\n            { Props = []; Classes = []; RemovedClasses = [] }\r\n\r\n        static member Parse(options, parser, ?baseClass, ?baseProps) =\r\n            let result = options |> List.fold parser GenericOptions.Empty\r\n\r\n            let result =\r\n                match baseClass with\r\n                | Some baseClass -> result.AddClass(baseClass)\r\n                | None -> result\r\n\r\n            match baseProps with\r\n            | Some baseProps -> result.AddProps(baseProps)\r\n            | None -> result\r\n\r\n        member this.AddProp(prop : IHTMLProp) =\r\n            { this with Props = prop::this.Props }\r\n\r\n        member this.AddProps(props : IHTMLProp list) =\r\n            { this with Props = props@this.Props }\r\n\r\n        member this.AddClass(cl: string) =\r\n            { this with Classes = cl::this.Classes }\r\n\r\n        member this.RemoveClass(cl: string) =\r\n            { this with RemovedClasses = cl::this.RemovedClasses }\r\n\r\n        member this.AddCaseName(case: 'T) =\r\n            Reflection.getCaseName case |> this.AddClass\r\n\r\n        member this.AddModifiers(modifiers) =\r\n            { this with Classes = (modifiers |> Modifier.parseModifiers) @ this.Classes }\r\n\r\n        member this.ToAttributes() =\r\n            match this.Classes |> List.filter (fun cls -> not (System.String.IsNullOrEmpty cls) && not (List.contains cls this.RemovedClasses)) with\r\n            | [] -> this.Props\r\n            | classes -> (classes |> String.concat \" \" |> ClassName :> _) :: this.Props\r\n\r\n        /// Convert to standard element\r\n        member this.ToReactElement(el : IHTMLProp list -> ReactElement list -> ReactElement, ?children): ReactElement =\r\n            let children = defaultArg children []\r\n            el (this.ToAttributes ()) children\r\n\r\n        /// Convert to self closing element\r\n        member this.ToReactElement(el : IHTMLProp list -> ReactElement): ReactElement =\r\n            el (this.ToAttributes ())\r\n\r\n    let parseOptions (result : GenericOptions) option =\r\n        match option with\r\n        | Props props -> result.AddProps props\r\n        | CustomClass customClass -> result.AddClass customClass\r\n        | Modifiers modifiers -> result.AddModifiers modifiers\r\n\r\n    module Helpers =\r\n\r\n        [<System.Obsolete(\"Use GenericOptions.Parse. This build an abstraction layer usable by all the components and helps reduce the bundle size\")>]\r\n        let classes std (options : string option list) (booleans: (string * bool) list) =\r\n            let std = (std, options) ||> List.fold (fun complete option ->\r\n                match option with\r\n                | Some name -> complete + \" \" + name\r\n                | None -> complete )\r\n            (std, booleans) ||> List.fold (fun complete (name, flag) ->\r\n                if flag then complete + \" \" + name else complete)\r\n            |> ClassName :> IHTMLProp\r\n\r\n[<RequireQualifiedAccess>]\r\nmodule Text =\r\n    open Fable.React\r\n\r\n    let p (options: GenericOption list) children =\r\n        GenericOptions.Parse(options, parseOptions).ToReactElement(p, children)\r\n\r\n    let div (options: GenericOption list) children =\r\n        GenericOptions.Parse(options, parseOptions).ToReactElement(div, children)\r\n\r\n    let span (options: GenericOption list) children =\r\n        GenericOptions.Parse(options, parseOptions).ToReactElement(span, children)\r\n","import { equals } from \"./Util.js\";\nimport { Union } from \"./Types.js\";\nconst CaseRules = {\n    None: 0,\n    LowerFirst: 1,\n    SnakeCase: 2,\n    SnakeCaseAllCaps: 3,\n    KebabCase: 4,\n};\nfunction dashify(str, separator) {\n    return str.replace(/[a-z]?[A-Z]/g, (m) => m.length === 1\n        ? m.toLowerCase()\n        : m.charAt(0) + separator + m.charAt(1).toLowerCase());\n}\nfunction changeCase(str, caseRule) {\n    switch (caseRule) {\n        case CaseRules.LowerFirst:\n            return str.charAt(0).toLowerCase() + str.slice(1);\n        case CaseRules.SnakeCase:\n            return dashify(str, \"_\");\n        case CaseRules.SnakeCaseAllCaps:\n            return dashify(str, \"_\").toUpperCase();\n        case CaseRules.KebabCase:\n            return dashify(str, \"-\");\n        case CaseRules.None:\n        default:\n            return str;\n    }\n}\nexport function keyValueList(fields, caseRule = CaseRules.None) {\n    const obj = {};\n    const definedCaseRule = caseRule;\n    function fail(kvPair) {\n        throw new Error(\"Cannot infer key and value of \" + String(kvPair));\n    }\n    function assign(key, caseRule, value) {\n        key = changeCase(key, caseRule);\n        obj[key] = value;\n    }\n    for (let kvPair of fields) {\n        let caseRule = CaseRules.None;\n        if (kvPair == null) {\n            fail(kvPair);\n        }\n        // Deflate unions and use the defined case rule\n        if (kvPair instanceof Union) {\n            const name = kvPair.cases()[kvPair.tag];\n            kvPair = kvPair.fields.length === 0 ? name : [name].concat(kvPair.fields);\n            caseRule = definedCaseRule;\n        }\n        if (Array.isArray(kvPair)) {\n            switch (kvPair.length) {\n                case 0:\n                    fail(kvPair);\n                    break;\n                case 1:\n                    assign(kvPair[0], caseRule, true);\n                    break;\n                case 2:\n                    const value = kvPair[1];\n                    assign(kvPair[0], caseRule, value);\n                    break;\n                default:\n                    assign(kvPair[0], caseRule, kvPair.slice(1));\n            }\n        }\n        else if (typeof kvPair === \"string\") {\n            assign(kvPair, caseRule, true);\n        }\n        else {\n            fail(kvPair);\n        }\n    }\n    return obj;\n}\n// TODO: Move these methods to Map and Set modules\nexport function containsValue(v, map) {\n    for (const kv of map) {\n        if (equals(v, kv[1])) {\n            return true;\n        }\n    }\n    return false;\n}\nexport function tryGetValue(map, key, defaultValue) {\n    if (map.has(key)) {\n        defaultValue.contents = map.get(key);\n        return true;\n    }\n    return false;\n}\nexport function addToSet(v, set) {\n    if (set.has(v)) {\n        return false;\n    }\n    set.add(v);\n    return true;\n}\nexport function addToDict(dict, k, v) {\n    if (dict.has(k)) {\n        throw new Error(\"An item with the same key has already been added. Key: \" + k);\n    }\n    dict.set(k, v);\n}\nexport function getItemFromDict(map, key) {\n    if (map.has(key)) {\n        return map.get(key);\n    }\n    else {\n        throw new Error(`The given key '${key}' was not present in the dictionary.`);\n    }\n}\n","namespace Fulma\r\n\r\nopen Fulma\r\nopen Fable.React\r\nopen Fable.React.Props\r\n\r\n[<RequireQualifiedAccess>]\r\nmodule File =\r\n\r\n    type Option =\r\n        | CustomClass of string\r\n        | Props of IHTMLProp list\r\n        | Size of ISize\r\n        /// Add `is-focused` class if true\r\n        | [<CompiledName(\"is-focused\")>]IsFocused of bool\r\n        /// Add `is-active` class if true\r\n        | [<CompiledName(\"is-active\")>]IsActive of bool\r\n        /// Add `is-hovered` class if true\r\n        | [<CompiledName(\"is-hovered\")>]IsHovered of bool\r\n        /// Add `is-fullwidth` class\r\n        | [<CompiledName(\"is-fullwidth\")>]IsFullWidth\r\n        /// Add `is-centered` class\r\n        | [<CompiledName(\"is-centered\")>]IsCentered\r\n        /// Add `is-right` class\r\n        | [<CompiledName(\"is-right\")>]IsRight\r\n        /// Add `is-boxed` class\r\n        | [<CompiledName(\"is-boxed\")>]IsBoxed\r\n        /// Add `has-name` class\r\n        | [<CompiledName(\"has-name\")>]HasName\r\n        /// Add `is-empty` class if true\r\n        | [<CompiledName(\"is-empty\")>]IsEmpty of bool\r\n        | Color of IColor\r\n        | Modifiers of Modifier.IModifier list\r\n\r\n    /// Generate <div class=\"file\"></div>\r\n    let file (options : Option list) children =\r\n        let parseOptions (result : GenericOptions) option =\r\n            match option with\r\n            | Size size -> ofSize size |> result.AddClass\r\n            | IsFullWidth\r\n            | IsCentered\r\n            | IsRight\r\n            | IsBoxed\r\n            | HasName -> result.AddCaseName option\r\n            | Color color -> ofColor color |> result.AddClass\r\n            | IsFocused state\r\n            | IsActive state\r\n            | IsHovered state\r\n            | IsEmpty state -> if state then result.AddCaseName option else result\r\n            | Props props -> result.AddProps props\r\n            | CustomClass customClass -> result.AddClass customClass\r\n            | Modifiers modifiers -> result.AddModifiers modifiers\r\n\r\n        GenericOptions.Parse(options, parseOptions, \"file\").ToReactElement(div, children)\r\n\r\n    /// Generate <input type=\"file\" class=\"file-input\"/>\r\n    let input (options : GenericOption list) =\r\n        GenericOptions.Parse(options, parseOptions, \"file-input\", [Type \"file\" :> IHTMLProp]).ToReactElement(input)\r\n\r\n    /// Generate <span class=\"file-cta\"></span>\r\n    let cta (options : GenericOption list) children =\r\n        GenericOptions.Parse(options, parseOptions, \"file-cta\").ToReactElement(span, children)\r\n\r\n    /// Generate <span class=\"file-name\"></span>\r\n    let name (options : GenericOption list) children =\r\n        GenericOptions.Parse(options, parseOptions, \"file-name\").ToReactElement(span, children)\r\n\r\n    /// Generate <span class=\"file-icon\"></span>\r\n    let icon (options : GenericOption list) children =\r\n        GenericOptions.Parse(options, parseOptions, \"file-icon\").ToReactElement(span, children)\r\n\r\n    module Label =\r\n\r\n        /// Generate <span class=\"file-label\"></span>\r\n        let span (options : GenericOption list) children =\r\n            GenericOptions.Parse(options, parseOptions, \"file-label\").ToReactElement(span, children)\r\n\r\n        /// Generate <label class=\"file-label\"></label>\r\n        let label (options : GenericOption list) children =\r\n            GenericOptions.Parse(options, parseOptions, \"file-label\").ToReactElement(label, children)\r\n","module CineMol.Drawing\n\nopen CineMol.Types\nopen CineMol.Types.Chem\nopen Types.Geometry\nopen Types.Svg \nopen Types.Drawing\n\n/// <summary>\n/// Driver code for rotating atoms in molecule.\n/// </summary>\nlet rotate (mol: Molecule) (axis: Axis) (rad: float) =\n    let rotateAtom (atom : Atom) = { atom with Position = atom.Position.Rotate axis rad }\n    { mol with Atoms = List.map (fun atom -> rotateAtom atom) mol.Atoms }\n\n/// <summary>\n/// Algorithm for finding convex hull of a set of points in 2D.\n/// </summary>\nlet quickHull2D (points : Point2D list) : int list =\n    // Find index of point with minimum X coordinate.\n    let minIndex : int =\n        points\n        |> List.mapi (fun i point -> (i, point))\n        |> List.minBy (fun (_, point) -> point.X)\n        |> fst\n        \n    // Find index of point with maximum X coordinate.\n    let maxIndex : int =\n        points\n        |> List.mapi (fun i point -> (i, point))\n        |> List.maxBy (fun (_, point) -> point.X)\n        |> fst\n        \n    // Create a range.\n    let createRange (length : int) : int list = [ 0 .. 1 .. length - 1 ]\n        \n    let rec processPoints (pointList : Point2D list, indexList : int list, a : int, b : int) : int list =\n        let W : Vector2D = pointList[b].CreateVector pointList[a]\n        \n        let signedDist : (int * float) list =\n            indexList\n            |> List.map (fun i -> (i, pointList[i]))\n            |> List.map (fun (i, point) ->\n                let V : Vector2D = point.CreateVector pointList[a]\n                let dist : float = V.Cross W\n                (i, dist))\n            |> List.filter (fun (i, dist) -> dist > 0.0 && i <> a && i <> b)\n        \n        match signedDist with\n        | [] -> [ a; b ]\n        | _ ->\n            let maxDistIndex : int = signedDist |> List.maxBy (fun (_, dist) -> dist) |> fst\n            let newIndexList : int list = List.map fst signedDist\n            \n            let left = processPoints (pointList, newIndexList, a, maxDistIndex)\n            let right = processPoints (pointList, newIndexList, maxDistIndex, b)\n            \n            (left |> List.rev |> List.tail |> List.rev) @ right\n    \n    let left = processPoints (points, createRange points.Length, minIndex, maxIndex)\n    let right = processPoints (points, createRange points.Length, maxIndex, minIndex)\n   \n    (left |> List.rev |> List.tail |> List.rev) @ (right |> List.rev |> List.tail |> List.rev) \n \n/// <summary>\n/// Make a polygon from visible part of atom.\n/// </summary>\nlet makePolygon (currAtom : Atom) (intersectsWith : Atom list) (resolution : int) : Point2D list =\n    let sphere : Sphere = { Center = currAtom.Position; Radius = currAtom.Radius }\n    \n    let otherSpheres : Sphere list =\n        intersectsWith |> List.map (fun atom -> { Center = atom.Position; Radius = atom.Radius })\n        \n    let notInsideOtherSphere (point : Point3D) : bool =\n        otherSpheres |> List.forall (fun otherSphere -> otherSphere.Center.Dist point > otherSphere.Radius)\n        \n    // let quadrants : Point3D list list = sphere.PointsOnSphere resolution\n    //\n    // let points : Point2D list =\n    //     quadrants\n    //     |> List.map (fun quadrant -> quadrant |> List.filter notInsideOtherSphere)\n    //     |> List.head\n    //     |> List.map (fun point -> { X = point.X; Y = point.Y })\n    \n    let pointsOnSphere = sphere.PointsOnSphere resolution\n    \n    let points : Point2D list =\n        pointsOnSphere \n        |> List.filter notInsideOtherSphere\n        |> List.map (fun point -> { X = point.X; Y = point.Y })\n        \n    let indices : int list = quickHull2D points\n    indices |> List.map (fun i -> points[i])\n \n/// <summary>\n/// Driver code for translating atoms in molecule.\n/// </summary> \nlet atomToSvg (prevAtoms : Atom list) (currAtom : Atom) (resolution : int) (opacity : float) : Shape =\n    let currAtomGeom : Sphere = { Center = currAtom.Position; Radius = currAtom.Radius }\n    \n    let intersectsWith =\n        prevAtoms\n        |> List.filter (fun atom -> { Center = atom.Position; Radius = atom.Radius }.Intersects currAtomGeom)\n        \n    match intersectsWith with\n    | [] ->\n        let position : Point2D = { X = currAtom.Position.X; Y = currAtom.Position.Y }\n        Shape.Circle (currAtom.Index, currAtom.Color, { Center = position; Radius = currAtom.Radius }, opacity )\n        \n    | _ ->\n        let points : Point2D list = makePolygon currAtom intersectsWith resolution \n        Shape.Polygon (currAtom.Index, currAtom.Color, points, opacity)\n \n/// <summary>\n/// Driver code for translating bonds in molecule.\n/// </summary>\nlet calculatePerpendicularPoints (p1 : Point3D) (p2 : Point3D) (radius : float) (numPoints : int) : Point3D list =\n    let dx = p2.X - p1.X\n    let dy = p2.Y - p1.Y\n    let len = sqrt (dx ** 2.0 + dy ** 2.0)\n    let ux = dx / len\n    let uy = dy / len\n    let step = 2.0 * radius / float (numPoints - 1)\n    [\n        for i in 0 .. numPoints - 1 ->\n            let offset = float i * step - radius\n            { X = p1.X + offset * uy; Y = p1.Y - offset * ux; Z = p1.Z }\n    ]\n    \nlet drawSingleBond (width : float) (index1 : int) (index2 : int) (color1 : Color) (color2 : Color) (p1 : Point3D) (p2 : Point3D) (opacity1 : float) (opacity2 : float) : Shape list =\n    // Move p1 and p2 both a bit closer to each other, without using MoveTowards.\n    let p1 = p1 + (p2 - p1).Mul(0.3)\n    let p2 = p2 + (p1 - p2).Mul(0.3)\n   \n    let points1 = calculatePerpendicularPoints p1 p2 width 2\n    let midPoints = calculatePerpendicularPoints (p1.Midpoint p2) p2 width 2 \n    let points2 = calculatePerpendicularPoints p2 p1 width 2\n    \n    let b1, b2, b3, b4 : Point2D * Point2D * Point2D * Point2D =\n        match points1 @ (midPoints |> List.rev) with\n        | [ b1; b2; b3; b4 ] -> { X = b1.X; Y = b1.Y }, { X = b2.X; Y = b2.Y }, { X = b3.X; Y = b3.Y }, { X = b4.X; Y = b4.Y }\n        | _ -> { X = 0.0; Y = 0.0 }, { X = 0.0; Y = 0.0 }, { X = 0.0; Y = 0.0 }, { X = 0.0; Y = 0.0 } // TODO\n    \n    let b5, b6, b7, b8 : Point2D * Point2D * Point2D * Point2D =\n        match midPoints @ points2 with\n        | [ b5; b6; b7; b8 ] -> { X = b5.X; Y = b5.Y }, { X = b6.X; Y = b6.Y }, { X = b7.X; Y = b7.Y }, { X = b8.X; Y = b8.Y }\n        | _ -> { X = 0.0; Y = 0.0 }, { X = 0.0; Y = 0.0 }, { X = 0.0; Y = 0.0 }, { X = 0.0; Y = 0.0 } // TODO\n    \n    [ (index1, color1, b1, b2, b3, b4, opacity1) |> Shape.BondPolygon; (index2, color2, b5, b6, b7, b8, opacity2) |> Shape.BondPolygon ]\n\nlet bondToSvg (beginAtom : Atom) (endAtom : Atom) (bond : Bond) : Shape list =\n    // Most negative Z is p1, most positive Z is p2, midpoint is pMid.\n    let a1, a2 = if beginAtom.Position.Z > endAtom.Position.Z then endAtom, beginAtom else beginAtom, endAtom\n    let p1 = a1.Position\n    let p2 = a2.Position\n    \n    let index1, index2, opacity1, opacity2 =\n        match bond.BeginAtomIndex, bond.EndAtomIndex with\n        | x1, x2 when x1 = a1.Index && x2 = a2.Index -> bond.BeginIndex, bond.EndIndex, a1.Opacity, a2.Opacity\n        | x1, x2 when x1 = a2.Index && x2 = a1.Index -> bond.EndIndex, bond.BeginIndex, a2.Opacity, a1.Opacity\n        | _ -> 0, 0, 1.0, 1.0 // TODO: Catch this error properly.\n    \n    match bond.Type with\n    | Single | Aromatic -> drawSingleBond 0.2 index1 index2 a1.Color a2.Color p1 p2 opacity1 opacity2\n        \n    | Double ->\n        let radius = bond.Radius / 3.0\n        let points1 = calculatePerpendicularPoints p1 p2 radius 2\n        let points2 = calculatePerpendicularPoints p2 p1 radius 2 |> List.rev\n        drawSingleBond 0.1 index1 index2 a1.Color a2.Color points1[0] points2[0] opacity1 opacity2 @\n        drawSingleBond 0.1 index1 index2 a1.Color a2.Color points1[1] points2[1] opacity1 opacity2\n        \n    | Triple ->\n        let radius = bond.Radius / 3.0\n        let points1 = calculatePerpendicularPoints p1 p2 radius 3\n        let points2 = calculatePerpendicularPoints p2 p1 radius 3 |> List.rev\n        drawSingleBond 0.05 index1 index2 a1.Color a2.Color points1[0] points2[0] opacity1 opacity2 @\n        drawSingleBond 0.05 index1 index2 a1.Color a2.Color points1[1] points2[1] opacity1 opacity2 @\n        drawSingleBond 0.05 index1 index2 a1.Color a2.Color points1[2] points2[2] opacity1 opacity2\n        \nlet bondToWire (beginAtom : Atom) (endAtom : Atom) : Shape list =\n    // Most negative z is p1, most positive z is p2, midpoint is pMid.\n    let a1, a2 = if beginAtom.Position.Z > endAtom.Position.Z then endAtom, beginAtom else beginAtom, endAtom\n    let p1 = a1.Position\n    let p2 = a2.Position\n    let midPoint = p1.Midpoint p2\n    \n    let p1 : Point2D = { X = p1.X; Y = p1.Y }\n    let p2 : Point2D = { X = p2.X; Y = p2.Y }\n    let midPoint : Point2D = { X = midPoint.X; Y = midPoint.Y }\n    \n    // Index actually doesn't matter because the wire frame has a fixed style (since it's just lines).\n    [ (a1.Index, a1.Color, p1, midPoint, a1.Opacity) |> Shape.Line; (a2.Index, a2.Color, midPoint, p2, a2.Opacity) |> Shape.Line ]\n \n/// <summary>\n/// Driver code for creating SVG for molecule.\n/// </summary>\nlet draw (mol: Molecule) (options: DrawingOptions) : SVG * DrawingOptions =\n    // Set origin.\n    let origin = Axis.Origin()\n    \n    // Set view box.\n    let viewBox  =\n        let margin = 5.0\n        \n        let offset =\n            mol.Atoms\n            |> List.map (fun atom -> atom.Position.Dist origin)\n            |> List.max\n            |> (+) margin\n            \n        let viewBox =\n            match options.ViewBox with\n            | Some viewBox -> viewBox\n            | None ->\n                { MinX = -offset\n                  MinY = -offset\n                  Width = offset * 2.0\n                  Height = offset * 2.0 }\n                \n        viewBox\n        \n    // Drawing style dictates if and how the objects are clipped and exactly drawn.\n    let objs : Shape list =\n        \n        // Filter out hydrogen atoms.\n        let atoms =\n            match options.DisplayHydrogenAtoms with\n            | true -> mol.Atoms\n            | false -> mol.Atoms |> List.filter (fun atom -> atom.Type <> AtomType.H)\n        \n        match options.ModelStyle with        \n        | SpaceFilling ->\n            let atoms = atoms |> List.sortBy (fun atom -> atom.Position.Z) |> List.rev\n    \n            let rec processAtoms (prevAtoms : Atom list) (shapes : Shape list) : Shape list =\n                match prevAtoms with\n                | [] -> shapes\n                | currAtom :: prevAtoms ->\n                    let shape : Shape = atomToSvg prevAtoms currAtom options.Resolution currAtom.Opacity \n                    processAtoms prevAtoms (shape :: shapes)\n                    \n            match atoms with\n            | [] -> []\n            | atoms -> processAtoms atoms []\n            \n        | BallAndStick ->\n            let atoms = atoms |> List.sortBy (fun atom -> atom.Position.Z) |> List.rev\n            \n            // BallAndStick has smaller atom radii.\n            let atomRadiusCorrection = 0.3\n            let atoms = atoms |> List.map (fun atom -> { atom with Radius = atom.Radius * atomRadiusCorrection })\n            \n            let rec processAtoms (prevAtoms : Atom list) (shapes : Shape list) : Shape list =\n                match prevAtoms with\n                | [] -> shapes\n                | currAtom :: prevAtoms ->\n                    let shape : Shape = atomToSvg prevAtoms currAtom options.Resolution currAtom.Opacity\n                    \n                    // Get bonds connected to atoms that have not yet been converted to an SVG shape.\n                    let prevAtomIndices : int list = prevAtoms |> List.map (fun atom -> atom.Index)\n                    let bondsToDraw =\n                        mol.GetBonds options.DisplayHydrogenAtoms currAtom.Index\n                        |> List.filter (fun bond ->\n                            not (prevAtomIndices |> List.contains bond.BeginAtomIndex)\n                            && not (prevAtomIndices |> List.contains bond.EndAtomIndex))\n                        \n                    // Convert bonds to SVG shapes.\n                    let bondShapes : Shape list =\n                        bondsToDraw\n                        |> List.map (fun bond ->\n                            let beginAtom = mol.GetAtom bond.BeginAtomIndex\n                            let endAtom = mol.GetAtom bond.EndAtomIndex\n                            match beginAtom, endAtom with\n                            | Some b, Some e ->\n                                let b = { b with Radius = b.Radius * atomRadiusCorrection }\n                                let e = { e with Radius = e.Radius * atomRadiusCorrection }\n                                bondToSvg b e bond  \n                            | _ -> [])\n                        |> List.concat\n                    \n                    processAtoms prevAtoms (shape :: bondShapes @ shapes)\n            \n            match atoms with\n            | [] -> []\n            | atoms -> processAtoms atoms []\n            \n        | WireFrame ->\n            let atoms = atoms |> List.sortBy (fun atom -> atom.Position.Z) |> List.rev\n            \n            let rec processAtoms (prevAtoms : Atom list) (shapes : Shape list) : Shape list =\n                match prevAtoms with\n                | [] -> shapes\n                | currAtom :: prevAtoms ->\n                    \n                    // Get bonds connected to atoms that have not yet been converted to an SVG shape.\n                    let prevAtomIndices : int list = prevAtoms |> List.map (fun atom -> atom.Index)\n                    let bondsToDraw =\n                        mol.GetBonds options.DisplayHydrogenAtoms currAtom.Index\n                        |> List.filter (fun bond ->\n                            not (prevAtomIndices |> List.contains bond.BeginAtomIndex)\n                            && not (prevAtomIndices |> List.contains bond.EndAtomIndex))\n                        \n                    // Convert bonds to SVG shapes.\n                    let bondShapes : Shape list =\n                        bondsToDraw\n                        |> List.map (fun bond ->\n                            let beginAtom = mol.GetAtom bond.BeginAtomIndex\n                            let endAtom = mol.GetAtom bond.EndAtomIndex\n                            match beginAtom, endAtom with\n                            | Some b, Some e -> bondToWire b e  \n                            | _ -> [])\n                        |> List.concat\n                    \n                    processAtoms prevAtoms (bondShapes @ shapes)\n            \n            match atoms with\n            | [] -> []\n            | atoms -> processAtoms atoms []\n\n    { Header = Header.New(); ID = \"model\"; ViewBox = viewBox; Objects = objs; Style = options.ArtStyle }, options           ","module CineMol.Encoding\n\ntype Encoding = | ISO_8859_1\n    with\n    member this.EncodeChar c =\n        // Pick encoding type.\n        match this with\n\n        // Base64 encode character according to ISO 8859-1.\n        | ISO_8859_1 ->\n            match c with\n            | '\\t'  | '\\n'  | ' '  -> Some 32uy\n            | '!'  -> Some 33uy  | '\"'  -> Some 34uy  | '#'  -> Some 35uy\n            | '$'  -> Some 36uy  | '%'  -> Some 37uy  | '&'  -> Some 38uy\n            | '''  -> Some 39uy  | '('  -> Some 40uy  | ')'  -> Some 41uy\n            | '*'  -> Some 42uy  | '+'  -> Some 43uy  | ','  -> Some 44uy\n            | '-'  -> Some 45uy  | '.'  -> Some 46uy  | '/'  -> Some 47uy\n            | '0'  -> Some 48uy  | '1'  -> Some 49uy  | '2'  -> Some 50uy\n            | '3'  -> Some 51uy  | '4'  -> Some 52uy  | '5'  -> Some 53uy\n            | '6'  -> Some 54uy  | '7'  -> Some 55uy  | '8'  -> Some 56uy\n            | '9'  -> Some 57uy  | ':'  -> Some 58uy  | ';'  -> Some 59uy\n            | '<'  -> Some 60uy  | '='  -> Some 61uy  | '>'  -> Some 62uy\n            | '?'  -> Some 63uy  | '@'  -> Some 64uy  | 'A'  -> Some 65uy\n            | 'B'  -> Some 66uy  | 'C'  -> Some 67uy  | 'D'  -> Some 68uy\n            | 'E'  -> Some 69uy  | 'F'  -> Some 70uy  | 'G'  -> Some 71uy\n            | 'H'  -> Some 72uy  | 'I'  -> Some 73uy  | 'J'  -> Some 74uy\n            | 'K'  -> Some 75uy  | 'L'  -> Some 76uy  | 'M'  -> Some 77uy\n            | 'N'  -> Some 78uy  | 'O'  -> Some 79uy  | 'P'  -> Some 80uy\n            | 'Q'  -> Some 81uy  | 'R'  -> Some 82uy  | 'S'  -> Some 83uy\n            | 'T'  -> Some 84uy  | 'U'  -> Some 85uy  | 'V'  -> Some 86uy\n            | 'W'  -> Some 87uy  | 'X'  -> Some 88uy  | 'Y'  -> Some 89uy\n            | 'Z'  -> Some 90uy  | '['  -> Some 91uy  | '\\\\' -> Some 92uy\n            | ']'  -> Some 93uy  | '^'  -> Some 94uy  | '_'  -> Some 95uy\n            | '`'  -> Some 96uy  | 'a'  -> Some 97uy  | 'b'  -> Some 98uy\n            | 'c'  -> Some 99uy  | 'd'  -> Some 100uy | 'e'  -> Some 101uy\n            | 'f'  -> Some 102uy | 'g'  -> Some 103uy | 'h'  -> Some 104uy\n            | 'i'  -> Some 105uy | 'j'  -> Some 106uy | 'k'  -> Some 107uy\n            | 'l'  -> Some 108uy | 'm'  -> Some 109uy | 'n'  -> Some 110uy\n            | 'o'  -> Some 111uy | 'p'  -> Some 112uy | 'q'  -> Some 113uy\n            | 'r'  -> Some 114uy | 's'  -> Some 115uy | 't'  -> Some 116uy\n            | 'u'  -> Some 117uy | 'v'  -> Some 118uy | 'w'  -> Some 119uy\n            | 'x'  -> Some 120uy | 'y'  -> Some 121uy | 'z'  -> Some 122uy\n            | '{'  -> Some 123uy | '|'  -> Some 124uy | '}'  -> Some 125uy\n            | '~'  -> Some 126uy\n            | c ->\n                printf $\"Unexpected char for ISO 8859-1 encoding: '{c}'\"\n                None\n\n    member this.Encode (src: string) =\n        src\n        |> Seq.toArray\n        |> Array.map (fun c -> this.EncodeChar c)\n        |> Array.choose id // We drop unexpected characters.","import { FSharpRef } from \"./Types.js\";\nexport function tryParse(str, defValue) {\n    // TODO: test if value is valid and in range\n    if (str != null && /\\S/.test(str)) {\n        const v = +str.replace(\"_\", \"\");\n        if (!Number.isNaN(v)) {\n            defValue.contents = v;\n            return true;\n        }\n    }\n    return false;\n}\nexport function parse(str) {\n    const defValue = new FSharpRef(0);\n    if (tryParse(str, defValue)) {\n        return defValue.contents;\n    }\n    else {\n        throw new Error(\"Input string was not in a correct format.\");\n    }\n}\n// JS Number.isFinite function evals false for NaN\nexport function isInfinity(x) {\n    return x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY;\n}\n","// export type decimal = Decimal;\nexport var NumberStyles;\n(function (NumberStyles) {\n    // None = 0x00000000,\n    // AllowLeadingWhite = 0x00000001,\n    // AllowTrailingWhite = 0x00000002,\n    // AllowLeadingSign = 0x00000004,\n    // AllowTrailingSign = 0x00000008,\n    // AllowParentheses = 0x00000010,\n    // AllowDecimalPoint = 0x00000020,\n    // AllowThousands = 0x00000040,\n    // AllowExponent = 0x00000080,\n    // AllowCurrencySymbol = 0x00000100,\n    NumberStyles[NumberStyles[\"AllowHexSpecifier\"] = 512] = \"AllowHexSpecifier\";\n    // Integer = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign,\n    // HexNumber = AllowLeadingWhite | AllowTrailingWhite | AllowHexSpecifier,\n    // Number = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign |\n    //          AllowTrailingSign | AllowDecimalPoint | AllowThousands,\n    // Float = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign |\n    //         AllowDecimalPoint | AllowExponent,\n    // Currency = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign | AllowTrailingSign |\n    //            AllowParentheses | AllowDecimalPoint | AllowThousands | AllowCurrencySymbol,\n    // Any = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign | AllowTrailingSign |\n    //       AllowParentheses | AllowDecimalPoint | AllowThousands | AllowCurrencySymbol | AllowExponent,\n})(NumberStyles || (NumberStyles = {}));\nfunction validResponse(regexMatch, radix) {\n    const [/*all*/ , sign, prefix, digits] = regexMatch;\n    return {\n        sign: sign || \"\",\n        prefix: prefix || \"\",\n        digits,\n        radix,\n    };\n}\nfunction getRange(unsigned, bitsize) {\n    switch (bitsize) {\n        case 8: return unsigned ? [0, 255] : [-128, 127];\n        case 16: return unsigned ? [0, 65535] : [-32768, 32767];\n        case 32: return unsigned ? [0, 4294967295] : [-2147483648, 2147483647];\n        default: throw new Error(\"Invalid bit size.\");\n    }\n}\nfunction getInvalidDigits(radix) {\n    switch (radix) {\n        case 2: return /[^0-1]/;\n        case 8: return /[^0-7]/;\n        case 10: return /[^0-9]/;\n        case 16: return /[^0-9a-fA-F]/;\n        default:\n            throw new Error(\"Invalid Base.\");\n    }\n}\nfunction getRadix(prefix, style) {\n    if (style & NumberStyles.AllowHexSpecifier) {\n        return 16;\n    }\n    else {\n        switch (prefix) {\n            case \"0b\":\n            case \"0B\": return 2;\n            case \"0o\":\n            case \"0O\": return 8;\n            case \"0x\":\n            case \"0X\": return 16;\n            default: return 10;\n        }\n    }\n}\nexport function isValid(str, style, radix) {\n    const integerRegex = /^\\s*([\\+\\-])?(0[xXoObB])?([0-9a-fA-F]+)\\s*$/;\n    const res = integerRegex.exec(str.replace(/_/g, \"\"));\n    if (res != null) {\n        const [/*all*/ , /*sign*/ , prefix, digits] = res;\n        radix = radix || getRadix(prefix, style);\n        const invalidDigits = getInvalidDigits(radix);\n        if (!invalidDigits.test(digits)) {\n            return validResponse(res, radix);\n        }\n    }\n    return null;\n}\nexport function parse(str, style, unsigned, bitsize, radix) {\n    const res = isValid(str, style, radix);\n    if (res != null) {\n        let v = Number.parseInt(res.sign + res.digits, res.radix);\n        if (!Number.isNaN(v)) {\n            const [umin, umax] = getRange(true, bitsize);\n            if (!unsigned && res.radix !== 10 && v >= umin && v <= umax) {\n                v = v << (32 - bitsize) >> (32 - bitsize);\n            }\n            const [min, max] = getRange(unsigned, bitsize);\n            if (v >= min && v <= max) {\n                return v;\n            }\n        }\n    }\n    throw new Error(\"Input string was not in a correct format.\");\n}\nexport function tryParse(str, style, unsigned, bitsize, defValue) {\n    try {\n        defValue.contents = parse(str, style, unsigned, bitsize);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexport function op_UnaryNegation_Int8(x) {\n    return x === -128 ? x : -x;\n}\nexport function op_UnaryNegation_Int16(x) {\n    return x === -32768 ? x : -x;\n}\nexport function op_UnaryNegation_Int32(x) {\n    return x === -2147483648 ? x : -x;\n}\nexport function divRem(x, y, out) {\n    const div = ~~(x / y);\n    const rem = x % y;\n    if (out != null) {\n        out.contents = rem;\n        return div;\n    }\n    else {\n        return [div, rem];\n    }\n}\n","module CineMol.Parsing\n\nopen System.Text.RegularExpressions\nopen Helpers\nopen Style \nopen Types.Geometry\nopen Types.Chem\n\n/// <summary>\n/// Supported file types for parsing molecule structures from.\n/// </summary>\nexception ParserError of string \n\n/// <summary>\n/// Supported file types for parsing molecule structures from.\n/// </summary>\ntype FileType = | Sdf\n\n/// <summary>\n/// Parse input file containing molecule structures.\n/// </summary> \ntype FileParser = FileParser of FileType \n    with\n    member this.Parse (fileContent: string) : Molecule list option =\n        match (match this with | FileParser fileType -> fileType) with\n        \n        // TODO: check if file type corresponds with file extension and contents of file\n        // TODO: limit file size for uploading\n        \n        // Parse molecules from SDF file.\n        | Sdf ->\n            /// Defines regex for whitespace.\n            let s = @\"\\s{1,}\"\n            \n            /// Defines regex for floating point value.\n            let d = @\"[-+]?[0-9]*\\.?[0-9]+\"\n            \n            /// Defines regex for captured floating point value.\n            let d_cap = $\"({d})\"\n            \n            /// Defines regex for captured word.\n            let w_cap = @\"(\\w+)\"\n            \n            /// Constructs regex for atom line in input file.\n            let atomLine : string =\n                [ \"$\" ]\n                |> (@) [ for _ in [ 0 .. 11 ] do yield s + d ]\n                |> (@) [ s + w_cap]\n                |> (@) [ for _ in [ 0 .. 2 ] do yield s + d_cap ]\n                |> (@) [ \"^\" ]\n                |> String.concat \"\"\n                \n            /// Constructs regex for bond line in input file.\n            let bondLine : string =\n                [ \"$\" ]\n                |> (@) [ for _ in [ 0 .. 3 ] do yield s + d ]\n                |> (@) [ for _ in [ 0 .. 2 ] do yield s + d_cap ]\n                |> (@) [ \"^\" ]\n                |> String.concat \"\"\n            \n            /// Active pattern for matching and parsing atom line in input file.\n            let (|AtomLine|_|) (line: string) : string list option =\n                let m = Regex.Match(line, atomLine)\n                if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])\n                else None\n            \n            /// Constructs regex for matching and parsing bond line in input file.\n            let (|BondLine|_|) (line: string) : string list option =\n                let m = Regex.Match(line, bondLine)\n                if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])\n                else None\n            \n            /// Parse input file.\n            let mutable count = 0\n            let mutable atoms: Atom list = []\n            let mutable bonds: Bond list = []\n            \n            [\n                for line in fileContent.Split [| '\\n' |] do\n                    match line with\n                    \n                    // Molecule structure delimiter.\n                    | line when line.Contains(\"$$$$\") = true ->\n                        yield { Atoms = atoms; Bonds = bonds }\n                        \n                        count <- count + 1\n                        atoms <- []\n                        bonds <- []\n                    \n                    // Atom line.\n                    | AtomLine [ x; y; z; atomSymbol ] ->\n                        match\n                            tryCast float x,\n                            tryCast float y,\n                            tryCast float z,\n                            AtomType.FromString atomSymbol\n                            with\n                        \n                        // Able to cast all data to appropriate types.\n                        | Some x, Some y, Some z, Some atomType ->\n                            let atom : Atom =\n                                { Index = atoms.Length + (bonds.Length * 2) + 1\n                                  Type = atomType\n                                  Color = CPK.Color atomType\n                                  Opacity = 1.0\n                                  Position = { X = x; Y = y; Z = z }\n                                  Radius = PubChem.Radius atomType }\n\n                            atoms <- atoms @ [ atom ]\n                        \n                        // Unable to cast all data to appropriate types.\n                        | _ ->\n                            $\"Unable to parse atom line: '{line}'\"\n                            |> ParserError |> raise \n                    \n                    // Bond line.\n                    | BondLine [ s_idx; e_idx; bondType ] ->\n                        match\n                            tryCast int s_idx,\n                            tryCast int e_idx,\n                            BondType.FromString bondType\n                            with\n                        \n                        // Able to cast all data to appropriate types.\n                        | Some s_idx, Some e_idx, Some bondType ->\n                            let bond : Bond =\n                                { BeginIndex = atoms.Length + (bonds.Length * 2) + 1\n                                  EndIndex = atoms.Length + (bonds.Length * 2) + 2\n                                  Type = bondType\n                                  BeginAtomIndex = s_idx\n                                  EndAtomIndex = e_idx\n                                  Opacity = None \n                                  Color = None\n                                  Radius = 0.5 }\n\n                            bonds <- bonds @ [ bond ]  \n                        \n                        // Unable to cast all data to appropriate types.\n                        | _ ->\n                            $\"Unable to parse bond line: '{line}'\"\n                            |> ParserError |> raise \n                    \n                    // Skip other lines.\n                    | _ -> ()\n                    \n            ]\n            |> List.map (fun mol -> mol.AdjustForCentroid())\n            |> Some ","module CineMol.Style\n\nopen CineMol.Types\nopen CineMol.Types.Chem\n\ntype AtomColorStyle =\n    \n    // Corey-Pauling-Koltun coloring convention for atoms.\n    // Source: https://en.wikipedia.org/wiki/CPK_coloring  \n    | CPK\n    \n    with\n    member this.Color (atomType: AtomType) =\n        match atomType with\n        | H                           -> 255, 255, 255 // White\n        | C                           ->  48,  48,  48 // Not quite black (need non-zero values to able to diffuse)\n        | N                           ->   0,   0, 255 // Blue\n        | O                           -> 255,   0,   0 // Red\n        | P                           -> 255, 165,   0 // Orange\n        | S                           -> 255, 255,   0 // Yellow\n        | B                           -> 245, 245, 220 // Beige\n        | Br                          -> 139,   0,   0 // Dark red\n        | I                           -> 148,   0, 211 // Dark violet\n        | Ti                          -> 128, 128, 128 // Grey\n        | Fe                          -> 255, 140,   0 // Dark orange\n        | F  | Cl                     ->   0, 128,   0 // Green\n        | He | Ne | Ar | Kr | Xe      ->   0, 255, 255 // Cyan\n        | Li | Na | K  | Rb | Cs | Fr -> 238, 130, 238 // Violet\n        | Be | Mg | Ca | Sr | Ba | Ra ->   0, 100,   0 // Dark green\n        | _                           -> 255, 192, 203 // Pink \n        |> Color\n        \ntype AtomRadius =\n    \n    // Atomic radii (van der Waals) in pm from PubChem.\n    // Source: https://pubchem.ncbi.nlm.nih.gov/periodic-table/#property=AtomicRadius \n    | PubChem\n    \n    with\n    member this.Radius (atomType: AtomType) =\n        match atomType with\n        | H  -> 120.0 | He -> 140.0 | Li -> 182.0 | Be -> 153.0 | B  -> 192.0 | C  -> 170.0\n        | N  -> 155.0 | O  -> 152.0 | F  -> 135.0 | Ne -> 154.0 | Na -> 227.0 | Mg -> 173.0\n        | Al -> 184.0 | Si -> 210.0 | P  -> 180.0 | S  -> 180.0 | Cl -> 175.0 | Ar -> 188.0\n        | K  -> 275.0 | Ca -> 231.0 | Sc -> 211.0 | Ti -> 187.0 | V  -> 179.0 | Cr -> 189.0\n        | Mn -> 197.0 | Fe -> 194.0 | Co -> 192.0 | Ni -> 163.0 | Cu -> 140.0 | Zn -> 139.0\n        | Ga -> 187.0 | Ge -> 211.0 | As -> 185.0 | Se -> 190.0 | Br -> 183.0 | Kr -> 202.0\n        | Rb -> 303.0 | Sr -> 249.0 | Y  -> 219.0 | Zr -> 186.0 | Nb -> 207.0 | Mo -> 209.0\n        | Tc -> 209.0 | Ru -> 207.0 | Rh -> 195.0 | Pd -> 202.0 | Ag -> 172.0 | Cd -> 158.0\n        | In -> 193.0 | Sn -> 217.0 | Sb -> 206.0 | Te -> 206.0 | I  -> 198.0 | Xe -> 216.0\n        | Cs -> 343.0 | Ba -> 268.0 | Lu -> 221.0 | Hf -> 212.0 | Ta -> 217.0 | W  -> 210.0\n        | Re -> 217.0 | Os -> 216.0 | Ir -> 202.0 | Pt -> 209.0 | Au -> 166.0 | Hg -> 209.0\n        | Tl -> 196.0 | Pb -> 202.0 | Bi -> 207.0 | Po -> 197.0 | At -> 202.0 | Rn -> 220.0\n        | Fr -> 348.0 | Ra -> 283.0\n        |> (fun v -> v / 100.0) // Adjust picometer to Angstrom. ","namespace Fable.FontAwesome\n\nopen Fable.Core\nopen Fable.React\nopen Fable.React.Props\n\nmodule internal Helpers =\n\n    let classes std (options : string option list) (booleans: (string * bool) list) =\n        let std = (std, options) ||> List.fold (fun complete opt ->\n            match opt with Some name -> complete + \" \" + name | None -> complete)\n        (std, booleans) ||> List.fold (fun complete (name, flag) ->\n            if flag then complete + \" \" + name else complete)\n        |> ClassName :> IHTMLProp\n\n[<RequireQualifiedAccess>]\nmodule Fa =\n\n    module Classes =\n        module Size =\n            let [<Literal>] FaExtraSmall = \"fa-xs\"\n            let [<Literal>] FaSmall = \"fa-sm\"\n            let [<Literal>] FaLarge = \"fa-lg\"\n            let [<Literal>] Fa2x = \"fa-2x\"\n            let [<Literal>] Fa3x = \"fa-3x\"\n            let [<Literal>] Fa4x = \"fa-4x\"\n            let [<Literal>] Fa5x = \"fa-5x\"\n            let [<Literal>] Fa6x = \"fa-6x\"\n            let [<Literal>] Fa7x = \"fa-7x\"\n            let [<Literal>] Fa8x = \"fa-8x\"\n            let [<Literal>] Fa9x = \"fa-9x\"\n            let [<Literal>] Fa10 = \"fa-10x\"\n\n        module Style =\n            let [<Literal>] FixedWidth = \"fa-fw\"\n            let [<Literal>] IsLi = \"fa-li\"\n            let [<Literal>] Border = \"fa-border\"\n            let [<Literal>] Inverse = \"fa-inverse\"\n\n        module Rotations =\n            let [<Literal>] Rotate90 = \"fa-rotate-90\"\n            let [<Literal>] Rotate180 = \"fa-rotate-180\"\n            let [<Literal>] Rotate270 = \"fa-rotate-270\"\n\n        module Flips =\n            let [<Literal>] Horizontal = \"fa-flip-horizontal\"\n            let [<Literal>] Vertical = \"fa-flip-vertical\"\n\n        module Animations =\n            let [<Literal>] Spin = \"fa-spin\"\n            let [<Literal>] Pulse = \"fa-pulse\"\n\n        module Pull =\n            let [<Literal>] Right = \"fa-pull-right\"\n            let [<Literal>] Left = \"fa-pull-left\"\n\n        module Stack =\n\n            let [<Literal>] Container = \"fa-stack\"\n\n            module Size =\n                let [<Literal>] Fa1x = \"fa-stack-1x\"\n                let [<Literal>] Fa2x = \"fa-stack-2x\"\n\n    type ISize =\n        | FaExtraSmall\n        | FaSmall\n        | FaLarge\n        | Fa2x\n        | Fa3x\n        | Fa4x\n        | Fa5x\n        | Fa6x\n        | Fa7x\n        | Fa8x\n        | Fa9x\n        | Fa10\n\n    type IconOption =\n        | Size of ISize\n        | Border\n        | PullLeft\n        | PullRight\n        | Inverse\n        | Rotate90\n        | Rotate180\n        | Rotate270\n        | FlipHorizontal\n        | FlipVertical\n        | IsLi\n        | Icon of string\n        | Spin\n        | Pulse\n        | Props of IHTMLProp list\n        | CustomClass of string\n        | FixedWidth\n        | Stack1x\n        | Stack2x\n\n    let internal ofSize (size : ISize) =\n        match size with\n        | FaExtraSmall -> Classes.Size.FaExtraSmall\n        | FaSmall -> Classes.Size.FaSmall\n        | FaLarge -> Classes.Size.FaLarge\n        | Fa2x -> Classes.Size.Fa2x\n        | Fa3x -> Classes.Size.Fa3x\n        | Fa4x -> Classes.Size.Fa4x\n        | Fa5x -> Classes.Size.Fa5x\n        | Fa6x -> Classes.Size.Fa6x\n        | Fa7x -> Classes.Size.Fa7x\n        | Fa8x -> Classes.Size.Fa8x\n        | Fa9x -> Classes.Size.Fa9x\n        | Fa10 -> Classes.Size.Fa10\n\n    type IconOptions =\n        { Icon : string option\n          Size : string option\n          Border : string option\n          Pull : string option\n          HaveSpin : bool\n          HavePulse : bool\n          Rotation : string option\n          Flip : string option\n          IsInverse : bool\n          Props : IHTMLProp list\n          FixedWidth : bool\n          IsLi : bool\n          StackSize : string option\n          CustomClass : string option }\n\n        static member Empty =\n            { Icon = None\n              Size = None\n              Border = None\n              Pull = None\n              HaveSpin = false\n              HavePulse = false\n              Rotation = None\n              Flip = None\n              IsInverse = false\n              Props = [ ]\n              FixedWidth = false\n              IsLi = false\n              StackSize = None\n              CustomClass = None }\n\n    let toIconOptions (faOptions: IconOption list) =\n        let parseOptions (result: IconOptions) (option: IconOption) =\n            match option with\n            | Size s ->\n                { result with Size = ofSize s |> Some }\n            | Border ->\n                { result with Border = Some Classes.Style.Border }\n            | PullLeft ->\n                { result with Pull = Some Classes.Pull.Left }\n            | PullRight ->\n                { result with Pull = Some Classes.Pull.Right }\n            | Inverse ->\n                { result with IsInverse = true }\n            | Icon faIcon ->\n                { result with Icon = faIcon |> Some }\n            | Rotate90 ->\n                { result with Rotation = Classes.Rotations.Rotate90 |> Some }\n            | Rotate180 ->\n                { result with Rotation = Classes.Rotations.Rotate180 |> Some }\n            | Rotate270 ->\n                { result with Rotation = Classes.Rotations.Rotate270 |> Some }\n            | FlipHorizontal ->\n                { result with Rotation = Classes.Flips.Horizontal |> Some }\n            | FlipVertical ->\n                { result with Rotation = Classes.Flips.Vertical |> Some }\n            | Spin ->\n                { result with HaveSpin = true }\n            | Pulse ->\n                { result with HavePulse = true }\n            | Props props ->\n                { result with Props = props }\n            | FixedWidth ->\n                { result with FixedWidth = true }\n            | IsLi ->\n                { result with IsLi = true }\n            | CustomClass customClass ->\n                { result with CustomClass = Some customClass }\n            | Stack1x ->\n                { result with StackSize = Some Classes.Stack.Size.Fa1x }\n            | Stack2x ->\n                { result with StackSize = Some Classes.Stack.Size.Fa2x }\n\n        faOptions |> List.fold parseOptions IconOptions.Empty\n\n    /// Logic used to display one icon alone or as one item in an unordered list:\n    let internal displayIcon baseElement baseClass (opts: IconOptions) children  =\n        let classes =\n            Helpers.classes baseClass\n                [ opts.Icon\n                  opts.Size\n                  opts.Border\n                  opts.Pull\n                  opts.Rotation\n                  opts.Flip\n                  opts.CustomClass\n                  opts.StackSize ]\n                [ Classes.Style.FixedWidth, opts.FixedWidth\n                  Classes.Style.IsLi, opts.IsLi\n                  Classes.Animations.Pulse, opts.HavePulse\n                  Classes.Animations.Spin, opts.HaveSpin\n                  Classes.Style.Inverse, opts.IsInverse ]\n\n        baseElement (classes::opts.Props)\n          children\n\n    let ul props children =\n        ul [ ClassName \"fa-ul\" ]\n            children\n\n    let ol props children =\n        ol [ ClassName \"fa-ul\" ]\n            children\n\n    let i (faOptions: IconOption list) children =\n        let opts = toIconOptions faOptions\n        displayIcon i \"\" opts children\n\n    let span (faOptions: IconOption list) children =\n        let opts = toIconOptions faOptions\n        displayIcon span \"\" opts children\n\n    module Stack =\n        type Option =\n            | Size of ISize\n            | CustomClass of string\n            | Props of IHTMLProp list\n\n        type internal Options =\n            { Size : string option\n              Props : IHTMLProp list\n              CustomClass : string option }\n\n            static member Empty =\n                { Size = None\n                  Props = [ ]\n                  CustomClass = None }\n\n\n    let stack options children =\n        let parseOption (result : Stack.Options) opt =\n            match opt with\n            | Stack.Size size ->\n                { result with Size = ofSize size |> Some }\n            | Stack.CustomClass customClass ->\n                { result with CustomClass = Some customClass }\n            | Stack.Props props ->\n                { result with Props = props }\n\n        let opts = options |> List.fold parseOption Stack.Options.Empty\n        let classes = Helpers.classes\n                        Classes.Stack.Container\n                        ( opts.Size\n                            :: opts.CustomClass\n                            :: [] )\n                        [ ]\n\n        Fable.React.Standard.span (classes::opts.Props)\n            children\n","module Feliz.Bulma.ElementBuilders\r\n\r\nopen Feliz\r\nopen Feliz.Bulma\r\n\r\nmodule Helpers =\r\n    let [<Literal>] private ClassName = \"className\"\r\n\r\n    let inline internal getClasses (xs:IReactProperty list) =\r\n        xs\r\n        |> List.choose (unbox<string * obj> >> function\r\n            | (k, v) when k = ClassName -> Some (string v)\r\n            | _ -> None)\r\n\r\n    let extractClasses (xs:IReactProperty list) =\r\n        xs\r\n        |> List.rev\r\n        |> List.fold (fun (classes, props) x ->\r\n            match unbox<string * obj> x with\r\n            | (k, v) when k = ClassName -> string v :: classes, props\r\n            | _ -> classes, x :: props) ([], [])\r\n\r\n    let combineClasses cn (xs:IReactProperty list) =\r\n        xs\r\n        |> extractClasses\r\n        |> fun (classes, props) -> (cn :: classes |> prop.classes) :: props\r\n\r\nmodule Div =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.div (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.div [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n    let inline valueStr (cn:string) (value:string) = Html.div [ prop.className cn; prop.text value ]\r\n    let inline valueInt (cn:string) (value:int) = Html.div [ prop.className cn; prop.text value ]\r\n\r\nmodule Nav =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.nav (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.nav [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n\r\nmodule Article =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.article (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.article [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n\r\nmodule Section =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.section (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.section [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n\r\nmodule Footer =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.footer (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.footer [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n\r\nmodule Label =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.label (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.label [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n    let inline valueStr (cn:string) (value:string) = Html.label [ prop.className cn; prop.text value ]\r\n    let inline valueInt (cn:string) (value:int) = Html.label [ prop.className cn; prop.text value ]\r\n\r\nmodule Input =\r\n    let inline propsWithType (cn:string) (typ: IReactProperty) (xs:IReactProperty list) =\r\n        Html.input (typ :: Helpers.combineClasses cn xs)\r\n\r\nmodule Textarea =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.textarea (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.textarea [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n\r\nmodule Button =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.button (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.button [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n    let inline valueStr (cn:string) (value:string) = Html.button [ prop.className cn; prop.text value ]\r\n    let inline valueInt (cn:string) (value:int) = Html.button [ prop.className cn; prop.text value ]\r\n\r\nmodule Span =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.span (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.span [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n    let inline valueStr (cn:string) (value:string) = Html.span [ prop.className cn; prop.text value ]\r\n    let inline valueInt (cn:string) (value:int) = Html.span [ prop.className cn; prop.text value ]\r\n\r\nmodule Figure =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.figure (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.figure [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n\r\nmodule Progress =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.progress (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.progress [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n    let inline valueStr (cn:string) (value:string) = Html.progress [ prop.className cn; prop.text value ]\r\n    let inline valueInt (cn:string) (value:int) = Html.progress [ prop.className cn; prop.text value ]\r\n\r\nmodule Table =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.table (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.table [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n\r\nmodule H1 =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.h1 (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.h1 [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n    let inline valueStr (cn:string) (value:string) = Html.h1 [ prop.className cn; prop.text value ]\r\n    let inline valueInt (cn:string) (value:int) = Html.h1 [ prop.className cn; prop.text value ]\r\n\r\nmodule H2 =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.h2 (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.h2 [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n    let inline valueStr (cn:string) (value:string) = Html.h2 [ prop.className cn; prop.text value ]\r\n    let inline valueInt (cn:string) (value:int) = Html.h2 [ prop.className cn; prop.text value ]\r\n\r\nmodule H3 =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.h3 (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.h3 [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n    let inline valueStr (cn:string) (value:string) = Html.h3 [ prop.className cn; prop.text value ]\r\n    let inline valueInt (cn:string) (value:int) = Html.h3 [ prop.className cn; prop.text value ]\r\n\r\nmodule H4 =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.h4 (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.h4 [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n    let inline valueStr (cn:string) (value:string) = Html.h4 [ prop.className cn; prop.text value ]\r\n    let inline valueInt (cn:string) (value:int) = Html.h4 [ prop.className cn; prop.text value ]\r\n\r\nmodule H5 =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.h5 (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.h5 [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n    let inline valueStr (cn:string) (value:string) = Html.h5 [ prop.className cn; prop.text value ]\r\n    let inline valueInt (cn:string) (value:int) = Html.h5 [ prop.className cn; prop.text value ]\r\n\r\nmodule H6 =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.h6 (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.h6 [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n    let inline valueStr (cn:string) (value:string) = Html.h6 [ prop.className cn; prop.text value ]\r\n    let inline valueInt (cn:string) (value:int) = Html.h6 [ prop.className cn; prop.text value ]\r\n\r\nmodule Hr =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.hr (Helpers.combineClasses cn xs)\r\n\r\nmodule Aside =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.aside (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.aside [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n\r\nmodule P =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.p (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.p [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n    let inline valueStr (cn:string) (value:string) = Html.p [ prop.className cn; prop.text value ]\r\n    let inline valueInt (cn:string) (value:int) = Html.p [ prop.className cn; prop.text value ]\r\n\r\nmodule Ul =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.ul (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.ul [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n\r\nmodule Li =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.li (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.li [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n\r\nmodule Header =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.header (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.header [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n\r\nmodule A =\r\n    let inline props (cn:string) (xs:IReactProperty list) = Html.a (Helpers.combineClasses cn xs)\r\n    let inline children (cn:string) (children:seq<ReactElement>) = Html.a [ prop.className cn; prop.children children ]\r\n    let inline valueElm (cn:string) (value:ReactElement) = value |> List.singleton |> children cn\r\n    let inline valueStr (cn:string) (value:string) = Html.a [ prop.className cn; prop.text value ]\r\n    let inline valueInt (cn:string) (value:int) = Html.a [ prop.className cn; prop.text value ]\r\n","module Client.Index\n\nopen System\n\nopen Browser\nopen Browser.Types\nopen Elmish\nopen Fable.Core\nopen Fable.FontAwesome\nopen Fable.React\nopen Fable.React.Props\nopen Feliz\nopen Feliz.Bulma\nopen Fulma\n\nopen CineMol\nopen CineMol.Encoding\nopen CineMol.Types\nopen CineMol.Types.Geometry\nopen CineMol.Types.Chem\nopen CineMol.Types.Drawing\nopen CineMol.Parsing\nopen CineMol.Drawing\n\n/// <summary>\n/// Load example molecule penicillin G.\n/// </summary>\nlet loadExampleMolecule () : string = \"\"\"5904\n  -OEChem-12182318453D\n\n 41 43  0     1  0  0  0  0  0999 V2000\n   -0.8019    1.2308    0.5170 S   0  0  0  0  0  0  0  0  0  0  0  0\n   -2.2842   -2.5451   -1.2026 O   0  0  0  0  0  0  0  0  0  0  0  0\n   -5.3517    1.0760   -0.8170 O   0  0  0  0  0  0  0  0  0  0  0  0\n   -5.1157   -0.6970    0.5961 O   0  0  0  0  0  0  0  0  0  0  0  0\n    2.1598   -2.0405    1.2167 O   0  0  0  0  0  0  0  0  0  0  0  0\n   -2.4781   -0.7369    0.3018 N   0  0  0  0  0  0  0  0  0  0  0  0\n    0.5677   -1.3807   -0.3375 N   0  0  0  0  0  0  0  0  0  0  0  0\n   -1.3100   -0.4177    1.1279 C   0  0  1  0  0  0  0  0  0  0  0  0\n   -2.5670    1.6679    0.1134 C   0  0  0  0  0  0  0  0  0  0  0  0\n   -3.1671    0.3360   -0.3862 C   0  0  2  0  0  0  0  0  0  0  0  0\n   -0.6142   -1.6325    0.4990 C   0  0  1  0  0  0  0  0  0  0  0  0\n   -1.9181   -1.8261   -0.3007 C   0  0  0  0  0  0  0  0  0  0  0  0\n   -3.2193    2.2224    1.3871 C   0  0  0  0  0  0  0  0  0  0  0  0\n   -2.5771    2.7313   -0.9863 C   0  0  0  0  0  0  0  0  0  0  0  0\n   -4.6296    0.1576   -0.1297 C   0  0  0  0  0  0  0  0  0  0  0  0\n    1.8730   -1.6107    0.1024 C   0  0  0  0  0  0  0  0  0  0  0  0\n    2.9020   -1.2655   -0.9563 C   0  0  0  0  0  0  0  0  0  0  0  0\n    3.8679   -0.1949   -0.5225 C   0  0  0  0  0  0  0  0  0  0  0  0\n    3.5670    1.1373   -0.7687 C   0  0  0  0  0  0  0  0  0  0  0  0\n    5.0457   -0.5556    0.1171 C   0  0  0  0  0  0  0  0  0  0  0  0\n    4.4619    2.1290   -0.3670 C   0  0  0  0  0  0  0  0  0  0  0  0\n    5.9405    0.4362    0.5190 C   0  0  0  0  0  0  0  0  0  0  0  0\n    5.6486    1.7786    0.2769 C   0  0  0  0  0  0  0  0  0  0  0  0\n   -1.5167   -0.4852    2.1999 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -2.9961    0.1926   -1.4616 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -0.4509   -2.4585    1.2025 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -3.2655    1.4761    2.1882 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -2.6724    3.0921    1.7709 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -4.2446    2.5572    1.1944 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -2.0666    3.6467   -0.6644 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -2.0842    2.3779   -1.8995 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -3.6008    3.0119   -1.2561 H   0  0  0  0  0  0  0  0  0  0  0  0\n    0.4359   -1.0113   -1.2762 H   0  0  0  0  0  0  0  0  0  0  0  0\n   -6.3150    0.9762   -0.6611 H   0  0  0  0  0  0  0  0  0  0  0  0\n    3.4453   -2.1891   -1.1950 H   0  0  0  0  0  0  0  0  0  0  0  0\n    2.4229   -0.9646   -1.8960 H   0  0  0  0  0  0  0  0  0  0  0  0\n    2.6443    1.4206   -1.2675 H   0  0  0  0  0  0  0  0  0  0  0  0\n    5.2818   -1.5979    0.3120 H   0  0  0  0  0  0  0  0  0  0  0  0\n    4.2343    3.1743   -0.5548 H   0  0  0  0  0  0  0  0  0  0  0  0\n    6.8642    0.1634    1.0209 H   0  0  0  0  0  0  0  0  0  0  0  0\n    6.3451    2.5508    0.5901 H   0  0  0  0  0  0  0  0  0  0  0  0\n  1  8  1  0  0  0  0\n  1  9  1  0  0  0  0\n  2 12  2  0  0  0  0\n  3 15  1  0  0  0  0\n  3 34  1  0  0  0  0\n  4 15  2  0  0  0  0\n  5 16  2  0  0  0  0\n  6  8  1  0  0  0  0\n  6 10  1  0  0  0  0\n  6 12  1  0  0  0  0\n  7 11  1  0  0  0  0\n  7 16  1  0  0  0  0\n  7 33  1  0  0  0  0\n  8 11  1  0  0  0  0\n  8 24  1  0  0  0  0\n  9 10  1  0  0  0  0\n  9 13  1  0  0  0  0\n  9 14  1  0  0  0  0\n 10 15  1  0  0  0  0\n 10 25  1  0  0  0  0\n 11 12  1  0  0  0  0\n 11 26  1  0  0  0  0\n 13 27  1  0  0  0  0\n 13 28  1  0  0  0  0\n 13 29  1  0  0  0  0\n 14 30  1  0  0  0  0\n 14 31  1  0  0  0  0\n 14 32  1  0  0  0  0\n 16 17  1  0  0  0  0\n 17 18  1  0  0  0  0\n 17 35  1  0  0  0  0\n 17 36  1  0  0  0  0\n 18 19  2  0  0  0  0\n 18 20  1  0  0  0  0\n 19 21  1  0  0  0  0\n 19 37  1  0  0  0  0\n 20 22  2  0  0  0  0\n 20 38  1  0  0  0  0\n 21 23  2  0  0  0  0\n 21 39  1  0  0  0  0\n 22 23  1  0  0  0  0\n 22 40  1  0  0  0  0\n 23 41  1  0  0  0  0\nM  END\n$$$$\n\"\"\"\n\n/// <summary>\n/// Position of mouse on screen.\n/// </summary>\ntype MousePosition = { X: float; Y: float }\n\n/// <summary>\n/// Wheel scroll delta.\n/// </summary>\ntype WheelPosition = { Delta: float }\n\n/// <summary>\n/// Dragging state.\n/// </summary>\ntype DragTarget = | Dragging | NoTarget\n\n/// <summary>\n/// Create handlers for mouse events.\n/// </summary>\n[<RequireQualifiedAccess>]\nmodule Cmd =\n    let ups messageCtor =\n        let handler dispatch =\n            window.addEventListener(\"mouseup\", fun _ ->\n                dispatch messageCtor)\n        [ handler ]\n\n    let move messageCtor =\n        let handler dispatch =\n            window.addEventListener(\"mousemove\", fun ev ->\n                let ev = ev :?> MouseEvent\n                { X = ev.pageX; Y = ev.pageY } |> messageCtor |> dispatch)\n        [ handler ]\n\n    let wheel messageCtor =\n        let handler dispatch =\n            window.addEventListener(\"mousewheel\", fun ev ->\n                let ev = ev :?> MouseWheelEvent\n                { Delta = ev.wheelDelta } |> messageCtor |> dispatch)\n        [ handler ]\n\n/// <summary>\n/// Viewer background colors (i.e., dark and light modes).\n/// </summary>\ntype ViewerBackgroundColor = | Dark | Light\n    with\n    override this.ToString() =\n        match this with | Dark -> \"#000\" | Light -> \"#f0f0f0\"\n\n/// <summary>\n/// App model.\n/// </summary>\ntype Model =\n    { Molecule: Molecule option\n      DrawingOptions: DrawingOptions\n      SvgString: string option\n      EncodedSvgString: string option\n      DragTarget: DragTarget\n      ViewerBackgroundColor: ViewerBackgroundColor\n      SidebarCollapsed: bool\n      PreviousMousePosition: MousePosition option\n      IsRendering: bool }\n    with\n    static member New () =\n        { Molecule = None\n          DrawingOptions = DrawingOptions.New()\n          SvgString = None\n          EncodedSvgString = None\n          DragTarget = NoTarget\n          ViewerBackgroundColor = Light\n          SidebarCollapsed = false\n          PreviousMousePosition = None\n          IsRendering = false }\n    member this.Reset () =\n        { Model.New() with\n            ViewerBackgroundColor = this.ViewerBackgroundColor\n            SidebarCollapsed = this.SidebarCollapsed }\n\n/// <summary>\n/// App messages.\n/// </summary>\ntype Msg =\n    // User interface.\n    | UploadSdf of name: string * content: string\n    | ResetViewer\n    | DownloadSvg\n    | ToggleDepiction\n    | ToggleArt\n    | ToggleBackgroundColor\n    | ToggleHydrogenAtoms\n    | LoadExample\n    | HighResolution\n    | ToggleSidebar\n\n    // Rendering.\n    | Render\n    | GotEncodedSvg of svgString: string option * encodedSvgString: string option\n    | SetRotation of xRotation: float * yRotation: float\n\n    // Mouse events.\n    | MouseUp\n    | MouseMove of MousePosition\n    | MouseDrag of MousePosition\n    | MouseDragStarted of MousePosition\n    | MouseDragEnded\n    | MouseWheelScroll of WheelPosition\n\n/// <summary>\n/// Initialize app.\n/// </summary>\nlet init () : Model * Cmd<Msg> =\n    Model.New(),\n    Cmd.batch [ Cmd.ups MouseUp; Cmd.move MouseMove; Cmd.wheel MouseWheelScroll ]\n\n/// <summary>\n/// Element that creates file picker pop-up.\n/// </summary>\nlet uploadFileEvent dispatch =\n    Fulma.File.input [\n        Props [\n            OnInput (\n                fun ev ->\n                    let file = (ev.target :?> HTMLInputElement).files[0]\n                    let name = file.name\n                    let reader = FileReader.Create()\n                    reader.onload <- fun _ ->\n                        let content = reader.result :?> string\n                        (name, content) |> UploadSdf |> dispatch\n                    reader.readAsText file\n\n                    // Setting value to empty string removes cached filename again and makes sure you can upload the\n                    // same file (after refresh) for a second time.\n                    (ev.target :?> HTMLInputElement).value <- \"\"\n            )\n        ]\n    ]\n\n/// <summary>\n/// Download text to file to downloads folder.\n/// </summary>\nlet private downloadSvgEvent (svgString: string option) (fileName: string) =\n    match svgString with\n    | Some svgString ->\n        let anchor = Dom.document.createElement \"a\"\n        let encodedSvgString =\n            svgString\n            |> sprintf \"data:text/plain;charset=utf-8,%s\"\n            |> JS.encodeURI\n            |> (fun msg -> msg.Replace(\"#\", \"%23\"))\n        anchor.setAttribute(\"href\", encodedSvgString)\n        anchor.setAttribute(\"download\", fileName)\n        anchor.click()\n    | None -> ()\n\n/// <summary>\n/// 'Render' molecule model.\n/// </summary>\nlet render (model: Model) =\n    async {\n        match model.Molecule with\n        | Some molecule ->\n            let svg, options = draw molecule model.DrawingOptions\n            let svgString = svg.ToString()\n            let encodedSvgString = ISO_8859_1.Encode svgString |> Convert.ToBase64String\n            return Some svgString, Some encodedSvgString\n        | None -> return None, None\n    }\n\n/// <summary>\n/// Update model.\n/// </summary>\nlet update (msg: Msg) (model: Model) : Model * Cmd<Msg> =\n    match msg with\n\n    // Upload SDF file and read and parse contents into Molecule object.\n    | UploadSdf (_, content) ->\n        match (FileParser Sdf).Parse content with\n        | Some (molecule::_) -> { model with Molecule = Some molecule }, Cmd.ofMsg Render\n        | _ -> model, Cmd.none // TODO: get error toast when parsing fails/file is empty\n\n    // Reset viewer.\n    | ResetViewer ->\n        let newModel = model.Reset()\n        newModel, Cmd.OfAsync.perform render newModel GotEncodedSvg\n\n    // Download SVG to downloads folder.\n    | DownloadSvg ->\n        downloadSvgEvent model.SvgString \"model.svg\"\n        model, Cmd.none\n\n    // Toggle model depiction.\n    | ToggleDepiction ->\n        let depiction : ModelStyle =\n            match model.DrawingOptions.ModelStyle with\n            | SpaceFilling -> BallAndStick\n            | BallAndStick -> WireFrame\n            | WireFrame -> SpaceFilling\n        let newModel = { model with DrawingOptions = { model.DrawingOptions with ModelStyle = depiction } }\n        newModel, Cmd.OfAsync.perform render newModel GotEncodedSvg\n\n    // Toggle art style.\n    | ToggleArt ->\n        let art : ArtStyle =\n            match model.DrawingOptions.ArtStyle with\n            | Cartoon -> Glossy\n            | Glossy -> Cartoon\n        let newModel = { model with DrawingOptions = { model.DrawingOptions with ArtStyle = art } }\n        newModel, Cmd.OfAsync.perform render newModel GotEncodedSvg\n\n    // Toggle background color (i.e., dark and light mode).\n    | ToggleBackgroundColor ->\n        let backgroundColor = if model.ViewerBackgroundColor = Dark then Light else Dark\n        let newModel = { model with ViewerBackgroundColor = backgroundColor }\n        newModel, Cmd.none\n\n    // Toggle displaying of hydrogen atoms.\n    | ToggleHydrogenAtoms ->\n        let toggle = not model.DrawingOptions.DisplayHydrogenAtoms\n        let newModel = { model with DrawingOptions = { model.DrawingOptions with DisplayHydrogenAtoms = toggle } }\n        newModel, Cmd.OfAsync.perform render newModel GotEncodedSvg\n\n    // Load  example molecule.\n    | LoadExample ->\n        let content = loadExampleMolecule()\n        match (FileParser Sdf).Parse content with\n        | Some (molecule::_) -> { model with Molecule = Some molecule }, Cmd.ofMsg Render\n        | _ ->\n            printfn \"ERROR: Could not parse example molecule.\"\n            model, Cmd.none // TODO: get error toast when parsing fails/file is empty\n\n    // Draw current model in high resolution.\n    | HighResolution ->\n        let newModel = { model with DrawingOptions = { model.DrawingOptions with Resolution = 200 } }\n        { newModel with IsRendering = true }, Cmd.OfAsync.perform render newModel GotEncodedSvg\n\n    // Toggle sidebar between expanded and collapsed.\n    | ToggleSidebar ->\n        let newModel = { model with SidebarCollapsed = not model.SidebarCollapsed }\n        newModel, Cmd.none\n\n    // 'Render' molecule model.\n    | Render -> model, Cmd.OfAsync.perform render model GotEncodedSvg\n\n    // Process 'rendered' model.\n    | GotEncodedSvg (svgString, encodedSvgString) ->\n        let defaultOptions = DrawingOptions.New()\n        { model with\n            DrawingOptions = { model.DrawingOptions with Resolution = defaultOptions.Resolution }\n            IsRendering = false\n            SvgString = svgString\n            EncodedSvgString = encodedSvgString }\n        , Cmd.none\n\n    // Set new rotation of molecule model.\n    | SetRotation (x, y) ->\n        match model.Molecule with\n        | Some molecule ->\n            let rotateAtom (atom : Atom) =\n                let rotate axis pos (p: Point3D) = p.Rotate axis pos\n                let rotatedCenter = atom.Position |> rotate Axis.X x |> rotate Axis.Y y\n                { atom with Position = rotatedCenter }\n            let rotatedAtoms = molecule.Atoms |> List.map (fun a -> rotateAtom a)\n            let rotatedMolecule = { molecule with Atoms = rotatedAtoms }\n            let newModel = { model with Molecule = Some rotatedMolecule }\n            newModel, Cmd.OfAsync.perform render newModel GotEncodedSvg\n        | None -> model, Cmd.none\n\n    // Mouse up indicates the end of a drag event.\n    | MouseUp -> model, Cmd.ofMsg MouseDragEnded\n\n    // Relay mouse drag.\n    | MouseMove pos -> model, Cmd.ofMsg (MouseDrag pos)\n\n    // Set start of drag event.\n    | MouseDragStarted pos -> { model with DragTarget = Dragging }, Cmd.none\n\n    // Set end of drag event.\n    | MouseDragEnded -> { model with DragTarget = NoTarget }, Cmd.none\n\n    // Register dragging movement.\n    | MouseDrag (pos: MousePosition) ->\n        let cmd =\n            match model.PreviousMousePosition with\n            | Some prevPos ->\n                match model.DragTarget with\n                | Dragging ->\n                    let xRotation = (prevPos.Y - pos.Y) / 180.0\n                    let yRotation = (prevPos.X - pos.X) / 180.0\n                    Cmd.ofMsg (SetRotation (xRotation, -1.0 * yRotation))\n                | _ -> Cmd.none\n            | None -> Cmd.none\n\n        let newModel = { model with PreviousMousePosition = Some pos }\n        newModel, cmd\n\n    // Register mouse scroll.\n    | MouseWheelScroll (pos: WheelPosition) ->\n        // TODO: implement zoom\n        model, Cmd.none\n\n/// <summary>\n/// Sidebar element.\n/// </summary>\nlet sidebar model dispatch =\n    let uploadFileButton dispatch =\n        Bulma.button.a [\n            prop.className (\"sidebar-button \" + match model.SidebarCollapsed with | true -> \"collapsed\" | false -> \"expanded\")\n            prop.children [\n                Fa.i [ Fa.Solid.Upload ] []\n                Html.span [ prop.style [ style.marginLeft (length.em 0.5) ]; prop.text (if model.SidebarCollapsed then \"\" else \"Upload file\") ]\n                uploadFileEvent dispatch\n            ]\n        ]\n\n    let generalButton action  icon  (label: string) =\n        Bulma.button.a [\n            prop.className (\"sidebar-button \" + match model.SidebarCollapsed with | true -> \"collapsed\" | false -> \"expanded\")\n            prop.children [\n                Fa.i [ icon ] []\n                Html.span [ prop.style [ style.marginLeft (length.em 0.5) ]; prop.text (if model.SidebarCollapsed then \"\" else label) ]\n            ]\n            prop.onClick (fun _ -> dispatch action)\n        ]\n\n    let rec toggleHydrogenAtoms dispatch =\n        Bulma.button.a [\n            prop.className (\"sidebar-button \" + match model.SidebarCollapsed with | true -> \"collapsed\" | false -> \"expanded\")\n            prop.children [\n                Fa.i [ Fa.Solid.Atom ] []\n                Html.span [ prop.style [ style.marginLeft (length.em 0.5) ]; prop.text (if model.SidebarCollapsed then \"\" else \"Toggle hydrogens\") ]\n            ]\n            prop.onClick (fun _ -> dispatch ToggleHydrogenAtoms)\n        ]\n\n    let reportBugButton =\n        Bulma.button.a [\n            prop.className (\"sidebar-button \" + match model.SidebarCollapsed with | true -> \"collapsed\" | false -> \"expanded\")\n            prop.href \"https://github.com/moltools/cinemol/issues\"\n            prop.rel \"noreffer noopener\"\n            prop.target \"_blank\"\n            prop.children [\n                Fa.i [ Fa.Solid.Bug ] []\n                Html.span [ prop.style [ style.marginLeft (length.em 0.5) ]; prop.text (if model.SidebarCollapsed then \"\" else \"Report bug\") ]\n            ]\n        ]\n\n    Html.div [\n        prop.className (\"sidebar \" + match model.SidebarCollapsed with | true -> \"collapsed\" | false -> \"expanded\")\n        prop.children [\n\n            Html.span [\n                prop.className \"version\"\n                if model.SidebarCollapsed then prop.children [ Html.div [ prop.className \"version collapsed\" ] ]\n                else prop.text $\"CineMol v{Version.version}\"\n            ]\n\n            uploadFileButton dispatch\n            generalButton DownloadSvg Fa.Solid.Download \"Download\"\n            generalButton ResetViewer Fa.Solid.Sync \"Refresh\"\n            generalButton ToggleBackgroundColor Fa.Solid.Adjust \"Toggle background\"\n            generalButton ToggleDepiction Fa.Solid.Eye \"Toggle depiction\"\n            generalButton ToggleArt Fa.Solid.PaintBrush \"Toggle styling\"\n            toggleHydrogenAtoms dispatch\n            generalButton LoadExample Fa.Solid.Seedling \"Load example\"\n            generalButton HighResolution Fa.Solid.DrawPolygon \"High resolution\"\n            reportBugButton\n\n            Html.div [\n                prop.className \"collapse-button\"\n                prop.children [ Fa.i [ (if model.SidebarCollapsed then Fa.Solid.AngleDoubleRight else Fa.Solid.AngleDoubleLeft) ] [] ]\n                prop.onClick (fun _ -> ToggleSidebar |> dispatch)\n            ]\n\n        ]\n    ]\n\n/// <summary>\n/// Viewer element.\n/// </summary>\nlet viewer model dispatch =\n    let viewerStyle =\n        let sidebarWidth = match model.SidebarCollapsed with | true -> 60 | false -> 210\n        let width = int window.innerWidth - sidebarWidth\n        let height = int window.innerHeight\n        if width < height then [ style.width width; style.height width ]\n        else [ style.width height; style.height height ]\n\n    let encodedSvgString =\n        match model.EncodedSvgString with\n        | None -> \"\"\n        | Some s -> sprintf \"data:image/svg+xml;base64,%s\" s\n\n    Html.div [\n        prop.className \"viewer\"\n        prop.style viewerStyle\n        prop.onMouseDown (fun ev ->\n            ev.preventDefault()\n            dispatch (MouseDragStarted { X = ev.pageX; Y = ev.pageY }))\n        prop.children [\n            img [ Style [ BackgroundColor (model.ViewerBackgroundColor.ToString()) ]; Src encodedSvgString ]\n        ]\n    ]\n\n/// <summary>\n/// Loading indicator.\n/// </summary>\nlet viewerRendering =\n    Html.div [\n        prop.className \"loading\"\n        prop.children [\n            Html.span [ prop.text \"Loading...\" ]\n        ]\n    ]\n\n/// <summary>\n/// Main app view.\n/// </summary>\nlet view (model: Model) (dispatch: Msg -> unit) =\n    Html.div [\n        prop.className \"app\"\n        prop.style [ style.backgroundColor (model.ViewerBackgroundColor.ToString()) ]\n        prop.children [\n            sidebar model dispatch\n            match model.IsRendering with\n            | false -> viewer model dispatch\n            | true -> viewerRendering\n        ]\n    ]","namespace Elmish.React\n\n[<AutoOpen>]\nmodule Helpers =\n    open Fable.React.Props\n    open Fable.Core.JsInterop\n\n    /// `Ref` callback that sets the value of an input textbox after DOM element is created.\n    /// Can be used instead of `DefaultValue` and `Value` props to override input box value.\n    let inline valueOrDefault value =\n        Ref <| (fun e -> if e |> isNull |> not && !!e?value <> !!value then e?value <- !!value)\n\n[<RequireQualifiedAccess>]\nmodule Program =\n\n    module Internal =\n\n        open Fable.React\n        open Browser\n        open Elmish\n\n        let withReactBatchedUsing lazyView2With placeholderId (program:Program<_,_,_,_>) =\n            let mutable lastRequest = None\n            let setState model dispatch =\n                match lastRequest with\n                | Some r -> window.cancelAnimationFrame r\n                | _ -> ()\n\n                lastRequest <- Some (window.requestAnimationFrame (fun _ ->\n                    ReactDom.render(\n                        lazyView2With (fun x y -> obj.ReferenceEquals(x,y)) (Program.view program) model dispatch,\n                        document.getElementById placeholderId\n                    )))\n\n            program\n            |> Program.withSetState setState\n\n        let withReactSynchronousUsing lazyView2With placeholderId (program:Elmish.Program<_,_,_,_>) =\n            let setState model dispatch =\n                ReactDom.render(\n                    lazyView2With (fun x y -> obj.ReferenceEquals(x,y)) (Program.view program) model dispatch,\n                    document.getElementById placeholderId\n                )\n\n            program\n            |> Program.withSetState setState\n\n        let withReactHydrateUsing lazyView2With placeholderId (program:Elmish.Program<_,_,_,_>) =\n            let setState model dispatch =\n                ReactDom.hydrate(\n                    lazyView2With (fun x y -> obj.ReferenceEquals(x,y)) (Program.view program) model dispatch,\n                    document.getElementById placeholderId\n                )\n\n            program\n            |> Program.withSetState setState\n\n\n    /// Renders React root component inside html element identified by placeholderId.\n    /// Uses `requestAnimationFrame` to batch updates to prevent drops in frame rate.\n    /// NOTE: This may have unexpected effects in React controlled inputs, see https://github.com/elmish/react/issues/12\n    let withReactBatched placeholderId (program:Elmish.Program<_,_,_,_>) =\n        Internal.withReactBatchedUsing lazyView2With placeholderId program\n\n    /// Renders React root component inside html element identified by placeholderId.\n    /// New renders are triggered immediately after an update.\n    let withReactSynchronous placeholderId (program:Elmish.Program<_,_,_,_>) =\n        Internal.withReactSynchronousUsing lazyView2With placeholderId program\n\n    [<System.Obsolete(\"Use withReactBatched\")>]\n    let withReact placeholderId (program:Elmish.Program<_,_,_,_>) =\n        Internal.withReactBatchedUsing lazyView2With placeholderId program\n\n    [<System.Obsolete(\"Use withReactSynchronous\")>]\n    let withReactUnoptimized placeholderId (program:Elmish.Program<_,_,_,_>) =\n        Internal.withReactSynchronousUsing lazyView2With placeholderId program\n\n    /// Renders React root component inside html element identified by placeholderId using `React.hydrate`.\n    let withReactHydrate placeholderId (program:Elmish.Program<_,_,_,_>) =\n        Internal.withReactHydrateUsing lazyView2With placeholderId program\n","(**\nProgram\n---------\nCore abstractions for creating and running the dispatch loop.\n\n*)\n\nnamespace Elmish\n\n\n/// Program type captures various aspects of program behavior\ntype Program<'arg, 'model, 'msg, 'view> = private {\n    init : 'arg -> 'model * Cmd<'msg>\n    update : 'msg -> 'model -> 'model * Cmd<'msg>\n    subscribe : 'model -> Cmd<'msg>\n    view : 'model -> Dispatch<'msg> -> 'view\n    setState : 'model -> Dispatch<'msg> -> unit\n    onError : (string*exn) -> unit\n    syncDispatch: Dispatch<'msg> -> Dispatch<'msg>\n}\n\n/// Program module - functions to manipulate program instances\n[<RequireQualifiedAccess>]\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule Program =\n    /// Typical program, new commands are produced by `init` and `update` along with the new state.\n    let mkProgram \n        (init : 'arg -> 'model * Cmd<'msg>) \n        (update : 'msg -> 'model -> 'model * Cmd<'msg>)\n        (view : 'model -> Dispatch<'msg> -> 'view) =\n        { init = init\n          update = update\n          view = view\n          setState = fun model -> view model >> ignore\n          subscribe = fun _ -> Cmd.none\n          onError = Log.onError\n          syncDispatch = id }\n\n    /// Simple program that produces only new state with `init` and `update`.\n    let mkSimple \n        (init : 'arg -> 'model) \n        (update : 'msg -> 'model -> 'model)\n        (view : 'model -> Dispatch<'msg> -> 'view) =\n        { init = init >> fun state -> state,Cmd.none\n          update = fun msg -> update msg >> fun state -> state,Cmd.none\n          view = view\n          setState = fun model -> view model >> ignore\n          subscribe = fun _ -> Cmd.none\n          onError = Log.onError\n          syncDispatch = id }\n\n    /// Subscribe to external source of events.\n    /// The subscription is called once - with the initial model, but can dispatch new messages at any time.\n    let withSubscription (subscribe : 'model -> Cmd<'msg>) (program: Program<'arg, 'model, 'msg, 'view>) =\n        let sub model =\n            Cmd.batch [ program.subscribe model\n                        subscribe model ]\n        { program with subscribe = sub }\n\n    /// Trace all the updates to the console\n    let withConsoleTrace (program: Program<'arg, 'model, 'msg, 'view>) =\n        let traceInit (arg:'arg) =\n            let initModel,cmd = program.init arg\n            Log.toConsole (\"Initial state:\", initModel)\n            initModel,cmd\n\n        let traceUpdate msg model =\n            Log.toConsole (\"New message:\", msg)\n            let newModel,cmd = program.update msg model\n            Log.toConsole (\"Updated state:\", newModel)\n            newModel,cmd\n\n        { program with\n            init = traceInit \n            update = traceUpdate }\n\n    /// Trace all the messages as they update the model\n    let withTrace trace (program: Program<'arg, 'model, 'msg, 'view>) =\n        let update msg model =\n            let state,cmd = program.update msg model\n            trace msg state\n            state,cmd\n        { program\n            with update = update }\n\n    /// Handle dispatch loop exceptions\n    let withErrorHandler onError (program: Program<'arg, 'model, 'msg, 'view>) =\n        { program\n            with onError = onError }\n\n    /// For library authors only: map existing error handler and return new `Program` \n    let mapErrorHandler map (program: Program<'arg, 'model, 'msg, 'view>) =\n        { program\n            with onError = map program.onError }\n\n    /// For library authors only: get the current error handler \n    let onError (program: Program<'arg, 'model, 'msg, 'view>) =\n        program.onError\n\n    /// For library authors only: function to render the view with the latest state \n    let withSetState (setState:'model -> Dispatch<'msg> -> unit)\n                     (program: Program<'arg, 'model, 'msg, 'view>) =        \n        { program\n            with setState = setState }\n\n    /// For library authors only: return the function to render the state \n    let setState (program: Program<'arg, 'model, 'msg, 'view>) =        \n        program.setState\n\n    /// For library authors only: return the view function \n    let view (program: Program<'arg, 'model, 'msg, 'view>) =        \n        program.view\n\n    /// For library authors only: function to synchronize the dispatch function\n    let withSyncDispatch (syncDispatch:Dispatch<'msg> -> Dispatch<'msg>)\n                         (program: Program<'arg, 'model, 'msg, 'view>) =        \n        { program\n            with syncDispatch = syncDispatch }\n\n    /// For library authors only: map the program type\n    let map mapInit mapUpdate mapView mapSetState mapSubscribe\n            (program: Program<'arg, 'model, 'msg, 'view>) =\n        { init = mapInit program.init\n          update = mapUpdate program.update\n          view = mapView program.view\n          setState = mapSetState program.setState\n          subscribe = mapSubscribe program.subscribe\n          onError = program.onError\n          syncDispatch = id }\n\n    /// Start the program loop.\n    /// arg: argument to pass to the init() function.\n    /// program: program created with 'mkSimple' or 'mkProgram'.\n    let runWith (arg: 'arg) (program: Program<'arg, 'model, 'msg, 'view>) =\n        let (model,cmd) = program.init arg\n        let rb = RingBuffer 10\n        let mutable reentered = false\n        let mutable state = model        \n        let rec dispatch msg = \n            if reentered then\n                rb.Push msg\n            else\n                reentered <- true\n                let mutable nextMsg = Some msg\n                while Option.isSome nextMsg do\n                    let msg = nextMsg.Value\n                    try\n                        let (model',cmd') = program.update msg state\n                        program.setState model' syncDispatch\n                        cmd' |> Cmd.exec (fun ex -> program.onError (sprintf \"Error in command while handling: %A\" msg, ex)) syncDispatch\n                        state <- model'\n                    with ex ->\n                        program.onError (sprintf \"Unable to process the message: %A\" msg, ex)\n                    nextMsg <- rb.Pop()\n                reentered <- false\n        and syncDispatch = program.syncDispatch dispatch            \n\n        program.setState model syncDispatch\n        let sub = \n            try \n                program.subscribe model \n            with ex ->\n                program.onError (\"Unable to subscribe:\", ex)\n                Cmd.none\n        Cmd.batch [sub; cmd]\n        |> Cmd.exec (fun ex -> program.onError (\"Error intitializing:\", ex)) syncDispatch\n\n    /// Start the dispatch loop with `unit` for the init() function.\n    let run (program: Program<unit, 'model, 'msg, 'view>) = runWith () program\n","module App\n\nopen Client\nopen Index\nopen Elmish\nopen Elmish.React\n\n#if DEBUG\nopen Elmish.Debug\nopen Elmish.HMR\n#endif\n\nProgram.mkProgram init update view\n#if DEBUG\n|> Program.withConsoleTrace\n#endif\n|> Program.withReactSynchronous \"elmish-app\"\n#if DEBUG\n|> Program.withDebugger\n#endif\n|> Program.run"],"names":["x","Array","isArray","ArrayBuffer","isView","Dispose","sameConstructor","y","Object","getPrototypeOf","constructor","Enumerator","iter","this","current","cur","next","value","done","Error","o","GetEnumerator","Symbol","iterator","en","hasNext","undefined","padWithZeros","i","length","str","toString","date","date1","offset","kind","getTimezoneOffset","ObjectRef","static","idMap","has","set","count","get","stringHash","s","h","len","charCodeAt","numberHash","combineHashCodes","hashes","reduce","h1","h2","structuralHash","GetHashCode","isHashable","arrayHash","Date","getTime","dateHash","values","map","v","id","equalArraysWith","eq","Equals","isEquatable","xKeys","keys","yKeys","sort","equalObjects","xtime","ytime","compareArrays","comp","j","compareArraysWith","compare","CompareTo","isComparable","key","compareObjects","max","comparer","createObj","fields","obj","kv","WeakMap","CURRIED","arity","f","uncurried","args","res","_curry","arg","concat","callStack","self","seqToString","cons","entries","k","join","name","String","cases","tag","toJSON","fieldStr","withParens","indexOf","unionToString","splice","other","recordToJSON","recordToString","recordGetHashCode","recordEquals","thisNames","recordCompareTo","result","FSharpRef","contentsOrGetter","setter","getter","contents","dateOffsetToString","isMinus","minutes","Math","abs","dateToHalfUTCString","half","toISOString","substring","dateToStringWithCustomFormat","format","utc","replace","match","rep","Number","NaN","getUTCFullYear","getFullYear","getUTCMonth","getMonth","getUTCDate","getDate","getUTCHours","getHours","getUTCMinutes","getMinutes","getUTCSeconds","getSeconds","getUTCMilliseconds","getMilliseconds","isNaN","symbol","sd","toPrecision","dp","toExponential","toHex","pattern","options","flags","RegExp","reg","input","startAt","lastIndex","exec","fsFormatRegExp","interpolateRegExp","printf","cont","strParts","matches","strIdx","matchIndex","index","push","createPrinter","interpolate","valIdx","padLength","precision","formatReplacement","continuePrint","toConsole","console","log","toText","sign","toLowerCase","isLessThan","multiply","parseInt","toFixed","toUpperCase","_provider","_a","_b","_c","d","dateWithOffset","dateToISOStringWithOffset","dateToStringWithOffset","toUTCString","toLocaleString","toLocaleDateString","toLocaleTimeString","printOffset","dateToISOString","dateToStringWithKind","zeroFlag","minusFlag","ch","padLeft","_strParts","_matches","_result","padArg","slice","_padLength","delimiter","xs","from","isRight","Some","Helpers_allocateArrayFromCons","fill","target","targetIndex","start","source","head","tail","super","xs_1_mut","ys_1_mut","loop","xs_1","ys_1","matchValue","xt","yt","i_mut","h_mut","t","_key","c","ListEnumerator$1","it","__","FSharpList_get_Empty","FSharpList_Cons_305B8EAC","FSharpList__get_IsEmpty","FSharpList__get_Length","FSharpList__get_Head","FSharpList__get_Tail","folder","state","acc","action","unitVar0","ofArrayWithTail","tail_1","lists","root","node","forEach","enumerator","xs_6","t_2","ys","mapping","acc_mut","n","FSharpList__get_Item_Z524259A4","projection","arr","Compare","setPrototypeOf","prototype","Trampoline","callCount","maxTrampolineCallCount","incrementAndCheck","hijack","setTimeout","ctx","cancelToken","isCancelled","onCancel","trampoline","err","onError","Bind","computation","binder","onSuccess","ex","Combine","computation1","computation2","Delay","generator","For","sequence","body","While","Return","ReturnFrom","TryFinally","compensation","TryWith","catchHandler","ex2","Using","resource","guard","Zero","FSharpChoice$2","emptyContinuation","_x","defaultCancellationToken","cancelled","_id","_cancelled","_listeners","Map","cancel","listener","addListener","removeListener","delete","register","$","startImmediate","cancellationToken","continuation","exceptionContinuation","cancellationContinuation","startWithContinuations","delegates","Add","_addHandler","Publish","Trigger","senderOrValue","valueOrUndefined","sender","AddHandler","handler","RemoveHandler","_removeHandler","Subscribe","callback","OnNext","onNext","onCompleted","OnError","_e","OnCompleted","interval","returnVal","_enabled","_isDisposed","_intervalId","_timeoutId","Interval","AutoReset","_elapsed","Elapsed","Enabled","setInterval","clearTimeout","clearInterval","Close","Start","Stop","dispatch","cmd","call","cmds","msg","task","ofSuccess","work","Choice_makeChoice1Of2","_arg1","r","Enumerator_notStarted","Enumerator_alreadyFinished","Enumerator_Seq","e","Enumerator_FromFunctions$1","dispose","Enumerator_noReset","Enumerator_FromFunctions$1_$ctor_58C54629","Enumerator_generateWhileSome","openf","compute","closef","curr","started","x_1","finish","matchValue_1","mkSeq","Enumerator_Seq_$ctor_673A07F2","argName","Operators_NullArg","sources","outerOpt","innerOpt","finished","inner","outer","copyOfStruct","inner_1","outer_1","Enumerator_concat","ar","xs_3","xs_5","ofSeq","create","e_1","_","Enumerator_enumerateThenFinally","integralRangeStep","step","stop","zero","add","stepFn","stepComparedWithZero","stepGreaterThanZero","comparedWithLast","makeRangeStepFunction","st_1","Enumerator_unfold","size","wix","rix","items","rix'","item","wix'","ix","props","nextProps","_nextState","model","alpha","diffuseChannel","tupledArg","Color","p1","p2","X","Y","arg00","Z","atomString","bondString","centroid","ps","atom","Position","(+)","atomIndex","Index","includeHydrogenAtoms","bond","beginAtom","endAtom","EndAtomIndex","color","center","cx","cy","styles","objs","style","opacity","pointsStr","p","p4","p3","r1","r2","path","circle","Center","Radius","defs","points","TypeInfo","fullname","generics","construct","parent","enumCases","fullName","getHashCode","getGenerics","t1","t2","getRecordElements","k1","v1","k2","v2","elemType","getElementType","assertUnion","case","screen","radix","cl","option","modifiers","arg10","level","display","typ","amount","direction","dashify","separator","m","charAt","caseRule","definedCaseRule","fail","kvPair","assign","changeCase","parser","baseClass","baseProps","cls","currAtom","intersectsWith","resolution","sphere","otherSpheres","point","otherSphere","N","numPointsPhi","phis","numPointsTheta","thetas","phi","z","theta","minIndex","maxIndex","createRange","processPoints","pointList","a","b","W","signedDist","maxDistIndex","newIndexList","tuple","left","right","quickHull2D","prevAtoms","currAtomGeom","makePolygon","radius","numPoints","dx","dy","sqrt","ux","uy","width","index1","index2","color1","color2","opacity1","opacity2","points1","calculatePerpendicularPoints","midPoints","points2","patternInput","b1","b2","b3","b4","b5","b6","b7","b8","a2","a1","BeginAtomIndex","BeginIndex","EndIndex","Opacity","Type","drawSingleBond","midPoint","src","chooser","array","defValue","test","NumberStyles","getRange","unsigned","bitsize","prefix","digits","AllowHexSpecifier","getRadix","invalidDigits","getInvalidDigits","regexMatch","validResponse","isValid","umin","umax","min","message","fileContent","list2","d_cap","atomLine","bondLine","atoms","bonds","line","atomSymbol","activePatternResult26327","g","atomType","ParserError","bondType","e_idx","s_idx","activePatternResult26326","baseElement","opts","children","std","Icon","Size","Border","Pull","Rotation","Flip","CustomClass","StackSize","booleans","FixedWidth","IsLi","HavePulse","HaveSpin","IsInverse","complete","opt","Props","faOptions","cn","classes","messageCtor","window","ev","wheelDelta","file","reader","FileReader","Molecule","svgString","mol","origin","viewBox","Atoms","ViewBox","DisplayHydrogenAtoms","ModelStyle","atomRadiusCorrection","processAtoms","shapes","shape","atomToSvg","Resolution","prevAtomIndices","bondToSvg","bondToWire","ArtStyle","DrawingOptions","encodedSvgString","inArray","fromCharCode","btoa","notSupported","elems","program","view","init","rb","reentered","syncDispatch","nextMsg","update","model'","subscribe","properties","generalButton","icon","label","SidebarCollapsed","reportBugButton","uploadFileEvent","_arg2","_arg3","viewerRendering","css","viewerStyle","sidebarWidth","innerWidth","height","innerHeight","EncodedSvgString","pageX","pageY","arg0","inputRecord","prevPos","newModel","render","fileName","anchor","downloadSvgEvent","SvgString","ViewerBackgroundColor","FileParser","molecule","rotate","axis","pos","rad","PreviousMousePosition","text","lazyView2With","placeholderId","setState","document","getElementById","equal"],"sourceRoot":""}